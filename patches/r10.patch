--- /tmp/index_before_r3.html	2026-02-19 03:01:25
+++ index.html	2026-02-19 09:09:30
@@ -6,6 +6,7 @@
   <title>Figure Maker</title>
   <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/svg2pdf.js@2.5.0/dist/svg2pdf.umd.min.js"></script>
+  <script src="https://cdn.jsdelivr.net/npm/canvg@4.0.2/lib/umd.min.js"></script>
   <style>
     :root {
       --bg: #f3f4f6;
@@ -79,6 +80,12 @@
       stroke-dasharray: 6 3;
       pointer-events: none;
     }
+    .selection-handle {
+      fill: #ffffff;
+      stroke: var(--accent);
+      stroke-width: 1.5;
+      cursor: nwse-resize;
+    }
     .context-menu {
       position: fixed;
       background: #fff;
@@ -136,8 +143,14 @@
       <div class="group">
         <button id="groupBtn">Group</button>
         <button id="ungroupBtn">Ungroup</button>
+        <button id="duplicateBtn">Duplicate</button>
       </div>
       <div class="group">
+        <label for="alignBasisSelect">Align base</label>
+        <select id="alignBasisSelect">
+          <option value="bbox">Selection Box</option>
+          <option value="first">First Selected</option>
+        </select>
         <button data-align="left">Align L</button>
         <button data-align="hcenter">Align C</button>
         <button data-align="right">Align R</button>
@@ -176,6 +189,7 @@
     const XLINK_NS = "http://www.w3.org/1999/xlink";
     const AUTOSAVE_KEY = "figureMaker_autosave_records";
     const AUTOSAVE_INTERVAL_KEY = "figureMaker_autosave_interval";
+    const ALIGN_BASIS_KEY = "figureMaker_align_basis";
 
     const canvas = document.getElementById("canvas");
     const statusEl = document.getElementById("status");
@@ -191,7 +205,8 @@
       maxHistory: 100,
       interaction: null,
       autosaveTimer: null,
-      contextGroupId: null
+      contextGroupId: null,
+      alignBasis: "bbox"
     };
 
     function setStatus(msg) {
@@ -209,6 +224,39 @@
       if (!el.dataset.id) el.dataset.id = createId();
     }
 
+    function applyPointerEventPolicy(el) {
+      if (!(el instanceof SVGElement) || el === canvas) return;
+      if (el.tagName === "line" || el.tagName === "path" || el.tagName === "polyline") {
+        el.setAttribute("pointer-events", "stroke");
+        return;
+      }
+      if (el.tagName === "text") {
+        el.setAttribute("pointer-events", "bounding-box");
+        return;
+      }
+      if (el.tagName !== "g") el.setAttribute("pointer-events", "all");
+    }
+
+    function sanitizeSvgTree(root) {
+      if (!(root instanceof SVGElement)) return;
+      root.querySelectorAll("script,foreignObject,iframe,object,embed").forEach((el) => el.remove());
+      const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
+      while (walker.nextNode()) {
+        const el = walker.currentNode;
+        if (!(el instanceof SVGElement)) continue;
+        for (const attr of Array.from(el.attributes)) {
+          const name = attr.name.toLowerCase();
+          const value = String(attr.value || "");
+          if (name.startsWith("on")) el.removeAttribute(attr.name);
+          if ((name === "href" || name.endsWith(":href")) && value.trim().toLowerCase().startsWith("javascript:")) {
+            el.removeAttribute(attr.name);
+          }
+        }
+        applyPointerEventPolicy(el);
+      }
+      applyPointerEventPolicy(root);
+    }
+
     function assignIds(root = canvas) {
       const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
       let maxNum = state.idCounter;
@@ -216,6 +264,7 @@
         const el = walker.currentNode;
         if (!(el instanceof SVGElement)) continue;
         ensureId(el);
+        applyPointerEventPolicy(el);
         if (el.dataset.id && /^obj-(\d+)$/.test(el.dataset.id)) {
           const n = Number(el.dataset.id.replace("obj-", ""));
           if (n >= maxNum) maxNum = n + 1;
@@ -264,7 +313,7 @@
     }
 
     function renderSelectionOutlines() {
-      canvas.querySelectorAll(".selection-outline").forEach((el) => el.remove());
+      canvas.querySelectorAll(".selection-outline,.selection-handle").forEach((el) => el.remove());
       const elements = getTopSelectedElements();
       elements.forEach((el) => {
         const b = safeBBox(el);
@@ -276,6 +325,37 @@
         rect.setAttribute("width", String(b.width));
         rect.setAttribute("height", String(b.height));
         canvas.appendChild(rect);
+      });
+      renderResizeHandles(elements);
+    }
+
+    function isResizableElement(el) {
+      return !!el && ["rect", "ellipse", "image", "line", "text", "polygon", "polyline", "path", "g"].includes(el.tagName);
+    }
+
+    function renderResizeHandles(elements) {
+      if (elements.length !== 1) return;
+      const target = elements[0];
+      if (!isResizableElement(target)) return;
+      const b = safeBBox(target);
+      if (!b) return;
+      const size = 8;
+      const corners = [
+        { name: "nw", x: b.x, y: b.y },
+        { name: "ne", x: b.x + b.width, y: b.y },
+        { name: "sw", x: b.x, y: b.y + b.height },
+        { name: "se", x: b.x + b.width, y: b.y + b.height }
+      ];
+      corners.forEach((c) => {
+        const h = document.createElementNS(SVG_NS, "rect");
+        h.setAttribute("class", "selection-handle");
+        h.setAttribute("x", String(c.x - size / 2));
+        h.setAttribute("y", String(c.y - size / 2));
+        h.setAttribute("width", String(size));
+        h.setAttribute("height", String(size));
+        h.dataset.handle = c.name;
+        h.dataset.targetId = target.dataset.id;
+        canvas.appendChild(h);
       });
     }
 
@@ -354,6 +434,7 @@
       Object.entries(attrs || {}).forEach(([k, v]) => el.setAttribute(k, String(v)));
       if (text) el.textContent = text;
       ensureId(el);
+      applyPointerEventPolicy(el);
       setTranslate(el, 0, 0);
       canvas.appendChild(el);
       return el;
@@ -385,7 +466,7 @@
 
     function getCleanCanvasMarkup() {
       const clone = canvas.cloneNode(true);
-      clone.querySelectorAll(".selection-outline,.marquee").forEach((el) => el.remove());
+      clone.querySelectorAll(".selection-outline,.selection-handle,.marquee").forEach((el) => el.remove());
       clone.querySelectorAll(".fm-selected,.fm-group-selected").forEach((el) => {
         el.classList.remove("fm-selected");
         el.classList.remove("fm-group-selected");
@@ -393,6 +474,16 @@
       return clone.innerHTML;
     }
 
+    function getCanvasDimensions() {
+      const vb = (canvas.getAttribute("viewBox") || "0 0 1200 700").split(/\s+/).map(Number);
+      return { width: vb[2] || 1200, height: vb[3] || 700 };
+    }
+
+    function getCleanSvgDocument() {
+      const { width, height } = getCanvasDimensions();
+      return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${height}" width="${width}" height="${height}">${getCleanCanvasMarkup()}</svg>`;
+    }
+
     function getSnapshot() {
       return { markup: getCleanCanvasMarkup(), selectedIds: [...state.selectedIds], at: Date.now() };
     }
@@ -454,28 +545,41 @@
       }
       const bounds = elements.map(safeBBox).filter(Boolean);
       if (!bounds.length) return;
-      const minX = Math.min(...bounds.map((b) => b.x));
-      const maxX = Math.max(...bounds.map((b) => b.x + b.width));
-      const minY = Math.min(...bounds.map((b) => b.y));
-      const maxY = Math.max(...bounds.map((b) => b.y + b.height));
-      const centerX = (minX + maxX) / 2;
-      const centerY = (minY + maxY) / 2;
+      let baseMinX = Math.min(...bounds.map((b) => b.x));
+      let baseMaxX = Math.max(...bounds.map((b) => b.x + b.width));
+      let baseMinY = Math.min(...bounds.map((b) => b.y));
+      let baseMaxY = Math.max(...bounds.map((b) => b.y + b.height));
+      let anchorEl = null;
+      if (state.alignBasis === "first") {
+        const firstId = state.selectedIds.find((id) => elements.some((el) => el.dataset.id === id));
+        anchorEl = firstId ? getById(firstId) : elements[0];
+        const anchorBox = anchorEl ? safeBBox(anchorEl) : null;
+        if (anchorBox) {
+          baseMinX = anchorBox.x;
+          baseMaxX = anchorBox.x + anchorBox.width;
+          baseMinY = anchorBox.y;
+          baseMaxY = anchorBox.y + anchorBox.height;
+        }
+      }
+      const centerX = (baseMinX + baseMaxX) / 2;
+      const centerY = (baseMinY + baseMaxY) / 2;
 
       elements.forEach((el) => {
+        if (state.alignBasis === "first" && anchorEl && el === anchorEl) return;
         const bRaw = el.getBBox();
         const t = getTranslate(el);
         let newX = t.x;
         let newY = t.y;
-        if (mode === "left") newX = minX - bRaw.x;
+        if (mode === "left") newX = baseMinX - bRaw.x;
         if (mode === "hcenter") newX = centerX - (bRaw.x + bRaw.width / 2);
-        if (mode === "right") newX = maxX - (bRaw.x + bRaw.width);
-        if (mode === "top") newY = minY - bRaw.y;
+        if (mode === "right") newX = baseMaxX - (bRaw.x + bRaw.width);
+        if (mode === "top") newY = baseMinY - bRaw.y;
         if (mode === "vcenter") newY = centerY - (bRaw.y + bRaw.height / 2);
-        if (mode === "bottom") newY = maxY - (bRaw.y + bRaw.height);
+        if (mode === "bottom") newY = baseMaxY - (bRaw.y + bRaw.height);
         setTranslate(el, newX, newY);
       });
       applySelectionStyles();
-      pushHistory(`align-${mode}`);
+      pushHistory(`align-${mode}-${state.alignBasis}`);
     }
 
     function distributeSelected(axis) {
@@ -561,6 +665,30 @@
       pushHistory("ungroup");
     }
 
+    function duplicateSelected() {
+      const elements = getTopSelectedElements();
+      if (!elements.length) {
+        setStatus("Duplicate needs selected object.");
+        return;
+      }
+      const clones = [];
+      elements.forEach((el) => {
+        const clone = el.cloneNode(true);
+        clone.querySelectorAll?.("[data-id]").forEach((n) => n.removeAttribute("data-id"));
+        clone.removeAttribute("data-id");
+        sanitizeSvgTree(clone);
+        ensureId(clone);
+        const t = getTranslate(el);
+        setTranslate(clone, t.x + 20, t.y + 20);
+        el.parentNode.appendChild(clone);
+        assignIds(clone);
+        if (clone.dataset.id) clones.push(clone.dataset.id);
+      });
+      setSelection(clones);
+      pushHistory("duplicate");
+      setStatus(`Duplicated ${clones.length} object(s).`);
+    }
+
     function addOrReplaceGroupLabel(groupEl, letter) {
       if (!groupEl || groupEl.tagName !== "g") return;
       const existing = groupEl.querySelector(":scope > .group-label");
@@ -589,7 +717,7 @@
     }
 
     function saveSvg() {
-      const markup = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${canvas.getAttribute("viewBox")}" width="1200" height="700">${getCleanCanvasMarkup()}</svg>`;
+      const markup = getCleanSvgDocument();
       const blob = new Blob([markup], { type: "image/svg+xml;charset=utf-8" });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
@@ -606,12 +734,24 @@
           setStatus("jsPDF unavailable.");
           return;
         }
-        const vb = (canvas.getAttribute("viewBox") || "0 0 1200 700").split(/\s+/).map(Number);
-        const w = vb[2] || 1200;
-        const h = vb[3] || 700;
+        const { width: w, height: h } = getCanvasDimensions();
         const { jsPDF } = window.jspdf;
         const pdf = new jsPDF({ unit: "pt", format: [w, h], orientation: w >= h ? "landscape" : "portrait" });
-        await pdf.svg(canvas, { x: 0, y: 0, width: w, height: h });
+        try {
+          const cleanSvg = new DOMParser().parseFromString(getCleanSvgDocument(), "image/svg+xml").documentElement;
+          await pdf.svg(cleanSvg, { x: 0, y: 0, width: w, height: h });
+        } catch (_) {
+          if (!window.canvg || !window.canvg.Canvg) throw new Error("svg2pdf failed and canvg unavailable");
+          const tempCanvas = document.createElement("canvas");
+          tempCanvas.width = Math.max(1, Math.round(w));
+          tempCanvas.height = Math.max(1, Math.round(h));
+          const ctx = tempCanvas.getContext("2d");
+          if (!ctx) throw new Error("Canvas context unavailable");
+          const v = await window.canvg.Canvg.fromString(ctx, getCleanSvgDocument());
+          await v.render();
+          const pngData = tempCanvas.toDataURL("image/png");
+          pdf.addImage(pngData, "PNG", 0, 0, w, h);
+        }
         pdf.save("figure.pdf");
         setStatus("PDF exported.");
       } catch (err) {
@@ -621,11 +761,16 @@
 
     function loadSvgText(text) {
       const doc = new DOMParser().parseFromString(text, "image/svg+xml");
+      if (doc.querySelector("parsererror")) {
+        setStatus("Invalid SVG file.");
+        return;
+      }
       const root = doc.querySelector("svg");
       if (!root) {
         setStatus("Invalid SVG file.");
         return;
       }
+      sanitizeSvgTree(root);
       canvas.innerHTML = root.innerHTML;
       assignIds();
       clearSelection();
@@ -748,35 +893,39 @@
     }
 
     function extractSvgFromHtml(html) {
-      if (!html) return "";
-      const match = html.match(/<svg[\s\S]*<\/svg>/i);
-      return match ? match[0] : "";
+      if (!html) return [];
+      const doc = new DOMParser().parseFromString(html, "text/html");
+      return Array.from(doc.querySelectorAll("svg")).map((svg) => svg.outerHTML).filter(Boolean);
     }
 
     function extractImageSrcFromHtml(html) {
-      if (!html) return "";
+      if (!html) return [];
       const doc = new DOMParser().parseFromString(html, "text/html");
-      const img = doc.querySelector("img[src]");
-      return img?.getAttribute("src") || "";
+      return Array.from(doc.querySelectorAll("img[src]")).map((img) => img.getAttribute("src")).filter(Boolean);
     }
 
-    function importSvgText(svgText) {
+    function importSvgText(svgText, options = {}) {
+      const push = options.push !== false;
+      const setMessage = options.setMessage !== false;
       const doc = new DOMParser().parseFromString(svgText, "image/svg+xml");
+      if (doc.querySelector("parsererror")) return false;
       const root = doc.querySelector("svg");
       if (!root) return false;
+      sanitizeSvgTree(root);
       const importedIds = [];
       Array.from(root.children).forEach((child) => {
         const imported = document.importNode(child, true);
         if (!(imported instanceof SVGElement)) return;
         ensureId(imported);
+        sanitizeSvgTree(imported);
         if (!imported.hasAttribute("transform")) setTranslate(imported, 0, 0);
         canvas.appendChild(imported);
         if (imported.dataset.id) importedIds.push(imported.dataset.id);
       });
       assignIds();
       setSelection(importedIds);
-      pushHistory("paste-svg");
-      setStatus("Pasted SVG content.");
+      if (push) pushHistory("paste-svg");
+      if (setMessage) setStatus("Pasted SVG content.");
       return importedIds.length > 0;
     }
 
@@ -798,19 +947,31 @@
       }
 
       const htmlText = ev.clipboardData?.getData("text/html") || "";
-      const htmlSvg = extractSvgFromHtml(htmlText);
-      if (htmlSvg) {
+      const htmlSvgs = extractSvgFromHtml(htmlText);
+      if (htmlSvgs.length) {
         ev.preventDefault();
-        if (importSvgText(htmlSvg)) return;
+        let count = 0;
+        htmlSvgs.forEach((svgText) => {
+          if (importSvgText(svgText, { push: false, setMessage: false })) count += 1;
+        });
+        if (count > 0) {
+          pushHistory("paste-html-svg");
+          setStatus(`Pasted ${count} SVG block(s) from HTML.`);
+          return;
+        }
       }
 
-      const htmlImgSrc = extractImageSrcFromHtml(htmlText);
-      if (htmlImgSrc) {
+      const htmlImgSrcs = extractImageSrcFromHtml(htmlText);
+      if (htmlImgSrcs.length) {
         ev.preventDefault();
-        const size = await getImageSize(htmlImgSrc);
-        insertImageElement(htmlImgSrc, size.width, size.height);
+        let inserted = 0;
+        for (const src of htmlImgSrcs.slice(0, 20)) {
+          const size = await getImageSize(src);
+          insertImageElement(src, size.width, size.height);
+          inserted += 1;
+        }
         pushHistory("paste-html-image");
-        setStatus("Pasted HTML image.");
+        setStatus(`Pasted ${inserted} HTML image(s).`);
         return;
       }
 
@@ -880,8 +1041,242 @@
       const original = new Map();
       elements.forEach((el) => original.set(el.dataset.id, getTranslate(el)));
       state.interaction = { type: "drag", start, original, moved: false };
+    }
+
+    function beginResize(start, targetEl, handle) {
+      if (!targetEl || !isResizableElement(targetEl)) return;
+      const b = safeBBox(targetEl);
+      if (!b) return;
+      state.interaction = {
+        type: "resize",
+        start,
+        targetId: targetEl.dataset.id,
+        handle,
+        originalBox: b,
+        moved: false
+      };
     }
 
+    function mapX(x, oldBox, newBox) {
+      const denom = Math.max(oldBox.width, 1e-6);
+      return newBox.x + ((x - oldBox.x) / denom) * newBox.width;
+    }
+
+    function mapY(y, oldBox, newBox) {
+      const denom = Math.max(oldBox.height, 1e-6);
+      return newBox.y + ((y - oldBox.y) / denom) * newBox.height;
+    }
+
+    function scalePathD(d, oldBox, newBox, offset) {
+      const tokens = [];
+      const re = /([a-zA-Z])|([-+]?\d*\.?\d+(?:e[-+]?\d+)?)/g;
+      let m;
+      while ((m = re.exec(d)) !== null) {
+        if (m[1]) tokens.push({ type: "cmd", value: m[1] });
+        else tokens.push({ type: "num", value: Number(m[2]) });
+      }
+      const out = [];
+      let i = 0;
+      let cmd = "";
+      const sx = newBox.width / Math.max(oldBox.width, 1e-6);
+      const sy = newBox.height / Math.max(oldBox.height, 1e-6);
+      const mapAbsX = (x) => mapX(x + offset.x, oldBox, newBox) - offset.x;
+      const mapAbsY = (y) => mapY(y + offset.y, oldBox, newBox) - offset.y;
+      const mapRelX = (x) => x * sx;
+      const mapRelY = (y) => y * sy;
+      const readNum = () => {
+        if (i >= tokens.length || tokens[i].type !== "num") return null;
+        return tokens[i++].value;
+      };
+      const emit = (vals) => vals.forEach((v) => out.push(Number.isInteger(v) ? String(v) : String(Number(v.toFixed(4)))));
+      while (i < tokens.length) {
+        if (tokens[i].type === "cmd") {
+          cmd = tokens[i].value;
+          out.push(cmd);
+          i += 1;
+        }
+        if (!cmd) break;
+        const c = cmd.toLowerCase();
+        const rel = cmd === c;
+        const need = c === "m" || c === "l" || c === "t" ? 2
+          : c === "h" || c === "v" ? 1
+          : c === "c" ? 6
+          : c === "s" || c === "q" ? 4
+          : c === "a" ? 7
+          : c === "z" ? 0 : -1;
+        if (need === 0) {
+          while (i < tokens.length && tokens[i].type !== "cmd") i += 1;
+          continue;
+        }
+        if (need < 0) break;
+        if (i < tokens.length && tokens[i].type === "cmd") continue;
+        const vals = [];
+        for (let k = 0; k < need; k += 1) {
+          const v = readNum();
+          if (v === null) break;
+          vals.push(v);
+        }
+        if (vals.length < need) break;
+
+        if (c === "h") emit([rel ? mapRelX(vals[0]) : mapAbsX(vals[0])]);
+        else if (c === "v") emit([rel ? mapRelY(vals[0]) : mapAbsY(vals[0])]);
+        else if (c === "m" || c === "l" || c === "t") {
+          emit([rel ? mapRelX(vals[0]) : mapAbsX(vals[0]), rel ? mapRelY(vals[1]) : mapAbsY(vals[1])]);
+        } else if (c === "s" || c === "q") {
+          emit([
+            rel ? mapRelX(vals[0]) : mapAbsX(vals[0]),
+            rel ? mapRelY(vals[1]) : mapAbsY(vals[1]),
+            rel ? mapRelX(vals[2]) : mapAbsX(vals[2]),
+            rel ? mapRelY(vals[3]) : mapAbsY(vals[3])
+          ]);
+        } else if (c === "c") {
+          emit([
+            rel ? mapRelX(vals[0]) : mapAbsX(vals[0]),
+            rel ? mapRelY(vals[1]) : mapAbsY(vals[1]),
+            rel ? mapRelX(vals[2]) : mapAbsX(vals[2]),
+            rel ? mapRelY(vals[3]) : mapAbsY(vals[3]),
+            rel ? mapRelX(vals[4]) : mapAbsX(vals[4]),
+            rel ? mapRelY(vals[5]) : mapAbsY(vals[5])
+          ]);
+        } else if (c === "a") {
+          const rx = Math.max(0.5, Math.abs(vals[0] * sx));
+          const ry = Math.max(0.5, Math.abs(vals[1] * sy));
+          emit([
+            rx,
+            ry,
+            vals[2],
+            vals[3],
+            vals[4],
+            rel ? mapRelX(vals[5]) : mapAbsX(vals[5]),
+            rel ? mapRelY(vals[6]) : mapAbsY(vals[6])
+          ]);
+        }
+      }
+      return out.join(" ");
+    }
+
+    function scaleSingleElement(el, oldBox, newBox, parentOffset = { x: 0, y: 0 }) {
+      const t = getTranslate(el);
+      if (el.tagName === "rect" || el.tagName === "image") {
+        const x = Number(el.getAttribute("x") || 0) + t.x + parentOffset.x;
+        const y = Number(el.getAttribute("y") || 0) + t.y + parentOffset.y;
+        const x2 = x + Number(el.getAttribute("width") || 0);
+        const y2 = y + Number(el.getAttribute("height") || 0);
+        const nx = mapX(x, oldBox, newBox);
+        const ny = mapY(y, oldBox, newBox);
+        const nx2 = mapX(x2, oldBox, newBox);
+        const ny2 = mapY(y2, oldBox, newBox);
+        el.setAttribute("x", String(nx - t.x - parentOffset.x));
+        el.setAttribute("y", String(ny - t.y - parentOffset.y));
+        el.setAttribute("width", String(Math.max(1, nx2 - nx)));
+        el.setAttribute("height", String(Math.max(1, ny2 - ny)));
+        return;
+      }
+      if (el.tagName === "ellipse") {
+        const cx = Number(el.getAttribute("cx") || 0) + t.x + parentOffset.x;
+        const cy = Number(el.getAttribute("cy") || 0) + t.y + parentOffset.y;
+        const rx = Number(el.getAttribute("rx") || 0);
+        const ry = Number(el.getAttribute("ry") || 0);
+        const x1 = cx - rx;
+        const x2 = cx + rx;
+        const y1 = cy - ry;
+        const y2 = cy + ry;
+        const nx1 = mapX(x1, oldBox, newBox);
+        const nx2 = mapX(x2, oldBox, newBox);
+        const ny1 = mapY(y1, oldBox, newBox);
+        const ny2 = mapY(y2, oldBox, newBox);
+        const ncx = (nx1 + nx2) / 2;
+        const ncy = (ny1 + ny2) / 2;
+        el.setAttribute("cx", String(ncx - t.x - parentOffset.x));
+        el.setAttribute("cy", String(ncy - t.y - parentOffset.y));
+        el.setAttribute("rx", String(Math.max(0.5, (nx2 - nx1) / 2)));
+        el.setAttribute("ry", String(Math.max(0.5, (ny2 - ny1) / 2)));
+        return;
+      }
+      if (el.tagName === "line") {
+        const x1 = Number(el.getAttribute("x1") || 0) + t.x + parentOffset.x;
+        const y1 = Number(el.getAttribute("y1") || 0) + t.y + parentOffset.y;
+        const x2 = Number(el.getAttribute("x2") || 0) + t.x + parentOffset.x;
+        const y2 = Number(el.getAttribute("y2") || 0) + t.y + parentOffset.y;
+        el.setAttribute("x1", String(mapX(x1, oldBox, newBox) - t.x - parentOffset.x));
+        el.setAttribute("y1", String(mapY(y1, oldBox, newBox) - t.y - parentOffset.y));
+        el.setAttribute("x2", String(mapX(x2, oldBox, newBox) - t.x - parentOffset.x));
+        el.setAttribute("y2", String(mapY(y2, oldBox, newBox) - t.y - parentOffset.y));
+        return;
+      }
+      if (el.tagName === "polygon" || el.tagName === "polyline") {
+        const pts = String(el.getAttribute("points") || "").trim();
+        if (!pts) return;
+        const mapped = pts.split(/\s+/).map((pair) => {
+          const [pxRaw, pyRaw] = pair.split(",");
+          const px = Number(pxRaw);
+          const py = Number(pyRaw);
+          if (Number.isNaN(px) || Number.isNaN(py)) return pair;
+          const wx = px + t.x + parentOffset.x;
+          const wy = py + t.y + parentOffset.y;
+          const nx = mapX(wx, oldBox, newBox) - t.x - parentOffset.x;
+          const ny = mapY(wy, oldBox, newBox) - t.y - parentOffset.y;
+          return `${nx},${ny}`;
+        });
+        el.setAttribute("points", mapped.join(" "));
+        return;
+      }
+      if (el.tagName === "path") {
+        const d = String(el.getAttribute("d") || "");
+        if (!d) return;
+        const mappedD = scalePathD(d, oldBox, newBox, { x: t.x + parentOffset.x, y: t.y + parentOffset.y });
+        if (mappedD) el.setAttribute("d", mappedD);
+        return;
+      }
+      if (el.tagName === "text") {
+        const x = Number(el.getAttribute("x") || 0) + t.x + parentOffset.x;
+        const y = Number(el.getAttribute("y") || 0) + t.y + parentOffset.y;
+        const sx = Math.max(newBox.width / Math.max(oldBox.width, 1e-6), 0.05);
+        const sy = Math.max(newBox.height / Math.max(oldBox.height, 1e-6), 0.05);
+        const fs = Number(el.getAttribute("font-size") || 16);
+        const scale = (sx + sy) / 2;
+        el.setAttribute("x", String(mapX(x, oldBox, newBox) - t.x - parentOffset.x));
+        el.setAttribute("y", String(mapY(y, oldBox, newBox) - t.y - parentOffset.y));
+        el.setAttribute("font-size", String(Math.max(6, fs * scale)));
+        return;
+      }
+      if (el.tagName === "g") {
+        const nextOffset = { x: parentOffset.x + t.x, y: parentOffset.y + t.y };
+        Array.from(el.children).forEach((child) => {
+          if (!(child instanceof SVGElement)) return;
+          scaleSingleElement(child, oldBox, newBox, nextOffset);
+        });
+      }
+    }
+
+    function updateResize(pt) {
+      const it = state.interaction;
+      if (!it || it.type !== "resize") return;
+      const el = getById(it.targetId);
+      if (!el) return;
+      const ob = it.originalBox;
+      let left = ob.x;
+      let right = ob.x + ob.width;
+      let top = ob.y;
+      let bottom = ob.y + ob.height;
+      if (it.handle.includes("w")) left = Math.min(pt.x, right - 1);
+      if (it.handle.includes("e")) right = Math.max(pt.x, left + 1);
+      if (it.handle.includes("n")) top = Math.min(pt.y, bottom - 1);
+      if (it.handle.includes("s")) bottom = Math.max(pt.y, top + 1);
+      const width = Math.max(1, right - left);
+      const height = Math.max(1, bottom - top);
+      scaleSingleElement(el, ob, { x: left, y: top, width, height }, { x: 0, y: 0 });
+      it.moved = true;
+      applySelectionStyles();
+    }
+
+    function finishResize() {
+      const it = state.interaction;
+      if (!it || it.type !== "resize") return;
+      if (it.moved) pushHistory("resize");
+      state.interaction = null;
+    }
+
     function updateDrag(pt) {
       const it = state.interaction;
       if (!it || it.type !== "drag") return;
@@ -924,6 +1319,7 @@
       document.getElementById("redoBtn").addEventListener("click", redo);
       document.getElementById("groupBtn").addEventListener("click", groupSelected);
       document.getElementById("ungroupBtn").addEventListener("click", ungroupSelected);
+      document.getElementById("duplicateBtn").addEventListener("click", duplicateSelected);
       document.getElementById("saveSvg").addEventListener("click", saveSvg);
       document.getElementById("exportPdf").addEventListener("click", exportPdf);
 
@@ -933,6 +1329,12 @@
       document.querySelectorAll("[data-distribute]").forEach((btn) => {
         btn.addEventListener("click", () => distributeSelected(btn.dataset.distribute));
       });
+      document.getElementById("alignBasisSelect").addEventListener("change", (e) => {
+        const value = e.target.value === "first" ? "first" : "bbox";
+        state.alignBasis = value;
+        localStorage.setItem(ALIGN_BASIS_KEY, value);
+        setStatus(`Align base: ${value === "first" ? "first selected" : "selection box"}`);
+      });
 
       const fileInput = document.getElementById("openFileInput");
       document.getElementById("openSvg").addEventListener("click", () => fileInput.click());
@@ -975,6 +1377,15 @@
       canvas.addEventListener("pointerdown", (e) => {
         if (e.button !== 0) return;
         closeContextMenu();
+        const handleEl = e.target instanceof SVGElement ? e.target.closest(".selection-handle") : null;
+        if (handleEl instanceof SVGElement) {
+          const pt = getSvgPoint(e.clientX, e.clientY);
+          const targetId = handleEl.dataset.targetId;
+          const handle = handleEl.dataset.handle || "se";
+          const target = targetId ? getById(targetId) : null;
+          beginResize(pt, target, handle);
+          return;
+        }
         const raw = closestEditableTarget(e.target);
         const pt = getSvgPoint(e.clientX, e.clientY);
         if (raw) {
@@ -997,12 +1408,14 @@
         if (!state.interaction) return;
         const pt = getSvgPoint(e.clientX, e.clientY);
         if (state.interaction.type === "drag") updateDrag(pt);
+        if (state.interaction.type === "resize") updateResize(pt);
         if (state.interaction.type === "marquee") updateMarquee(pt);
       });
 
       window.addEventListener("pointerup", () => {
         if (!state.interaction) return;
         if (state.interaction.type === "drag") finishDrag();
+        if (state.interaction.type === "resize") finishResize();
         if (state.interaction.type === "marquee") finishMarquee();
       });
 
@@ -1032,6 +1445,10 @@
           e.preventDefault();
           redo();
         }
+        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "d") {
+          e.preventDefault();
+          duplicateSelected();
+        }
       });
 
       window.addEventListener("paste", handlePaste);
@@ -1045,6 +1462,9 @@
       setupEvents();
       const interval = localStorage.getItem(AUTOSAVE_INTERVAL_KEY) || "off";
       document.getElementById("autosaveSelect").value = ["off", "10", "30"].includes(interval) ? interval : "off";
+      const alignBasis = localStorage.getItem(ALIGN_BASIS_KEY);
+      state.alignBasis = alignBasis === "first" ? "first" : "bbox";
+      document.getElementById("alignBasisSelect").value = state.alignBasis;
       refreshRestoreList();
       updateAutosaveTimer();
       pushHistory("init");
