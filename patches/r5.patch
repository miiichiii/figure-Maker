--- /tmp/index_before_r3.html	2026-02-19 03:01:25
+++ index.html	2026-02-19 03:08:25
@@ -6,6 +6,7 @@
   <title>Figure Maker</title>
   <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/svg2pdf.js@2.5.0/dist/svg2pdf.umd.min.js"></script>
+  <script src="https://cdn.jsdelivr.net/npm/canvg@4.0.2/lib/umd.min.js"></script>
   <style>
     :root {
       --bg: #f3f4f6;
@@ -79,6 +80,12 @@
       stroke-dasharray: 6 3;
       pointer-events: none;
     }
+    .selection-handle {
+      fill: #ffffff;
+      stroke: var(--accent);
+      stroke-width: 1.5;
+      cursor: nwse-resize;
+    }
     .context-menu {
       position: fixed;
       background: #fff;
@@ -138,6 +145,11 @@
         <button id="ungroupBtn">Ungroup</button>
       </div>
       <div class="group">
+        <label for="alignBasisSelect">Align base</label>
+        <select id="alignBasisSelect">
+          <option value="bbox">Selection Box</option>
+          <option value="first">First Selected</option>
+        </select>
         <button data-align="left">Align L</button>
         <button data-align="hcenter">Align C</button>
         <button data-align="right">Align R</button>
@@ -176,6 +188,7 @@
     const XLINK_NS = "http://www.w3.org/1999/xlink";
     const AUTOSAVE_KEY = "figureMaker_autosave_records";
     const AUTOSAVE_INTERVAL_KEY = "figureMaker_autosave_interval";
+    const ALIGN_BASIS_KEY = "figureMaker_align_basis";
 
     const canvas = document.getElementById("canvas");
     const statusEl = document.getElementById("status");
@@ -191,7 +204,8 @@
       maxHistory: 100,
       interaction: null,
       autosaveTimer: null,
-      contextGroupId: null
+      contextGroupId: null,
+      alignBasis: "bbox"
     };
 
     function setStatus(msg) {
@@ -264,7 +278,7 @@
     }
 
     function renderSelectionOutlines() {
-      canvas.querySelectorAll(".selection-outline").forEach((el) => el.remove());
+      canvas.querySelectorAll(".selection-outline,.selection-handle").forEach((el) => el.remove());
       const elements = getTopSelectedElements();
       elements.forEach((el) => {
         const b = safeBBox(el);
@@ -277,8 +291,39 @@
         rect.setAttribute("height", String(b.height));
         canvas.appendChild(rect);
       });
+      renderResizeHandles(elements);
+    }
+
+    function isResizableElement(el) {
+      return !!el && ["rect", "ellipse", "image", "line", "text", "g"].includes(el.tagName);
     }
 
+    function renderResizeHandles(elements) {
+      if (elements.length !== 1) return;
+      const target = elements[0];
+      if (!isResizableElement(target)) return;
+      const b = safeBBox(target);
+      if (!b) return;
+      const size = 8;
+      const corners = [
+        { name: "nw", x: b.x, y: b.y },
+        { name: "ne", x: b.x + b.width, y: b.y },
+        { name: "sw", x: b.x, y: b.y + b.height },
+        { name: "se", x: b.x + b.width, y: b.y + b.height }
+      ];
+      corners.forEach((c) => {
+        const h = document.createElementNS(SVG_NS, "rect");
+        h.setAttribute("class", "selection-handle");
+        h.setAttribute("x", String(c.x - size / 2));
+        h.setAttribute("y", String(c.y - size / 2));
+        h.setAttribute("width", String(size));
+        h.setAttribute("height", String(size));
+        h.dataset.handle = c.name;
+        h.dataset.targetId = target.dataset.id;
+        canvas.appendChild(h);
+      });
+    }
+
     function setSelection(ids) {
       state.selectedIds = [...new Set(ids)].filter((id) => !!getById(id));
       applySelectionStyles();
@@ -385,7 +430,7 @@
 
     function getCleanCanvasMarkup() {
       const clone = canvas.cloneNode(true);
-      clone.querySelectorAll(".selection-outline,.marquee").forEach((el) => el.remove());
+      clone.querySelectorAll(".selection-outline,.selection-handle,.marquee").forEach((el) => el.remove());
       clone.querySelectorAll(".fm-selected,.fm-group-selected").forEach((el) => {
         el.classList.remove("fm-selected");
         el.classList.remove("fm-group-selected");
@@ -393,6 +438,16 @@
       return clone.innerHTML;
     }
 
+    function getCanvasDimensions() {
+      const vb = (canvas.getAttribute("viewBox") || "0 0 1200 700").split(/\s+/).map(Number);
+      return { width: vb[2] || 1200, height: vb[3] || 700 };
+    }
+
+    function getCleanSvgDocument() {
+      const { width, height } = getCanvasDimensions();
+      return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${height}" width="${width}" height="${height}">${getCleanCanvasMarkup()}</svg>`;
+    }
+
     function getSnapshot() {
       return { markup: getCleanCanvasMarkup(), selectedIds: [...state.selectedIds], at: Date.now() };
     }
@@ -454,28 +509,41 @@
       }
       const bounds = elements.map(safeBBox).filter(Boolean);
       if (!bounds.length) return;
-      const minX = Math.min(...bounds.map((b) => b.x));
-      const maxX = Math.max(...bounds.map((b) => b.x + b.width));
-      const minY = Math.min(...bounds.map((b) => b.y));
-      const maxY = Math.max(...bounds.map((b) => b.y + b.height));
-      const centerX = (minX + maxX) / 2;
-      const centerY = (minY + maxY) / 2;
+      let baseMinX = Math.min(...bounds.map((b) => b.x));
+      let baseMaxX = Math.max(...bounds.map((b) => b.x + b.width));
+      let baseMinY = Math.min(...bounds.map((b) => b.y));
+      let baseMaxY = Math.max(...bounds.map((b) => b.y + b.height));
+      let anchorEl = null;
+      if (state.alignBasis === "first") {
+        const firstId = state.selectedIds.find((id) => elements.some((el) => el.dataset.id === id));
+        anchorEl = firstId ? getById(firstId) : elements[0];
+        const anchorBox = anchorEl ? safeBBox(anchorEl) : null;
+        if (anchorBox) {
+          baseMinX = anchorBox.x;
+          baseMaxX = anchorBox.x + anchorBox.width;
+          baseMinY = anchorBox.y;
+          baseMaxY = anchorBox.y + anchorBox.height;
+        }
+      }
+      const centerX = (baseMinX + baseMaxX) / 2;
+      const centerY = (baseMinY + baseMaxY) / 2;
 
       elements.forEach((el) => {
+        if (state.alignBasis === "first" && anchorEl && el === anchorEl) return;
         const bRaw = el.getBBox();
         const t = getTranslate(el);
         let newX = t.x;
         let newY = t.y;
-        if (mode === "left") newX = minX - bRaw.x;
+        if (mode === "left") newX = baseMinX - bRaw.x;
         if (mode === "hcenter") newX = centerX - (bRaw.x + bRaw.width / 2);
-        if (mode === "right") newX = maxX - (bRaw.x + bRaw.width);
-        if (mode === "top") newY = minY - bRaw.y;
+        if (mode === "right") newX = baseMaxX - (bRaw.x + bRaw.width);
+        if (mode === "top") newY = baseMinY - bRaw.y;
         if (mode === "vcenter") newY = centerY - (bRaw.y + bRaw.height / 2);
-        if (mode === "bottom") newY = maxY - (bRaw.y + bRaw.height);
+        if (mode === "bottom") newY = baseMaxY - (bRaw.y + bRaw.height);
         setTranslate(el, newX, newY);
       });
       applySelectionStyles();
-      pushHistory(`align-${mode}`);
+      pushHistory(`align-${mode}-${state.alignBasis}`);
     }
 
     function distributeSelected(axis) {
@@ -589,7 +657,7 @@
     }
 
     function saveSvg() {
-      const markup = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${canvas.getAttribute("viewBox")}" width="1200" height="700">${getCleanCanvasMarkup()}</svg>`;
+      const markup = getCleanSvgDocument();
       const blob = new Blob([markup], { type: "image/svg+xml;charset=utf-8" });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
@@ -606,12 +674,24 @@
           setStatus("jsPDF unavailable.");
           return;
         }
-        const vb = (canvas.getAttribute("viewBox") || "0 0 1200 700").split(/\s+/).map(Number);
-        const w = vb[2] || 1200;
-        const h = vb[3] || 700;
+        const { width: w, height: h } = getCanvasDimensions();
         const { jsPDF } = window.jspdf;
         const pdf = new jsPDF({ unit: "pt", format: [w, h], orientation: w >= h ? "landscape" : "portrait" });
-        await pdf.svg(canvas, { x: 0, y: 0, width: w, height: h });
+        try {
+          const cleanSvg = new DOMParser().parseFromString(getCleanSvgDocument(), "image/svg+xml").documentElement;
+          await pdf.svg(cleanSvg, { x: 0, y: 0, width: w, height: h });
+        } catch (_) {
+          if (!window.canvg || !window.canvg.Canvg) throw new Error("svg2pdf failed and canvg unavailable");
+          const tempCanvas = document.createElement("canvas");
+          tempCanvas.width = Math.max(1, Math.round(w));
+          tempCanvas.height = Math.max(1, Math.round(h));
+          const ctx = tempCanvas.getContext("2d");
+          if (!ctx) throw new Error("Canvas context unavailable");
+          const v = await window.canvg.Canvg.fromString(ctx, getCleanSvgDocument());
+          await v.render();
+          const pngData = tempCanvas.toDataURL("image/png");
+          pdf.addImage(pngData, "PNG", 0, 0, w, h);
+        }
         pdf.save("figure.pdf");
         setStatus("PDF exported.");
       } catch (err) {
@@ -748,19 +828,20 @@
     }
 
     function extractSvgFromHtml(html) {
-      if (!html) return "";
-      const match = html.match(/<svg[\s\S]*<\/svg>/i);
-      return match ? match[0] : "";
+      if (!html) return [];
+      const doc = new DOMParser().parseFromString(html, "text/html");
+      return Array.from(doc.querySelectorAll("svg")).map((svg) => svg.outerHTML).filter(Boolean);
     }
 
     function extractImageSrcFromHtml(html) {
-      if (!html) return "";
+      if (!html) return [];
       const doc = new DOMParser().parseFromString(html, "text/html");
-      const img = doc.querySelector("img[src]");
-      return img?.getAttribute("src") || "";
+      return Array.from(doc.querySelectorAll("img[src]")).map((img) => img.getAttribute("src")).filter(Boolean);
     }
 
-    function importSvgText(svgText) {
+    function importSvgText(svgText, options = {}) {
+      const push = options.push !== false;
+      const setMessage = options.setMessage !== false;
       const doc = new DOMParser().parseFromString(svgText, "image/svg+xml");
       const root = doc.querySelector("svg");
       if (!root) return false;
@@ -775,8 +856,8 @@
       });
       assignIds();
       setSelection(importedIds);
-      pushHistory("paste-svg");
-      setStatus("Pasted SVG content.");
+      if (push) pushHistory("paste-svg");
+      if (setMessage) setStatus("Pasted SVG content.");
       return importedIds.length > 0;
     }
 
@@ -798,19 +879,31 @@
       }
 
       const htmlText = ev.clipboardData?.getData("text/html") || "";
-      const htmlSvg = extractSvgFromHtml(htmlText);
-      if (htmlSvg) {
+      const htmlSvgs = extractSvgFromHtml(htmlText);
+      if (htmlSvgs.length) {
         ev.preventDefault();
-        if (importSvgText(htmlSvg)) return;
+        let count = 0;
+        htmlSvgs.forEach((svgText) => {
+          if (importSvgText(svgText, { push: false, setMessage: false })) count += 1;
+        });
+        if (count > 0) {
+          pushHistory("paste-html-svg");
+          setStatus(`Pasted ${count} SVG block(s) from HTML.`);
+          return;
+        }
       }
 
-      const htmlImgSrc = extractImageSrcFromHtml(htmlText);
-      if (htmlImgSrc) {
+      const htmlImgSrcs = extractImageSrcFromHtml(htmlText);
+      if (htmlImgSrcs.length) {
         ev.preventDefault();
-        const size = await getImageSize(htmlImgSrc);
-        insertImageElement(htmlImgSrc, size.width, size.height);
+        let inserted = 0;
+        for (const src of htmlImgSrcs.slice(0, 20)) {
+          const size = await getImageSize(src);
+          insertImageElement(src, size.width, size.height);
+          inserted += 1;
+        }
         pushHistory("paste-html-image");
-        setStatus("Pasted HTML image.");
+        setStatus(`Pasted ${inserted} HTML image(s).`);
         return;
       }
 
@@ -880,8 +973,130 @@
       const original = new Map();
       elements.forEach((el) => original.set(el.dataset.id, getTranslate(el)));
       state.interaction = { type: "drag", start, original, moved: false };
+    }
+
+    function beginResize(start, targetEl, handle) {
+      if (!targetEl || !isResizableElement(targetEl)) return;
+      const b = safeBBox(targetEl);
+      if (!b) return;
+      state.interaction = {
+        type: "resize",
+        start,
+        targetId: targetEl.dataset.id,
+        handle,
+        originalBox: b,
+        moved: false
+      };
+    }
+
+    function mapX(x, oldBox, newBox) {
+      const denom = Math.max(oldBox.width, 1e-6);
+      return newBox.x + ((x - oldBox.x) / denom) * newBox.width;
+    }
+
+    function mapY(y, oldBox, newBox) {
+      const denom = Math.max(oldBox.height, 1e-6);
+      return newBox.y + ((y - oldBox.y) / denom) * newBox.height;
+    }
+
+    function scaleSingleElement(el, oldBox, newBox, parentOffset = { x: 0, y: 0 }) {
+      const t = getTranslate(el);
+      if (el.tagName === "rect" || el.tagName === "image") {
+        const x = Number(el.getAttribute("x") || 0) + t.x + parentOffset.x;
+        const y = Number(el.getAttribute("y") || 0) + t.y + parentOffset.y;
+        const x2 = x + Number(el.getAttribute("width") || 0);
+        const y2 = y + Number(el.getAttribute("height") || 0);
+        const nx = mapX(x, oldBox, newBox);
+        const ny = mapY(y, oldBox, newBox);
+        const nx2 = mapX(x2, oldBox, newBox);
+        const ny2 = mapY(y2, oldBox, newBox);
+        el.setAttribute("x", String(nx - t.x - parentOffset.x));
+        el.setAttribute("y", String(ny - t.y - parentOffset.y));
+        el.setAttribute("width", String(Math.max(1, nx2 - nx)));
+        el.setAttribute("height", String(Math.max(1, ny2 - ny)));
+        return;
+      }
+      if (el.tagName === "ellipse") {
+        const cx = Number(el.getAttribute("cx") || 0) + t.x + parentOffset.x;
+        const cy = Number(el.getAttribute("cy") || 0) + t.y + parentOffset.y;
+        const rx = Number(el.getAttribute("rx") || 0);
+        const ry = Number(el.getAttribute("ry") || 0);
+        const x1 = cx - rx;
+        const x2 = cx + rx;
+        const y1 = cy - ry;
+        const y2 = cy + ry;
+        const nx1 = mapX(x1, oldBox, newBox);
+        const nx2 = mapX(x2, oldBox, newBox);
+        const ny1 = mapY(y1, oldBox, newBox);
+        const ny2 = mapY(y2, oldBox, newBox);
+        const ncx = (nx1 + nx2) / 2;
+        const ncy = (ny1 + ny2) / 2;
+        el.setAttribute("cx", String(ncx - t.x - parentOffset.x));
+        el.setAttribute("cy", String(ncy - t.y - parentOffset.y));
+        el.setAttribute("rx", String(Math.max(0.5, (nx2 - nx1) / 2)));
+        el.setAttribute("ry", String(Math.max(0.5, (ny2 - ny1) / 2)));
+        return;
+      }
+      if (el.tagName === "line") {
+        const x1 = Number(el.getAttribute("x1") || 0) + t.x + parentOffset.x;
+        const y1 = Number(el.getAttribute("y1") || 0) + t.y + parentOffset.y;
+        const x2 = Number(el.getAttribute("x2") || 0) + t.x + parentOffset.x;
+        const y2 = Number(el.getAttribute("y2") || 0) + t.y + parentOffset.y;
+        el.setAttribute("x1", String(mapX(x1, oldBox, newBox) - t.x - parentOffset.x));
+        el.setAttribute("y1", String(mapY(y1, oldBox, newBox) - t.y - parentOffset.y));
+        el.setAttribute("x2", String(mapX(x2, oldBox, newBox) - t.x - parentOffset.x));
+        el.setAttribute("y2", String(mapY(y2, oldBox, newBox) - t.y - parentOffset.y));
+        return;
+      }
+      if (el.tagName === "text") {
+        const x = Number(el.getAttribute("x") || 0) + t.x + parentOffset.x;
+        const y = Number(el.getAttribute("y") || 0) + t.y + parentOffset.y;
+        const sx = Math.max(newBox.width / Math.max(oldBox.width, 1e-6), 0.05);
+        const sy = Math.max(newBox.height / Math.max(oldBox.height, 1e-6), 0.05);
+        const fs = Number(el.getAttribute("font-size") || 16);
+        const scale = (sx + sy) / 2;
+        el.setAttribute("x", String(mapX(x, oldBox, newBox) - t.x - parentOffset.x));
+        el.setAttribute("y", String(mapY(y, oldBox, newBox) - t.y - parentOffset.y));
+        el.setAttribute("font-size", String(Math.max(6, fs * scale)));
+        return;
+      }
+      if (el.tagName === "g") {
+        const nextOffset = { x: parentOffset.x + t.x, y: parentOffset.y + t.y };
+        Array.from(el.children).forEach((child) => {
+          if (!(child instanceof SVGElement)) return;
+          scaleSingleElement(child, oldBox, newBox, nextOffset);
+        });
+      }
     }
 
+    function updateResize(pt) {
+      const it = state.interaction;
+      if (!it || it.type !== "resize") return;
+      const el = getById(it.targetId);
+      if (!el) return;
+      const ob = it.originalBox;
+      let left = ob.x;
+      let right = ob.x + ob.width;
+      let top = ob.y;
+      let bottom = ob.y + ob.height;
+      if (it.handle.includes("w")) left = Math.min(pt.x, right - 1);
+      if (it.handle.includes("e")) right = Math.max(pt.x, left + 1);
+      if (it.handle.includes("n")) top = Math.min(pt.y, bottom - 1);
+      if (it.handle.includes("s")) bottom = Math.max(pt.y, top + 1);
+      const width = Math.max(1, right - left);
+      const height = Math.max(1, bottom - top);
+      scaleSingleElement(el, ob, { x: left, y: top, width, height }, { x: 0, y: 0 });
+      it.moved = true;
+      applySelectionStyles();
+    }
+
+    function finishResize() {
+      const it = state.interaction;
+      if (!it || it.type !== "resize") return;
+      if (it.moved) pushHistory("resize");
+      state.interaction = null;
+    }
+
     function updateDrag(pt) {
       const it = state.interaction;
       if (!it || it.type !== "drag") return;
@@ -933,6 +1148,12 @@
       document.querySelectorAll("[data-distribute]").forEach((btn) => {
         btn.addEventListener("click", () => distributeSelected(btn.dataset.distribute));
       });
+      document.getElementById("alignBasisSelect").addEventListener("change", (e) => {
+        const value = e.target.value === "first" ? "first" : "bbox";
+        state.alignBasis = value;
+        localStorage.setItem(ALIGN_BASIS_KEY, value);
+        setStatus(`Align base: ${value === "first" ? "first selected" : "selection box"}`);
+      });
 
       const fileInput = document.getElementById("openFileInput");
       document.getElementById("openSvg").addEventListener("click", () => fileInput.click());
@@ -975,6 +1196,15 @@
       canvas.addEventListener("pointerdown", (e) => {
         if (e.button !== 0) return;
         closeContextMenu();
+        const handleEl = e.target instanceof SVGElement ? e.target.closest(".selection-handle") : null;
+        if (handleEl instanceof SVGElement) {
+          const pt = getSvgPoint(e.clientX, e.clientY);
+          const targetId = handleEl.dataset.targetId;
+          const handle = handleEl.dataset.handle || "se";
+          const target = targetId ? getById(targetId) : null;
+          beginResize(pt, target, handle);
+          return;
+        }
         const raw = closestEditableTarget(e.target);
         const pt = getSvgPoint(e.clientX, e.clientY);
         if (raw) {
@@ -997,12 +1227,14 @@
         if (!state.interaction) return;
         const pt = getSvgPoint(e.clientX, e.clientY);
         if (state.interaction.type === "drag") updateDrag(pt);
+        if (state.interaction.type === "resize") updateResize(pt);
         if (state.interaction.type === "marquee") updateMarquee(pt);
       });
 
       window.addEventListener("pointerup", () => {
         if (!state.interaction) return;
         if (state.interaction.type === "drag") finishDrag();
+        if (state.interaction.type === "resize") finishResize();
         if (state.interaction.type === "marquee") finishMarquee();
       });
 
@@ -1045,6 +1277,9 @@
       setupEvents();
       const interval = localStorage.getItem(AUTOSAVE_INTERVAL_KEY) || "off";
       document.getElementById("autosaveSelect").value = ["off", "10", "30"].includes(interval) ? interval : "off";
+      const alignBasis = localStorage.getItem(ALIGN_BASIS_KEY);
+      state.alignBasis = alignBasis === "first" ? "first" : "bbox";
+      document.getElementById("alignBasisSelect").value = state.alignBasis;
       refreshRestoreList();
       updateAutosaveTimer();
       pushHistory("init");
