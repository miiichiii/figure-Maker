--- /tmp/index_before_r3.html	2026-02-19 03:01:25
+++ index.html	2026-02-19 03:02:12
@@ -6,6 +6,7 @@
   <title>Figure Maker</title>
   <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/svg2pdf.js@2.5.0/dist/svg2pdf.umd.min.js"></script>
+  <script src="https://cdn.jsdelivr.net/npm/canvg@4.0.2/lib/umd.min.js"></script>
   <style>
     :root {
       --bg: #f3f4f6;
@@ -138,6 +139,11 @@
         <button id="ungroupBtn">Ungroup</button>
       </div>
       <div class="group">
+        <label for="alignBasisSelect">Align base</label>
+        <select id="alignBasisSelect">
+          <option value="bbox">Selection Box</option>
+          <option value="first">First Selected</option>
+        </select>
         <button data-align="left">Align L</button>
         <button data-align="hcenter">Align C</button>
         <button data-align="right">Align R</button>
@@ -176,6 +182,7 @@
     const XLINK_NS = "http://www.w3.org/1999/xlink";
     const AUTOSAVE_KEY = "figureMaker_autosave_records";
     const AUTOSAVE_INTERVAL_KEY = "figureMaker_autosave_interval";
+    const ALIGN_BASIS_KEY = "figureMaker_align_basis";
 
     const canvas = document.getElementById("canvas");
     const statusEl = document.getElementById("status");
@@ -191,7 +198,8 @@
       maxHistory: 100,
       interaction: null,
       autosaveTimer: null,
-      contextGroupId: null
+      contextGroupId: null,
+      alignBasis: "bbox"
     };
 
     function setStatus(msg) {
@@ -391,8 +399,18 @@
         el.classList.remove("fm-group-selected");
       });
       return clone.innerHTML;
+    }
+
+    function getCanvasDimensions() {
+      const vb = (canvas.getAttribute("viewBox") || "0 0 1200 700").split(/\s+/).map(Number);
+      return { width: vb[2] || 1200, height: vb[3] || 700 };
     }
 
+    function getCleanSvgDocument() {
+      const { width, height } = getCanvasDimensions();
+      return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${height}" width="${width}" height="${height}">${getCleanCanvasMarkup()}</svg>`;
+    }
+
     function getSnapshot() {
       return { markup: getCleanCanvasMarkup(), selectedIds: [...state.selectedIds], at: Date.now() };
     }
@@ -454,28 +472,41 @@
       }
       const bounds = elements.map(safeBBox).filter(Boolean);
       if (!bounds.length) return;
-      const minX = Math.min(...bounds.map((b) => b.x));
-      const maxX = Math.max(...bounds.map((b) => b.x + b.width));
-      const minY = Math.min(...bounds.map((b) => b.y));
-      const maxY = Math.max(...bounds.map((b) => b.y + b.height));
-      const centerX = (minX + maxX) / 2;
-      const centerY = (minY + maxY) / 2;
+      let baseMinX = Math.min(...bounds.map((b) => b.x));
+      let baseMaxX = Math.max(...bounds.map((b) => b.x + b.width));
+      let baseMinY = Math.min(...bounds.map((b) => b.y));
+      let baseMaxY = Math.max(...bounds.map((b) => b.y + b.height));
+      let anchorEl = null;
+      if (state.alignBasis === "first") {
+        const firstId = state.selectedIds.find((id) => elements.some((el) => el.dataset.id === id));
+        anchorEl = firstId ? getById(firstId) : elements[0];
+        const anchorBox = anchorEl ? safeBBox(anchorEl) : null;
+        if (anchorBox) {
+          baseMinX = anchorBox.x;
+          baseMaxX = anchorBox.x + anchorBox.width;
+          baseMinY = anchorBox.y;
+          baseMaxY = anchorBox.y + anchorBox.height;
+        }
+      }
+      const centerX = (baseMinX + baseMaxX) / 2;
+      const centerY = (baseMinY + baseMaxY) / 2;
 
       elements.forEach((el) => {
+        if (state.alignBasis === "first" && anchorEl && el === anchorEl) return;
         const bRaw = el.getBBox();
         const t = getTranslate(el);
         let newX = t.x;
         let newY = t.y;
-        if (mode === "left") newX = minX - bRaw.x;
+        if (mode === "left") newX = baseMinX - bRaw.x;
         if (mode === "hcenter") newX = centerX - (bRaw.x + bRaw.width / 2);
-        if (mode === "right") newX = maxX - (bRaw.x + bRaw.width);
-        if (mode === "top") newY = minY - bRaw.y;
+        if (mode === "right") newX = baseMaxX - (bRaw.x + bRaw.width);
+        if (mode === "top") newY = baseMinY - bRaw.y;
         if (mode === "vcenter") newY = centerY - (bRaw.y + bRaw.height / 2);
-        if (mode === "bottom") newY = maxY - (bRaw.y + bRaw.height);
+        if (mode === "bottom") newY = baseMaxY - (bRaw.y + bRaw.height);
         setTranslate(el, newX, newY);
       });
       applySelectionStyles();
-      pushHistory(`align-${mode}`);
+      pushHistory(`align-${mode}-${state.alignBasis}`);
     }
 
     function distributeSelected(axis) {
@@ -589,7 +620,7 @@
     }
 
     function saveSvg() {
-      const markup = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${canvas.getAttribute("viewBox")}" width="1200" height="700">${getCleanCanvasMarkup()}</svg>`;
+      const markup = getCleanSvgDocument();
       const blob = new Blob([markup], { type: "image/svg+xml;charset=utf-8" });
       const url = URL.createObjectURL(blob);
       const a = document.createElement("a");
@@ -606,12 +637,24 @@
           setStatus("jsPDF unavailable.");
           return;
         }
-        const vb = (canvas.getAttribute("viewBox") || "0 0 1200 700").split(/\s+/).map(Number);
-        const w = vb[2] || 1200;
-        const h = vb[3] || 700;
+        const { width: w, height: h } = getCanvasDimensions();
         const { jsPDF } = window.jspdf;
         const pdf = new jsPDF({ unit: "pt", format: [w, h], orientation: w >= h ? "landscape" : "portrait" });
-        await pdf.svg(canvas, { x: 0, y: 0, width: w, height: h });
+        try {
+          const cleanSvg = new DOMParser().parseFromString(getCleanSvgDocument(), "image/svg+xml").documentElement;
+          await pdf.svg(cleanSvg, { x: 0, y: 0, width: w, height: h });
+        } catch (_) {
+          if (!window.canvg || !window.canvg.Canvg) throw new Error("svg2pdf failed and canvg unavailable");
+          const tempCanvas = document.createElement("canvas");
+          tempCanvas.width = Math.max(1, Math.round(w));
+          tempCanvas.height = Math.max(1, Math.round(h));
+          const ctx = tempCanvas.getContext("2d");
+          if (!ctx) throw new Error("Canvas context unavailable");
+          const v = await window.canvg.Canvg.fromString(ctx, getCleanSvgDocument());
+          await v.render();
+          const pngData = tempCanvas.toDataURL("image/png");
+          pdf.addImage(pngData, "PNG", 0, 0, w, h);
+        }
         pdf.save("figure.pdf");
         setStatus("PDF exported.");
       } catch (err) {
@@ -933,6 +976,12 @@
       document.querySelectorAll("[data-distribute]").forEach((btn) => {
         btn.addEventListener("click", () => distributeSelected(btn.dataset.distribute));
       });
+      document.getElementById("alignBasisSelect").addEventListener("change", (e) => {
+        const value = e.target.value === "first" ? "first" : "bbox";
+        state.alignBasis = value;
+        localStorage.setItem(ALIGN_BASIS_KEY, value);
+        setStatus(`Align base: ${value === "first" ? "first selected" : "selection box"}`);
+      });
 
       const fileInput = document.getElementById("openFileInput");
       document.getElementById("openSvg").addEventListener("click", () => fileInput.click());
@@ -1045,6 +1094,9 @@
       setupEvents();
       const interval = localStorage.getItem(AUTOSAVE_INTERVAL_KEY) || "off";
       document.getElementById("autosaveSelect").value = ["off", "10", "30"].includes(interval) ? interval : "off";
+      const alignBasis = localStorage.getItem(ALIGN_BASIS_KEY);
+      state.alignBasis = alignBasis === "first" ? "first" : "bbox";
+      document.getElementById("alignBasisSelect").value = state.alignBasis;
       refreshRestoreList();
       updateAutosaveTimer();
       pushHistory("init");
