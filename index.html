<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Figure Maker (Beta)</title>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/svg2pdf.js@2.5.0/dist/svg2pdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvg@4.0.2/lib/umd.min.js"></script>
  <style>
    :root {
      --bg: #F3EFE6;
      --panel: #E7D7B8;
      --card: #F6F0E3;
      --border: #CBB489;
      --ink: #2B2A27;
      --muted: #4f4a41;
      --accent: #7B5A2B;
      --accent-hover: #B07D2B;
      --focus: #5a8fc7;
      --danger: #B84A3A;
      --button-bg: var(--accent);
      --button-text: #ffffff;
      --input-bg: #F6F0E3;
      --input-border: #CBB489;
      --line: var(--border);
    }
    * { box-sizing: border-box; font-family: "Zen Kaku Gothic New", "Roboto", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; }
    body { margin: 0; color: var(--ink); background: var(--bg); }
    .app { height: 100vh; display: grid; grid-template-rows: auto auto 1fr auto; }
    .menu-bar {
      display: flex;
      align-items: center;
      gap: 2px;
      padding: 4px 8px;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
      user-select: none;
      position: relative;
      z-index: 20;
    }
    .menu-root { position: relative; }
    .menu-trigger {
      border: none;
      background: transparent;
      border-radius: 4px;
      padding: 6px 10px;
      font-size: 13px;
      color: var(--ink);
    }
    .menu-root.open .menu-trigger,
    .menu-trigger:hover {
      background: var(--card);
      color: var(--ink);
    }
    .menu-panel {
      display: none;
      position: absolute;
      top: calc(100% + 4px);
      left: 0;
      z-index: 30;
      min-width: 220px;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 10px 24px rgba(43, 42, 39, 0.16);
      padding: 6px;
    }
    .menu-root.open .menu-panel { display: block; }
    .menu-action {
      display: block;
      width: 100%;
      text-align: left;
      border: none;
      background: transparent;
      border-radius: 5px;
      padding: 7px 10px;
      font-size: 12px;
      color: var(--ink);
    }
    .menu-action:hover { background: var(--panel); color: var(--ink); }
    .menu-sep {
      height: 1px;
      background: var(--border);
      margin: 6px 0;
    }
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      padding: 8px;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
      align-items: center;
    }
    .toolbar-tabs {
      width: 100%;
      display: flex;
      gap: 6px;
      margin-bottom: 2px;
      padding-bottom: 6px;
      border-bottom: 1px solid var(--border);
    }
    .toolbar-tab-btn {
      min-width: 72px;
      font-weight: 700;
    }
    .toolbar-tab-btn.active {
      background: var(--button-bg);
      color: var(--button-text);
      border-color: var(--accent);
    }
    .group { display: flex; gap: 6px; align-items: center; padding-right: 8px; border-right: 1px solid var(--border); }
    .group:last-child { border-right: none; }
    .group[hidden] { display: none !important; }
    button, select, input[type="number"], input[type="text"], input[type="color"] {
      border: 1px solid var(--input-border);
      background: var(--input-bg);
      color: var(--ink);
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 12px;
      line-height: 1.2;
    }
    button, select {
      cursor: pointer;
    }
    button.active { background: var(--button-bg); color: var(--button-text); border-color: var(--accent); }
    button:hover { border-color: var(--accent-hover); }
    button:focus-visible, select:focus-visible, input:focus-visible {
      outline: 2px solid var(--focus);
      outline-offset: 1px;
    }
    .menu-bar .menu-trigger,
    .menu-bar .menu-action {
      border: none;
      background: transparent;
      color: var(--ink);
    }
    .tool-icon-btn {
      width: 34px;
      height: 30px;
      padding: 3px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .tool-icon-btn svg {
      width: 18px;
      height: 18px;
      display: block;
    }
    .shape-icon-btn {
      width: 34px;
      height: 30px;
      padding: 3px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .shape-icon-btn svg {
      width: 18px;
      height: 18px;
      display: block;
    }
    .align-icon-btn {
      width: 34px;
      height: 30px;
      padding: 3px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .align-icon-btn svg {
      width: 17px;
      height: 17px;
      display: block;
    }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    .toolbar input[type="number"] { text-align: right; }
    .zoom-group { gap: 4px; }
    #zoomSlider { width: 120px; }
    #zoomPercentInput { width: 62px; text-align: right; }
    .canvas-wrap { padding: 10px; overflow: auto; position: relative; background: var(--bg); transition: background-color 0.12s ease, box-shadow 0.12s ease; }
    .canvas-wrap.drag-over { background: #efe8d8; box-shadow: inset 0 0 0 2px var(--focus); }
    .canvas-wrap.hand-mode { cursor: grab; }
    .canvas-wrap.is-panning { cursor: grabbing; }
    #canvas {
      width: 8000px;
      height: 8000px;
      background: transparent;
      border: none;
      box-shadow: none;
      overflow: visible;
      user-select: none;
      touch-action: none;
    }
    .fm-artboard-layer {
      pointer-events: none;
    }
    .fm-artboard-bg {
      fill: #ffffff;
      stroke: var(--border);
      stroke-width: 1;
      filter: drop-shadow(0 8px 20px rgba(43, 42, 39, 0.18));
    }
    #status.status {
      padding: 6px 10px;
      font-size: 12px;
      color: var(--muted);
      border-top: 1px solid var(--border);
      background: var(--panel);
      min-height: 30px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #copyright {
      font-size: 11px;
      color: var(--muted);
      margin-left: auto;
      padding-left: 8px;
    }
    .marquee {
      fill: rgba(90, 143, 199, 0.14);
      stroke: var(--focus);
      stroke-dasharray: 4 2;
      pointer-events: none;
    }
    .selection-outline {
      fill: none;
      stroke: var(--focus);
      stroke-width: 1.5;
      stroke-dasharray: 6 3;
      pointer-events: none;
      vector-effect: non-scaling-stroke;
    }
    .selection-handle {
      fill: var(--card);
      stroke: var(--focus);
      stroke-width: 1.5;
      cursor: nwse-resize;
      vector-effect: non-scaling-stroke;
    }
    .smart-guide {
      fill: none;
      stroke: var(--danger);
      stroke-width: 1.2;
      stroke-dasharray: 5 3;
      opacity: 0.95;
      pointer-events: none;
      vector-effect: non-scaling-stroke;
    }
    .crop-boundary {
      fill: none;
      stroke: #111;
      stroke-opacity: 0.7;
      stroke-width: 1.15;
      pointer-events: none;
      vector-effect: non-scaling-stroke;
    }
    .crop-mask {
      fill: rgba(0, 0, 0, 0.46);
      pointer-events: none;
    }
    .crop-draft {
      fill: none;
      stroke: #101010;
      stroke-width: 2.2;
      pointer-events: none;
      vector-effect: non-scaling-stroke;
    }
    .crop-handle {
      fill: #111;
      stroke: #fff;
      stroke-width: 1.4;
      vector-effect: non-scaling-stroke;
    }
    .crop-handle[data-handle="n"],
    .crop-handle[data-handle="s"] { cursor: ns-resize; }
    .crop-handle[data-handle="e"],
    .crop-handle[data-handle="w"] { cursor: ew-resize; }
    .crop-handle[data-handle="nw"],
    .crop-handle[data-handle="se"] { cursor: nwse-resize; }
    .crop-handle[data-handle="ne"],
    .crop-handle[data-handle="sw"] { cursor: nesw-resize; }
    .context-menu {
      position: fixed;
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(43, 42, 39, 0.18);
      display: none;
      z-index: 10;
      padding: 4px;
      min-width: 110px;
    }
    .context-menu button {
      display: block;
      width: 100%;
      text-align: left;
      border: none;
      background: transparent;
      border-radius: 4px;
      padding: 6px 8px;
    }
    .context-menu button:hover { background: var(--panel); }
    .context-menu button.disabled,
    .context-menu button:disabled {
      color: var(--muted);
      background: transparent;
      cursor: default;
      pointer-events: none;
    }
    .mark-editor {
      position: fixed;
      z-index: 40;
      display: none;
      align-items: center;
      gap: 6px;
      padding: 6px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--card);
      box-shadow: 0 8px 24px rgba(43, 42, 39, 0.18);
    }
    .mark-editor input {
      width: 42px;
      text-transform: uppercase;
      text-align: center;
      font-weight: 700;
      font-size: 13px;
      padding: 4px 6px;
    }
    .mark-editor button {
      padding: 4px 8px;
      font-size: 12px;
    }
    .figure-editor-prefix {
      font-size: 12px;
      font-weight: 700;
      color: var(--muted);
      min-width: 42px;
      text-align: center;
    }
    #figureEditorInput {
      width: 64px;
      text-align: center;
      font-weight: 700;
    }
    .mark-editor-spin {
      display: grid;
      grid-template-rows: 1fr 1fr;
      gap: 2px;
    }
    .mark-editor-spin button {
      width: 28px;
      min-width: 28px;
      height: 20px;
      padding: 1px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .mark-editor-spin svg {
      width: 11px;
      height: 11px;
      display: block;
    }
    .fm-group-label {
      font-family: "Zen Kaku Gothic New", "Roboto", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      font-weight: bold;
      fill: var(--ink);
      pointer-events: visiblePainted;
    }
    .fm-figure-title {
      font-family: "Zen Kaku Gothic New", "Roboto", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      font-weight: 700;
      fill: var(--ink);
      pointer-events: visiblePainted;
    }
    #toggleAdvanced { display: none; }
    body.compact .toolbar { gap: 6px; padding: 6px; }
    body.compact .group { gap: 4px; padding-right: 6px; }
    body.compact button, body.compact select { padding: 4px 6px; font-size: 11px; }
    body.compact .group label { display: none; }
    body.compact #toggleAdvanced { display: inline-block; }
    body.compact #restoreList,
    body.compact #restoreFromList { display: none; }
    body.compact.show-advanced #restoreList,
    body.compact.show-advanced #restoreFromList { display: inline-block; }
    body.compact #canvas {
      max-width: none;
      min-width: 0;
    }
    #textEditorInput {
      position: absolute;
      display: none;
      z-index: 30;
      min-width: 120px;
      padding: 4px 6px;
      border: 1px solid var(--focus);
      border-radius: 4px;
      font-size: 16px;
      background: var(--card);
      color: var(--ink);
    }
    #pasteSink {
      position: fixed;
      left: -10000px;
      top: -10000px;
      width: 1px;
      height: 1px;
      opacity: 0;
      pointer-events: none;
    }
    #errorNotice {
      position: fixed;
      right: 12px;
      bottom: 12px;
      z-index: 60;
      width: min(540px, calc(100vw - 24px));
      background: var(--card);
      border: 1px solid var(--danger);
      border-radius: 10px;
      box-shadow: 0 8px 24px rgba(43, 42, 39, 0.2);
      padding: 10px 12px;
      display: none;
      gap: 8px;
      align-items: flex-start;
    }
    #errorNotice.show { display: flex; }
    #errorNotice strong { color: var(--danger); font-size: 14px; }
    #errorNoticeMeta { font-size: 12px; color: var(--muted); margin-top: 3px; }
    #errorNoticeActions { margin-left: auto; display: flex; gap: 6px; }
    #shortcutModal {
      position: fixed;
      inset: 0;
      z-index: 70;
      background: rgba(43, 42, 39, 0.35);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
    }
    #shortcutModal.show { display: flex; }
    #shortcutCard {
      width: min(760px, 100%);
      max-height: min(82vh, 920px);
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 16px 36px rgba(43, 42, 39, 0.22);
      display: grid;
      grid-template-rows: auto 1fr;
      overflow: hidden;
    }
    #shortcutHead {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
    }
    #shortcutHead strong { font-size: 14px; }
    #shortcutHelpText {
      margin: 0;
      padding: 12px;
      white-space: pre-wrap;
      overflow: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      line-height: 1.5;
      background: var(--card);
      color: var(--ink);
    }
    #uiTooltip {
      position: fixed;
      left: 0;
      top: 0;
      transform: translate(-9999px, -9999px);
      z-index: 9999;
      pointer-events: none;
      max-width: min(420px, 86vw);
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: #fffdf8;
      color: var(--ink);
      font-size: 12px;
      line-height: 1.35;
      box-shadow: 0 6px 16px rgba(43, 42, 39, 0.2);
      opacity: 0;
      transition: opacity 0.08s ease;
      white-space: normal;
    }
    #uiTooltip.show {
      opacity: 1;
    }
  </style>
</head>
  <body>
  <div class="app">
    <div id="menuBar" class="menu-bar">
      <div class="menu-root" data-menu-root="file">
        <button class="menu-trigger" data-menu-trigger="file">File</button>
        <div class="menu-panel">
          <button class="menu-action" data-menu-action="file.new">New</button>
          <button class="menu-action" data-menu-action="file.open">Open SVG...</button>
          <button class="menu-action" data-menu-action="file.import">Import SVG...</button>
          <button class="menu-action" data-menu-action="file.save">Save SVG</button>
          <button class="menu-action" data-menu-action="file.saveAs">Save As...</button>
          <button class="menu-action" data-menu-action="file.pdf">Export PDF</button>
        </div>
      </div>
      <div class="menu-root" data-menu-root="edit">
        <button class="menu-trigger" data-menu-trigger="edit">Edit</button>
        <div class="menu-panel">
          <button class="menu-action" data-menu-action="edit.undo">Undo</button>
          <button class="menu-action" data-menu-action="edit.redo">Redo</button>
          <div class="menu-sep"></div>
          <button class="menu-action" data-menu-action="edit.copy">Copy (SVG)</button>
          <button class="menu-action" data-menu-action="edit.copyImage">Copy as Image (for Excel)</button>
          <button class="menu-action" data-menu-action="edit.cut">Cut</button>
          <button class="menu-action" data-menu-action="edit.paste">Paste (Internal)</button>
          <div class="menu-sep"></div>
          <button class="menu-action" data-menu-action="edit.group">Group</button>
          <button class="menu-action" data-menu-action="edit.ungroup">Ungroup</button>
        </div>
      </div>
      <div class="menu-root" data-menu-root="page">
        <button class="menu-trigger" data-menu-trigger="page">Page Setup</button>
        <div class="menu-panel">
          <button class="menu-action" data-menu-action="page.canvas.a4.portrait">A4 Portrait (794 x 1123)</button>
          <button class="menu-action" data-menu-action="page.canvas.a4.landscape">A4 Landscape (1123 x 794)</button>
          <button class="menu-action" data-menu-action="page.canvas.custom">Canvas Size...</button>
        </div>
      </div>
      <div class="menu-root" data-menu-root="maintenance">
        <button class="menu-trigger" data-menu-trigger="maintenance">Maintenance</button>
        <div class="menu-panel">
          <button class="menu-action" data-menu-action="maintenance.shortcuts">Shortcuts</button>
          <button class="menu-action" data-menu-action="maintenance.restore">Restore Latest Autosave</button>
          <div class="menu-sep"></div>
          <button class="menu-action" data-menu-action="maintenance.pasteReport">Paste Report</button>
          <button class="menu-action" data-menu-action="maintenance.pasteReport.copy">Copy Paste Report</button>
          <button class="menu-action" data-menu-action="maintenance.pasteReport.save">Save Paste Report</button>
          <button class="menu-action" data-menu-action="maintenance.pasteReport.history">Report History</button>
          <button class="menu-action" data-menu-action="maintenance.pasteReport.history.copy">Copy Report History</button>
          <button class="menu-action" data-menu-action="maintenance.pasteReport.history.clear">Clear Report History</button>
        </div>
      </div>
    </div>
    <div class="toolbar">
      <div class="toolbar-tabs" id="toolbarTabBar">
        <button class="toolbar-tab-btn active" data-toolbar-tab-btn="tool">Tool</button>
        <button class="toolbar-tab-btn" data-toolbar-tab-btn="object">Object</button>
        <button class="toolbar-tab-btn" data-toolbar-tab-btn="text">Text</button>
      </div>
      <div class="group" data-toolbar-tab="all">
        <button id="toolSelect" class="active tool-icon-btn" title="Select tool" aria-label="Select tool">
          <svg viewBox="0 0 20 20" aria-hidden="true">
            <path d="M2 1 L2 18 L7 13 L10 19 L12 18 L9 12 L15 12 Z" fill="#111827" stroke="#ffffff" stroke-width="1"></path>
          </svg>
          <span class="sr-only">Black Arrow</span>
        </button>
        <button id="toolDirect" class="tool-icon-btn" title="Direct select tool" aria-label="Direct select tool">
          <svg viewBox="0 0 20 20" aria-hidden="true">
            <path d="M2 1 L2 18 L7 13 L10 19 L12 18 L9 12 L15 12 Z" fill="#ffffff" stroke="#111827" stroke-width="1.3"></path>
          </svg>
          <span class="sr-only">White Arrow</span>
        </button>
      </div>
      <div class="group" data-toolbar-tab="tool">
        <button id="toolHand" class="tool-icon-btn" title="Hand tool (H / hold Space)" aria-label="Hand tool (H / hold Space)">
          <svg viewBox="0 0 20 20" aria-hidden="true">
            <path d="M7 18 C5.5 18 4.4 16.9 4.3 15.4 L3.8 10.3 C3.7 9.4 4.4 8.6 5.3 8.6 C6.1 8.6 6.8 9.2 6.9 10 L7.2 12.5 V4.7 C7.2 3.8 7.9 3.1 8.8 3.1 C9.7 3.1 10.4 3.8 10.4 4.7 V10.4 H10.8 V3.9 C10.8 3 11.5 2.3 12.4 2.3 C13.3 2.3 14 3 14 3.9 V10.4 H14.4 V5 C14.4 4.1 15.1 3.4 16 3.4 C16.9 3.4 17.6 4.1 17.6 5 V12.2 C17.6 15.4 14.9 18 11.7 18 Z" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"></path>
          </svg>
          <span class="sr-only">Hand</span>
        </button>
        <button id="undoBtn" class="tool-icon-btn" title="Undo (Ctrl/Cmd+Z)" aria-label="Undo (Ctrl/Cmd+Z)">
          <svg viewBox="0 0 20 20" aria-hidden="true">
            <path d="M7 5 L3 9 L7 13" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"></path>
            <path d="M4 9 H12 C15.2 9 17 10.8 17 14" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"></path>
          </svg>
          <span class="sr-only">Undo</span>
        </button>
        <button id="redoBtn" class="tool-icon-btn" title="Redo (Ctrl/Cmd+Shift+Z)" aria-label="Redo (Ctrl/Cmd+Shift+Z)">
          <svg viewBox="0 0 20 20" aria-hidden="true">
            <path d="M13 5 L17 9 L13 13" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"></path>
            <path d="M16 9 H8 C4.8 9 3 10.8 3 14" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"></path>
          </svg>
          <span class="sr-only">Redo</span>
        </button>
        <button id="shortcutsBtn">Shortcuts</button>
      </div>
      <div class="group zoom-group" data-toolbar-tab="tool">
        <label for="zoomSlider">Zoom</label>
        <button id="zoomOutBtn" title="Zoom out">-</button>
        <input id="zoomSlider" type="range" min="5" max="12800" step="1" value="100" />
        <input id="zoomPercentInput" type="number" min="5" max="12800" step="1" value="100" />
        <span>%</span>
        <button id="zoomInBtn" title="Zoom in">+</button>
        <button id="zoomResetBtn" title="Reset zoom">Reset</button>
        <button id="cropImageBtn" title="Crop selected image">Crop</button>
        <button id="cropApplyBtn" title="Apply crop" hidden>Apply Crop</button>
        <button id="cropCancelBtn" title="Cancel crop" hidden>Cancel Crop</button>
      </div>
      <div class="group" data-toolbar-tab="tool">
        <button id="newCanvas">New</button>
        <button id="openSvg">Open SVG</button>
        <button id="importSvgBtn">Import SVG</button>
        <button id="saveSvg">Save SVG</button>
        <button id="exportPdf">Export PDF</button>
      </div>
      <div class="group" data-toolbar-tab="tool">
        <button id="groupBtn">Group</button>
        <button id="ungroupBtn">Ungroup</button>
        <button id="duplicateBtn">Duplicate</button>
      </div>
      <div class="group" data-toolbar-tab="tool">
        <label for="autosaveSelect">Autosave</label>
        <select id="autosaveSelect">
          <option value="off">Off</option>
          <option value="10">10 min</option>
          <option value="30">30 min</option>
        </select>
        <button id="restoreLatest">Restore latest</button>
        <button id="toggleAdvanced">More</button>
        <select id="restoreList"></select>
        <button id="restoreFromList">Restore selected</button>
      </div>
      <div class="group" data-toolbar-tab="object">
        <button id="addRect" class="shape-icon-btn" title="Rect (R)" aria-label="Rect (R)">
          <svg viewBox="0 0 20 20" aria-hidden="true">
            <rect x="3" y="4" width="14" height="12" fill="none" stroke="currentColor" stroke-width="1.6"></rect>
          </svg>
          <span class="sr-only">Rect</span>
        </button>
        <button id="addEllipse" class="shape-icon-btn" title="Ellipse (E)" aria-label="Ellipse (E)">
          <svg viewBox="0 0 20 20" aria-hidden="true">
            <ellipse cx="10" cy="10" rx="7" ry="5.5" fill="none" stroke="currentColor" stroke-width="1.6"></ellipse>
          </svg>
          <span class="sr-only">Ellipse</span>
        </button>
        <button id="addLine" class="shape-icon-btn" title="Line (L)" aria-label="Line (L)">
          <svg viewBox="0 0 20 20" aria-hidden="true">
            <path d="M3 10 H17" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"></path>
          </svg>
          <span class="sr-only">Line</span>
        </button>
        <button id="addTriangle" class="shape-icon-btn" title="Triangle" aria-label="Triangle">
          <svg viewBox="0 0 20 20" aria-hidden="true">
            <polygon points="10,3 17,16 3,16" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linejoin="round"></polygon>
          </svg>
          <span class="sr-only">Triangle</span>
        </button>
        <button id="matchArrowBtn" title="Apply Arrow: selected line(s) get an arrowhead. Arrowhead height follows stroke width x3.">Apply Arrow</button>
        <label for="lineStrokeWidthInput">Stroke width</label>
        <input id="lineStrokeWidthInput" type="number" min="0.5" max="20" step="0.5" value="3" style="width:70px" />
        <label for="objectFillColorInput">Fill</label>
        <input id="objectFillColorInput" type="color" value="#dbeafe" />
        <label for="objectStrokeColorInput">Stroke</label>
        <input id="objectStrokeColorInput" type="color" value="#1e3a8a" />
        <label for="objectStrokeToggle">Stroke on</label>
        <input id="objectStrokeToggle" type="checkbox" checked />
      </div>
      <div class="group" data-toolbar-tab="object">
        <label for="alignBasisSelect">Align base</label>
        <select id="alignBasisSelect">
          <option value="bbox">Selection Box</option>
          <option value="first">First Selected</option>
        </select>
        <button class="align-icon-btn" data-align="left" title="Align Left" aria-label="Align Left">
          <svg viewBox="0 0 16 16" aria-hidden="true">
            <path d="M2 2V14M4 5H12M4 9H10" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/>
          </svg>
        </button>
        <button class="align-icon-btn" data-align="hcenter" title="Align Center" aria-label="Align Center">
          <svg viewBox="0 0 16 16" aria-hidden="true">
            <path d="M8 2V14M2 5H14M4 9H12" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/>
          </svg>
        </button>
        <button class="align-icon-btn" data-align="right" title="Align Right" aria-label="Align Right">
          <svg viewBox="0 0 16 16" aria-hidden="true">
            <path d="M14 2V14M4 5H12M6 9H12" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/>
          </svg>
        </button>
        <button class="align-icon-btn" data-align="top" title="Align Top" aria-label="Align Top">
          <svg viewBox="0 0 16 16" aria-hidden="true">
            <path d="M2 2H14M4 4V12M9 4V10" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/>
          </svg>
        </button>
        <button class="align-icon-btn" data-align="vcenter" title="Align Middle" aria-label="Align Middle">
          <svg viewBox="0 0 16 16" aria-hidden="true">
            <path d="M2 8H14M4 3V13M9 5V11" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/>
          </svg>
        </button>
        <button class="align-icon-btn" data-align="bottom" title="Align Bottom" aria-label="Align Bottom">
          <svg viewBox="0 0 16 16" aria-hidden="true">
            <path d="M2 14H14M4 4V12M9 6V12" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/>
          </svg>
        </button>
        <button class="align-icon-btn" data-distribute="h" title="Distribute Horizontal" aria-label="Distribute Horizontal">
          <svg viewBox="0 0 16 16" aria-hidden="true">
            <path d="M2 2V14M14 2V14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round"/>
            <rect x="4.5" y="5" width="2" height="6" fill="none" stroke="currentColor" stroke-width="1.2"/>
            <rect x="9.5" y="5" width="2" height="6" fill="none" stroke="currentColor" stroke-width="1.2"/>
          </svg>
        </button>
        <button class="align-icon-btn" data-distribute="v" title="Distribute Vertical" aria-label="Distribute Vertical">
          <svg viewBox="0 0 16 16" aria-hidden="true">
            <path d="M2 2H14M2 14H14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round"/>
            <rect x="5" y="4.5" width="6" height="2" fill="none" stroke="currentColor" stroke-width="1.2"/>
            <rect x="5" y="9.5" width="6" height="2" fill="none" stroke="currentColor" stroke-width="1.2"/>
          </svg>
        </button>
      </div>
      <div class="group" data-toolbar-tab="text">
        <button id="addText">Text</button>
        <button id="textBoldBtn" title="Bold"><strong>B</strong></button>
        <button id="textItalicBtn" title="Italic"><em>I</em></button>
        <button id="textSuperBtn" title="Superscript">X<sup>2</sup></button>
        <button id="textSubBtn" title="Subscript">X<sub>2</sub></button>
        <label for="textFontSizeInput">Text size</label>
        <input id="textFontSizeInput" type="number" min="6" max="240" step="1" value="28" style="width:64px" />
        <label for="textColorInput">Color</label>
        <input id="textColorInput" type="color" value="#111827" />
        <label for="markFontSizeInput">Mark size</label>
        <input id="markFontSizeInput" type="number" min="6" max="120" step="1" value="16" style="width:64px" />
      </div>
    </div>
    <input id="openFileInput" type="file" accept=".svg,image/svg+xml" hidden />
    <input id="importFileInput" type="file" accept=".svg,image/svg+xml" hidden />
    <div class="canvas-wrap" tabindex="0">
      <svg id="canvas" viewBox="0 0 8000 8000" xmlns="http://www.w3.org/2000/svg"></svg>
      <input id="textEditorInput" type="text" />
    </div>
    <textarea id="pasteSink" aria-hidden="true" inputmode="none"></textarea>
    <div id="status" class="status">
      <span id="statusMessage">Ready.</span>
      <span id="copyright">Â© 2026 Michito Hamada (Beta)</span>
    </div>
  </div>

  <div id="ctxMenu" class="context-menu">
    <button data-ctx-action="copy">Copy</button>
    <button data-ctx-action="cut">Cut</button>
    <button data-ctx-action="paste">Paste</button>
    <button data-ctx-action="rasterize-image" hidden>Rasterize...</button>
    <div class="menu-sep"></div>
    <button data-ctx-action="mark">Mark (A-Z)...</button>
    <button data-ctx-action="mark-clear">Clear Mark</button>
    <div class="menu-sep"></div>
    <button data-ctx-action="group">Group</button>
    <button data-ctx-action="ungroup">Ungroup</button>
    <button data-ctx-action="duplicate">Duplicate</button>
  </div>
  <div id="markEditor" class="mark-editor" role="dialog" aria-label="Edit mark">
    <input id="markEditorInput" type="text" maxlength="1" autocomplete="off" />
    <div class="mark-editor-spin">
      <button id="markEditorUpBtn" type="button" aria-label="Mark Up">
        <svg viewBox="0 0 12 12" aria-hidden="true">
          <path d="M2 8 L6 3 L10 8 Z" fill="currentColor"></path>
        </svg>
      </button>
      <button id="markEditorDownBtn" type="button" aria-label="Mark Down">
        <svg viewBox="0 0 12 12" aria-hidden="true">
          <path d="M2 4 L6 9 L10 4 Z" fill="currentColor"></path>
        </svg>
      </button>
    </div>
    <button id="markEditorApplyBtn" type="button">OK</button>
    <button id="markEditorCancelBtn" type="button">Cancel</button>
  </div>
  <div id="figureEditor" class="mark-editor" role="dialog" aria-label="Edit figure number">
    <select id="figureEditorType">
      <option value="figure">Figure</option>
      <option value="supplementary">Supplementary Figure</option>
    </select>
    <span class="figure-editor-prefix">Figure</span>
    <input id="figureEditorInput" type="number" min="0" max="9999" step="1" inputmode="numeric" />
    <button id="figureEditorApplyBtn" type="button">OK</button>
    <button id="figureEditorCancelBtn" type="button">Cancel</button>
  </div>

  <div id="errorNotice" role="alert" aria-live="assertive">
    <div>
      <strong id="errorNoticeTitle">Error ID: -</strong>
      <div id="errorNoticeMeta">An unexpected error occurred.</div>
    </div>
    <div id="errorNoticeActions">
      <button id="downloadErrorLogBtn">Download log</button>
      <button id="dismissErrorNoticeBtn">Close</button>
    </div>
  </div>
  <div id="shortcutModal" role="dialog" aria-modal="true" aria-labelledby="shortcutModalTitle">
    <div id="shortcutCard">
      <div id="shortcutHead">
        <strong id="shortcutModalTitle">Keyboard Shortcuts</strong>
        <button id="shortcutCloseBtn" type="button">Close</button>
      </div>
      <pre id="shortcutHelpText"></pre>
    </div>
  </div>

  <script>
    const SVG_NS = "http://www.w3.org/2000/svg";
    const XLINK_NS = "http://www.w3.org/1999/xlink";
    const AUTOSAVE_KEY = "figureMaker_autosave_records";
    const AUTOSAVE_INTERVAL_KEY = "figureMaker_autosave_interval";
    const ALIGN_BASIS_KEY = "figureMaker_align_basis";
    const PASTE_REPORT_KEY = "figureMaker_last_paste_report";
    const PASTE_REPORT_HISTORY_KEY = "figureMaker_paste_report_history";
    const LAST_ERROR_KEY = "figureMaker_last_error";
    const LIVE_AUTOSAVE_KEY = "figureMaker_live_snapshot";
    const AUTOSAVE_DB_NAME = "figureMakerAutosaveDB";
    const AUTOSAVE_DB_VERSION = 1;
    const AUTOSAVE_RECORDS_STORE = "autosaveRecords";
    const AUTOSAVE_META_STORE = "autosaveMeta";
    const AUTOSAVE_META_LIVE_KEY = "liveSnapshot";
    const AUTOSAVE_MAX_RECORDS = 8;
    const MAX_HISTORY_ENTRIES_DEFAULT = 30;
    const MAX_HISTORY_SNAPSHOT_BYTES = 2 * 1024 * 1024;
    const MAX_HISTORY_TOTAL_BYTES = 24 * 1024 * 1024;
    const DEFAULT_VIEWBOX = "0 0 794 1123";
    const WORKSPACE_SIZE = 8000;
    const WORKSPACE_VIEWBOX = `0 0 ${WORKSPACE_SIZE} ${WORKSPACE_SIZE}`;
    const DEFAULT_ARTBOARD_VIEWBOX = `${(WORKSPACE_SIZE - 794) / 2} ${(WORKSPACE_SIZE - 1123) / 2} 794 1123`;
    const FIGURE_TITLE_DEFAULT_FONT_SIZE = 16;
    const MIN_RESIZE_SIZE = 6;
    const MIN_VIEW_SCALE = 0.05;
    const MAX_VIEW_SCALE = 128;
    const PASTE_LOCK_TIMEOUT_MS = 900;
    const DEBUG_MODE = new URLSearchParams(window.location.search).get("debug") === "1";
    const CURSOR_BLACK = "url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 20 20'%3E%3Cpath d='M2 1 L2 18 L7 13 L10 19 L12 18 L9 12 L15 12 Z' fill='%23111827' stroke='%23ffffff' stroke-width='1'/%3E%3C/svg%3E\") 2 2, default";
    const CURSOR_WHITE = "url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 20 20'%3E%3Cpath d='M2 1 L2 18 L7 13 L10 19 L12 18 L9 12 L15 12 Z' fill='%23ffffff' stroke='%23111827' stroke-width='1.3'/%3E%3C/svg%3E\") 2 2, default";
    const CURSOR_ROTATE = "url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='22' height='22' viewBox='0 0 22 22'%3E%3Cg fill='none' stroke='%232B2A27' stroke-width='1.8' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M17.8 7.8A8 8 0 1 0 18.5 13'/%3E%3Cpath d='M17.6 3.8v5h-5'/%3E%3C/g%3E%3C/svg%3E\") 11 11, alias";

    const canvas = document.getElementById("canvas");
    const canvasWrapEl = document.querySelector(".canvas-wrap");
    const statusEl = document.getElementById("status");
    const restoreListEl = document.getElementById("restoreList");
    const ctxMenu = document.getElementById("ctxMenu");
    const markEditorEl = document.getElementById("markEditor");
    const markEditorInputEl = document.getElementById("markEditorInput");
    const figureEditorEl = document.getElementById("figureEditor");
    const figureEditorInputEl = document.getElementById("figureEditorInput");
    const figureEditorTypeEl = document.getElementById("figureEditorType");
    const textEditorInput = document.getElementById("textEditorInput");
    const pasteSinkEl = document.getElementById("pasteSink");
    const errorNoticeEl = document.getElementById("errorNotice");
    const errorNoticeTitleEl = document.getElementById("errorNoticeTitle");
    const errorNoticeMetaEl = document.getElementById("errorNoticeMeta");
    const shortcutModalEl = document.getElementById("shortcutModal");
    const shortcutHelpTextEl = document.getElementById("shortcutHelpText");
    const processedPasteEvents = new WeakSet();

    /* --- Image Pool (Memory Optimization) --- */
    const imagePool = new Map(); // dataUrl -> id
    const imagePoolRev = new Map(); // id -> dataUrl
    let imagePoolCounter = 0;
    let autosaveDbPromise = null;

    function registerImage(dataUrl) {
      if (!dataUrl || !dataUrl.startsWith("data:image/")) return dataUrl;
      if (imagePool.has(dataUrl)) return imagePool.get(dataUrl);
      const id = `pool-${++imagePoolCounter}`;
      imagePool.set(dataUrl, id);
      imagePoolRev.set(id, dataUrl);
      return id;
    }

    function resolveImage(ref) {
      if (!ref || !ref.startsWith("img-ref:")) return ref;
      const id = ref.substring("img-ref:".length);
      return imagePoolRev.get(id) || ref;
    }

    function processMarkupForRefs(markup) {
      if (!markup.includes("data:image/")) return markup;
      const div = document.createElement("div");
      div.innerHTML = markup;
      const images = div.querySelectorAll("image");
      if (images.length === 0) return markup;
      let changed = false;
      images.forEach((img) => {
        const href = img.getAttribute("href") || img.getAttribute("xlink:href");
        if (href && href.startsWith("data:image/")) {
          const id = registerImage(href);
          img.setAttribute("href", `img-ref:${id}`);
          if (img.hasAttribute("xlink:href")) img.removeAttribute("xlink:href");
          changed = true;
        }
      });
      return changed ? div.innerHTML : markup;
    }

    function restoreMarkupFromRefs(markup) {
      if (!markup.includes("img-ref:")) return markup;
      const div = document.createElement("div");
      div.innerHTML = markup;
      const images = div.querySelectorAll("image");
      images.forEach((img) => {
        const href = img.getAttribute("href");
        if (href && href.startsWith("img-ref:")) {
          const resolved = resolveImage(href);
          if (resolved) img.setAttribute("href", resolved);
        }
      });
      return div.innerHTML;
    }

    function hydrateImageRefs(imageRefs) {
      if (!imageRefs || typeof imageRefs !== "object") return;
      Object.entries(imageRefs).forEach(([id, dataUrl]) => {
        if (!id || typeof id !== "string") return;
        if (!dataUrl || typeof dataUrl !== "string" || !dataUrl.startsWith("data:image/")) return;
        imagePoolRev.set(id, dataUrl);
        if (!imagePool.has(dataUrl)) imagePool.set(dataUrl, id);
        const m = /^pool-(\d+)$/.exec(id);
        if (m) {
          const n = Number(m[1]);
          if (Number.isFinite(n) && n > imagePoolCounter) imagePoolCounter = n;
        }
      });
    }

    function collectImageRefsForMarkup(markup) {
      if (!markup || !markup.includes("img-ref:")) return null;
      const ids = new Set();
      const regex = /img-ref:([A-Za-z0-9_-]+)/g;
      let m = regex.exec(markup);
      while (m) {
        ids.add(m[1]);
        m = regex.exec(markup);
      }
      if (!ids.size) return null;
      const refs = {};
      ids.forEach((id) => {
        const dataUrl = imagePoolRev.get(id);
        if (typeof dataUrl === "string" && dataUrl.startsWith("data:image/")) refs[id] = dataUrl;
      });
      return Object.keys(refs).length ? refs : null;
    }

    function applySnapshotMarkup(markup, imageRefs = null) {
      hydrateImageRefs(imageRefs);
      const resolved = restoreMarkupFromRefs(String(markup || ""));
      canvas.innerHTML = resolved;
      ensureArtboardLayer();
      updateArtboardVisual();
    }

    function isQuotaExceededError(err) {
      if (!err) return false;
      if (err.name === "QuotaExceededError") return true;
      if (err.code === 22 || err.code === 1014) return true;
      const msg = String(err.message || "");
      return msg.includes("exceeded the quota") || msg.includes("QuotaExceededError");
    }

    function isIndexedDbAvailable() {
      return typeof indexedDB !== "undefined" && indexedDB != null;
    }

    function idbRequestToPromise(request) {
      return new Promise((resolve, reject) => {
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error || new Error("IndexedDB request failed."));
      });
    }

    function idbTransactionToPromise(tx) {
      return new Promise((resolve, reject) => {
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error || new Error("IndexedDB transaction failed."));
        tx.onabort = () => reject(tx.error || new Error("IndexedDB transaction aborted."));
      });
    }

    function openAutosaveDb() {
      if (!isIndexedDbAvailable()) return Promise.reject(new Error("IndexedDB unavailable"));
      if (!autosaveDbPromise) {
        autosaveDbPromise = new Promise((resolve, reject) => {
          const req = indexedDB.open(AUTOSAVE_DB_NAME, AUTOSAVE_DB_VERSION);
          req.onupgradeneeded = () => {
            const db = req.result;
            if (!db.objectStoreNames.contains(AUTOSAVE_RECORDS_STORE)) {
              const store = db.createObjectStore(AUTOSAVE_RECORDS_STORE, { keyPath: "id" });
              store.createIndex("at", "at", { unique: false });
            } else {
              const store = req.transaction?.objectStore(AUTOSAVE_RECORDS_STORE);
              if (store && !store.indexNames.contains("at")) store.createIndex("at", "at", { unique: false });
            }
            if (!db.objectStoreNames.contains(AUTOSAVE_META_STORE)) {
              db.createObjectStore(AUTOSAVE_META_STORE, { keyPath: "key" });
            }
          };
          req.onsuccess = () => {
            const db = req.result;
            db.onversionchange = () => db.close();
            resolve(db);
          };
          req.onerror = () => {
            autosaveDbPromise = null;
            reject(req.error || new Error("Failed to open autosave IndexedDB."));
          };
          req.onblocked = () => {
            setStatus("Autosave DB upgrade blocked. Close other Figure Maker tabs.");
          };
        });
      }
      return autosaveDbPromise;
    }

    function cloneAutosaveRecord(record) {
      if (!record || typeof record !== "object") return null;
      const cloned = {
        id: String(record.id || `as-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`),
        at: Number(record.at || Date.now()),
        markup: String(record.markup || ""),
        selectedIds: Array.isArray(record.selectedIds) ? record.selectedIds.map((id) => String(id || "")) : [],
        canvasMeta: record.canvasMeta && typeof record.canvasMeta === "object" ? { ...record.canvasMeta } : null
      };
      if (!cloned.canvasMeta) return null;
      if (record.imageRefs && typeof record.imageRefs === "object") {
        const refs = {};
        Object.entries(record.imageRefs).forEach(([key, value]) => {
          if (!key || typeof key !== "string") return;
          if (!value || typeof value !== "string" || !value.startsWith("data:image/")) return;
          refs[key] = value;
        });
        if (Object.keys(refs).length) cloned.imageRefs = refs;
      }
      const snapBytes = Number(record.snapBytes);
      cloned.snapBytes = Number.isFinite(snapBytes) ? snapBytes : 0;
      const sizeBytes = Number(record.sizeBytes);
      cloned.sizeBytes = Number.isFinite(sizeBytes) ? sizeBytes : 0;
      if (!cloned.sizeBytes) cloned.sizeBytes = estimateAutosaveRecordBytes(cloned);
      return cloned;
    }

    function normalizeAutosaveRecords(records) {
      if (!Array.isArray(records)) return [];
      return records
        .map((record) => cloneAutosaveRecord(record))
        .filter((record) => !!record)
        .sort((a, b) => Number(a.at || 0) - Number(b.at || 0));
    }

    function estimateBytes(value) {
      if (value == null) return 0;
      if (typeof value !== "string") {
        try {
          value = JSON.stringify(value);
        } catch (_) {
          value = String(value);
        }
      }
      return Math.max(0, String(value).length * 2);
    }

    function estimateSnapshotBytes(snap) {
      if (!snap || typeof snap !== "object") return 0;
      return estimateBytes(snap.markup) + estimateBytes(snap.selectedIds) + estimateBytes(snap.canvasMeta) + 96;
    }

    function estimateAutosaveRecordBytes(rec) {
      if (!rec || typeof rec !== "object") return 0;
      return estimateBytes(rec.markup) + estimateBytes(rec.selectedIds) + estimateBytes(rec.canvasMeta) + estimateBytes(rec.imageRefs) + 128;
    }

    function collectRefIdsFromMarkup(markup, outSet) {
      const set = outSet instanceof Set ? outSet : new Set();
      const regex = /img-ref:([A-Za-z0-9_-]+)/g;
      const text = String(markup || "");
      let m = regex.exec(text);
      while (m) {
        set.add(m[1]);
        m = regex.exec(text);
      }
      return set;
    }

    function garbageCollectImagePool() {
      const used = new Set();
      collectRefIdsFromMarkup(canvas?.innerHTML || "", used);
      (state.history || []).forEach((snap) => collectRefIdsFromMarkup(snap?.markup || "", used));
      (state.future || []).forEach((snap) => collectRefIdsFromMarkup(snap?.markup || "", used));
      (state.clipboardItems || []).forEach((item) => collectRefIdsFromMarkup(item?.markup || "", used));
      Array.from(imagePoolRev.keys()).forEach((id) => {
        if (used.has(id)) return;
        const dataUrl = imagePoolRev.get(id);
        imagePoolRev.delete(id);
        if (dataUrl) imagePool.delete(dataUrl);
      });
    }

    function makeAutosaveRecord(prefix, reason) {
      const snap = getSnapshot(`${prefix}:${reason}`, { useRefs: true });
      if (!snap || typeof snap.markup !== "string") return null;
      const rec = {
        id: `${prefix}-${Date.now()}`,
        at: Number(snap.at || Date.now()),
        markup: snap.markup,
        selectedIds: Array.isArray(snap.selectedIds) ? [...snap.selectedIds] : [],
        canvasMeta: snap.canvasMeta,
        snapBytes: Number(snap.sizeBytes || 0)
      };
      const refs = collectImageRefsForMarkup(snap.markup);
      if (refs) rec.imageRefs = refs;
      rec.sizeBytes = estimateAutosaveRecordBytes(rec);
      return rec;
    }
    /* ---------------------------------------- */

    const state = {
      tool: "select",
      selectedIds: [],
      idCounter: 1,
      artboardViewBox: DEFAULT_ARTBOARD_VIEWBOX,
      history: [],
      future: [],
      maxHistory: MAX_HISTORY_ENTRIES_DEFAULT,
      interaction: null,
      autosaveTimer: null,
      liveAutosaveTimer: 0,
      contextGroupId: null,
      contextTargetId: null,
      alignBasis: "bbox",
      isExportingPdf: false,
      isPasting: false,
      pasteLockAt: 0,
      clipboardItems: [],
      lastPasteReport: null,
      pasteReportHistory: [],
      eventRing: [],
      eventRingMax: 100,
      lastErrorRecord: null,
      autosaveParseWarned: false,
      textEdit: null,
      selectionRefreshRaf: 0,
      pendingInternalPasteTimer: 0,
      lastExternalPasteAt: 0,
      activeMenu: "",
      markLabelComp: {},
      viewScale: 1,
      pinch: { active: false, startScale: 1, startDistance: 0 },
      spacePanActive: false,
      toolbarTab: "tool",
      cropMode: null,
      fileHandle: null,
      autosaveQuotaWarned: false,
      liveAutosaveQuotaWarned: false,
      historySizeWarned: false,
      autosaveSizeWarned: false,
      liveAutosaveSizeWarned: false,
      pasteNudgeCounter: 0,
      suppressContextMenuOnce: false,
      hoverRotateReady: false,
      statusMessage: "Ready."
    };

    function makeErrorId() {
      const d = new Date();
      const pad = (n) => String(n).padStart(2, "0");
      const ts = `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}-${pad(d.getHours())}${pad(d.getMinutes())}`;
      const rand = Math.floor(Math.random() * 0x10000).toString(16).padStart(4, "0");
      return `${ts}-${rand}`;
    }

    function pushEventRing(type, detail = {}) {
      const base = { at: new Date().toISOString(), type };
      const payload = DEBUG_MODE ? { ...base, detail } : base;
      state.eventRing.push(payload);
      if (state.eventRing.length > state.eventRingMax) state.eventRing.shift();
    }

    function formatErrorMessage(errLike) {
      if (errLike instanceof Error) return errLike.message || "Unknown error";
      if (typeof errLike === "string") return errLike;
      if (errLike && typeof errLike === "object" && "message" in errLike) return String(errLike.message || "Unknown error");
      return String(errLike || "Unknown error");
    }

    function captureError(kind, errLike, extra = {}) {
      const errorId = makeErrorId();
      const message = formatErrorMessage(errLike);
      const stack = errLike instanceof Error ? String(errLike.stack || "") : "";
      const record = {
        id: errorId,
        kind,
        message,
        stack,
        at: new Date().toISOString(),
        debug: DEBUG_MODE ? 1 : 0,
        url: window.location.href,
        userAgent: navigator.userAgent,
        extra: DEBUG_MODE ? extra : { userMessage: extra.userMessage || "" },
        eventHistory: [...state.eventRing]
      };
      state.lastErrorRecord = record;
      try {
        localStorage.setItem(LAST_ERROR_KEY, JSON.stringify(record));
      } catch (_) {}
      const consolePayload = DEBUG_MODE ? record : {
        id: record.id,
        kind: record.kind,
        message: record.message,
        at: record.at,
        userMessage: record.extra?.userMessage || ""
      };
      console.error("[FigureMakerError]", consolePayload);
      showErrorNotice(record);
      return record;
    }

    function showErrorNotice(record) {
      if (!record || !errorNoticeEl) return;
      errorNoticeTitleEl.textContent = `Error ID: ${record.id}`;
      const userMsg = record.extra?.userMessage || "Unexpected error occurred.";
      errorNoticeMetaEl.textContent = `${userMsg}`;
      errorNoticeEl.classList.add("show");
    }

    function dismissErrorNotice() {
      errorNoticeEl.classList.remove("show");
    }

    function downloadErrorLog() {
      const rec = state.lastErrorRecord;
      if (!rec) {
        setStatus("No error log available.");
        return;
      }
      const text = JSON.stringify(rec, null, 2);
      const blob = new Blob([text], { type: "application/json;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `error-${rec.id}.json`;
      a.click();
      setTimeout(() => URL.revokeObjectURL(url), 1500);
      setStatus(`Error log downloaded: ${rec.id}`);
    }

    function setupGlobalErrorHandlers() {
      window.onerror = (message, source, lineno, colno, error) => {
        captureError("window.onerror", error || String(message || "error"), {
          source: source || "",
          line: lineno || 0,
          col: colno || 0,
          userMessage: "Runtime error detected."
        });
      };
      window.onunhandledrejection = (ev) => {
        const reason = ev?.reason instanceof Error ? ev.reason : new Error(formatErrorMessage(ev?.reason));
        captureError("window.onunhandledrejection", reason, {
          userMessage: "Unhandled promise rejection detected."
        });
      };
    }

    function setupEventRingHooks() {
      document.addEventListener("click", (e) => {
        const t = e.target instanceof Element ? e.target.tagName : "";
        pushEventRing("click", { target: t });
      }, true);
      window.addEventListener("keydown", (e) => {
        pushEventRing("key", {
          key: e.key,
          ctrl: !!e.ctrlKey,
          shift: !!e.shiftKey,
          alt: !!e.altKey,
          meta: !!e.metaKey
        });
      }, true);
      window.addEventListener("hashchange", () => pushEventRing("route", { mode: "hashchange", href: location.href }));
      window.addEventListener("popstate", () => pushEventRing("route", { mode: "popstate", href: location.href }));
      const p = history.pushState.bind(history);
      history.pushState = (...args) => {
        const out = p(...args);
        pushEventRing("route", { mode: "pushState", href: location.href });
        return out;
      };
      const r = history.replaceState.bind(history);
      history.replaceState = (...args) => {
        const out = r(...args);
        pushEventRing("route", { mode: "replaceState", href: location.href });
        return out;
      };
    }

    function renderStatus() {
      const compact = window.innerWidth < 980;
      document.body.classList.toggle("compact", compact);
      const advancedBtn = document.getElementById("toggleAdvanced");
      if (!compact) {
        document.body.classList.remove("show-advanced");
      }
      if (advancedBtn) {
        const expanded = compact && document.body.classList.contains("show-advanced");
        advancedBtn.textContent = expanded ? "Less" : "More";
        advancedBtn.setAttribute("aria-expanded", expanded ? "true" : "false");
      }
      const effectiveTool = getEffectiveTool();
      const toolName = effectiveTool === "direct"
        ? "White Arrow"
        : (effectiveTool === "hand" ? "Hand" : "Black Arrow");
      const selectedCount = state.selectedIds.length;
      const histPos = Math.max(1, state.history.length - state.future.length);
      const histTotal = Math.max(1, state.history.length);
      const autosaveSel = document.getElementById("autosaveSelect");
      const autosave = autosaveSel ? autosaveSel.value : "off";
      const alignBase = state.alignBasis === "first" ? "first" : "bbox";
      const zoomPct = Math.round(state.viewScale * 100);
      
      const statusMsgEl = document.getElementById("statusMessage");
      if (statusMsgEl) {
        if (compact) {
          statusMsgEl.textContent = `${state.statusMessage} | ${toolName} | sel:${selectedCount} | z:${zoomPct}% | h:${histPos}/${histTotal}`;
        } else {
          statusMsgEl.textContent = `${state.statusMessage} | tool:${toolName} | sel:${selectedCount} | zoom:${zoomPct}% | hist:${histPos}/${histTotal} | autosave:${autosave} | align:${alignBase}`;
        }
      }
    }

    function setStatus(msg) {
      state.statusMessage = msg;
      renderStatus();
    }

    function createId() {
      const id = `obj-${state.idCounter++}`;
      return id;
    }

    function isHelperElement(el) {
      return !!el && (
        el.classList.contains("selection-outline") ||
        el.classList.contains("selection-handle") ||
        el.classList.contains("marquee") ||
        el.classList.contains("smart-guide") ||
        el.classList.contains("crop-boundary") ||
        el.classList.contains("crop-draft") ||
        el.classList.contains("crop-mask") ||
        el.classList.contains("crop-handle") ||
        el.classList.contains("fm-artboard-layer") ||
        el.classList.contains("fm-artboard-bg")
      );
    }

    function isGroupLabel(el) {
      return !!el && el instanceof SVGElement && el.getAttribute("data-fm-group-label") === "1";
    }

    function isFigureTitle(el) {
      return !!el && el instanceof SVGElement && (el.getAttribute("data-fm-figure-title") === "1" || el.classList.contains("fm-figure-title"));
    }

    function ensureId(el) {
      if (!el || !(el instanceof SVGElement)) return;
      if (el === canvas) return;
      if (isHelperElement(el)) return;
      const cur = String(el.dataset.id || "");
      if (!cur) {
        el.dataset.id = createId();
        return;
      }
      try {
        const first = canvas.querySelector(`[data-id="${CSS.escape(cur)}"]`);
        if (first && first !== el) {
          el.dataset.id = createId();
        }
      } catch (_) {
        const first = canvas.querySelector(`[data-id="${cur.replace(/\"/g, "\\\"")}"]`);
        if (first && first !== el) {
          el.dataset.id = createId();
        }
      }
    }

    function parseViewBoxString(raw, fallback = { minX: 0, minY: 0, width: 794, height: 1123 }) {
      const parts = String(raw || "").trim().split(/\s+/).map(Number);
      const minX = Number.isFinite(parts[0]) ? parts[0] : Number(fallback.minX || 0);
      const minY = Number.isFinite(parts[1]) ? parts[1] : Number(fallback.minY || 0);
      const width = Number.isFinite(parts[2]) && parts[2] > 0 ? parts[2] : Math.max(1, Number(fallback.width || 794));
      const height = Number.isFinite(parts[3]) && parts[3] > 0 ? parts[3] : Math.max(1, Number(fallback.height || 1123));
      return { minX, minY, width, height };
    }

    function formatViewBoxString(box) {
      const minX = Number(box?.minX || 0);
      const minY = Number(box?.minY || 0);
      const width = Math.max(1, Number(box?.width || 794));
      const height = Math.max(1, Number(box?.height || 1123));
      return `${Number(minX.toFixed(4))} ${Number(minY.toFixed(4))} ${Number(width.toFixed(4))} ${Number(height.toFixed(4))}`;
    }

    function centeredArtboardBox(width, height) {
      const w = Math.max(1, Number(width || 794));
      const h = Math.max(1, Number(height || 1123));
      return {
        minX: (WORKSPACE_SIZE - w) / 2,
        minY: (WORKSPACE_SIZE - h) / 2,
        width: w,
        height: h
      };
    }

    function normalizeArtboardBox(raw, options = {}) {
      const parsed = parseViewBoxString(raw, parseViewBoxString(DEFAULT_VIEWBOX));
      const isLegacyOrigin = Math.abs(parsed.minX) < 1e-6 && Math.abs(parsed.minY) < 1e-6;
      let box = parsed;
      if (options.centerIfLegacy !== false && isLegacyOrigin) {
        box = centeredArtboardBox(parsed.width, parsed.height);
      }
      if (box.width > WORKSPACE_SIZE) box.width = WORKSPACE_SIZE;
      if (box.height > WORKSPACE_SIZE) box.height = WORKSPACE_SIZE;
      box.minX = Math.max(0, Math.min(WORKSPACE_SIZE - box.width, box.minX));
      box.minY = Math.max(0, Math.min(WORKSPACE_SIZE - box.height, box.minY));
      return box;
    }

    function getWorkspaceDimensions() {
      return parseViewBoxString(canvas.getAttribute("viewBox") || WORKSPACE_VIEWBOX, {
        minX: 0,
        minY: 0,
        width: WORKSPACE_SIZE,
        height: WORKSPACE_SIZE
      });
    }

    function applyPointerEventPolicy(el) {
      if (!(el instanceof SVGElement) || el === canvas) return;
      try {
        el.removeAttribute("pointer-events");
        el.style.removeProperty("pointer-events");
      } catch (_) {}
      // Keep pointer-event policy separate from visual stroke policy.
      // (non-scaling-stroke caused zoom rendering artifacts)
      el.removeAttribute("vector-effect");
      el.style.removeProperty("vector-effect");
      if (el.tagName === "line" || el.tagName === "polyline") {
        el.setAttribute("pointer-events", "stroke");
        el.style.setProperty("pointer-events", "stroke", "important");
        return;
      }
      if (el.tagName === "path" || el.tagName === "text" || el.tagName === "tspan" || el.tagName === "rect" || el.tagName === "ellipse" || el.tagName === "circle" || el.tagName === "polygon") {
        el.setAttribute("pointer-events", "visiblePainted");
        el.style.setProperty("pointer-events", "visiblePainted", "important");
        return;
      }
      if (el.tagName === "g") {
        el.setAttribute("pointer-events", "visiblePainted");
        el.style.setProperty("pointer-events", "visiblePainted", "important");
        return;
      }
      if (el.tagName !== "g") {
        el.setAttribute("pointer-events", "visiblePainted");
        el.style.setProperty("pointer-events", "visiblePainted", "important");
      }
    }

    function sanitizeSvgAttributes(el) {
      if (!(el instanceof SVGElement)) return;
      for (const attr of Array.from(el.attributes)) {
        const name = attr.name.toLowerCase();
        const value = String(attr.value || "");
        if (name === "data-id" || name === "data-tx" || name === "data-ty" || name === "data-base-transform") {
          el.removeAttribute(attr.name);
          continue;
        }
        if (name.startsWith("on")) el.removeAttribute(attr.name);
        if ((name === "href" || name.endsWith(":href")) && value.trim().toLowerCase().startsWith("javascript:")) {
          el.removeAttribute(attr.name);
        }
      }
    }

    function sanitizeSvgTree(root) {
      if (!(root instanceof SVGElement)) return;
      root.querySelectorAll("script,foreignObject,iframe,object,embed").forEach((el) => el.remove());
      sanitizeSvgAttributes(root);
      const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
      while (walker.nextNode()) {
        const el = walker.currentNode;
        if (!(el instanceof SVGElement)) continue;
        sanitizeSvgAttributes(el);
        applyPointerEventPolicy(el);
      }
      applyPointerEventPolicy(root);
    }

    function assignIds(root = canvas) {
      const used = new Set();
      const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
      let maxNum = state.idCounter;
      while (walker.nextNode()) {
        const el = walker.currentNode;
        if (!(el instanceof SVGElement)) continue;
        if (isHelperElement(el)) continue;
        const existingId = String(el.dataset.id || "");
        if (existingId && used.has(existingId)) {
          el.dataset.id = "";
        }
        ensureId(el);
        if (el.dataset.id) used.add(el.dataset.id);
        applyPointerEventPolicy(el);
        ensureTransformState(el);
        if (el.dataset.id && /^obj-(\d+)$/.test(el.dataset.id)) {
          const n = Number(el.dataset.id.replace("obj-", ""));
          if (n >= maxNum) maxNum = n + 1;
        }
      }
      state.idCounter = maxNum;
    }

    function isEditableElement(el) {
      if (!(el instanceof SVGElement)) return false;
      if (el === canvas) return false;
      if (isHelperElement(el)) return false;
      if (isGroupLabel(el)) return true;
      if (el.closest("defs,clipPath,mask,marker,symbol,pattern,metadata")) return false;
      const display = String(el.getAttribute("display") || "").trim().toLowerCase();
      const visibility = String(el.getAttribute("visibility") || "").trim().toLowerCase();
      if (display === "none" || visibility === "hidden") return false;
      const supported = ["rect", "line", "ellipse", "circle", "text", "path", "polygon", "polyline", "image", "g", "use", "foreignObject"];
      if (!supported.includes(el.tagName)) return false;
      if (el.tagName === "g") return true;
      if (el.tagName === "image" || el.tagName === "text" || el.tagName === "use" || el.tagName === "foreignObject") return true;
      const cs = window.getComputedStyle ? window.getComputedStyle(el) : null;
      const fillRaw = String(el.getAttribute("fill") || cs?.fill || "").trim().toLowerCase();
      const strokeRaw = String(el.getAttribute("stroke") || cs?.stroke || "").trim().toLowerCase();
      const transparentLike = (v) => v === "none" || v === "transparent" || /rgba\([^)]*,\s*0(?:\.0+)?\s*\)/.test(v);
      const hasFill = fillRaw ? !transparentLike(fillRaw) : true;
      const hasStroke = strokeRaw ? !transparentLike(strokeRaw) : false;
      if (el.tagName === "line" || el.tagName === "polyline") return hasStroke;
      return hasFill || hasStroke;
    }

    function getById(id) {
      return canvas.querySelector(`[data-id="${CSS.escape(id)}"]`);
    }

    function ensureTransformState(el) {
      if (!(el instanceof SVGElement) || el === canvas) return;
      const hasState = el.dataset.tx !== undefined && el.dataset.ty !== undefined && el.dataset.baseTransform !== undefined;
      if (hasState) return;
      const raw = String(el.getAttribute("transform") || "").trim();
      const m = raw.match(/^translate\(\s*([-+]?\d*\.?\d+(?:e[-+]?\d+)?)(?:[\s,]+([-+]?\d*\.?\d+(?:e[-+]?\d+)?))?\s*\)$/i);
      if (m) {
        const parent = el.parentNode instanceof SVGElement ? el.parentNode : canvas;
        const fromLocal = fromParentLocalDelta(parent, Number(m[1] || 0), Number(m[2] || 0));
        el.dataset.baseTransform = "";
        el.dataset.tx = String(Number(fromLocal.dx || 0));
        el.dataset.ty = String(Number(fromLocal.dy || 0));
      } else {
        el.dataset.baseTransform = raw;
        el.dataset.tx = String(Number(el.dataset.tx || 0));
        el.dataset.ty = String(Number(el.dataset.ty || 0));
      }
      setTranslate(el, Number(el.dataset.tx || 0), Number(el.dataset.ty || 0));
    }

    function getTranslate(el) {
      ensureTransformState(el);
      const x = Number(el.dataset.tx || 0);
      const y = Number(el.dataset.ty || 0);
      return { x, y };
    }

    function setTranslate(el, x, y) {
      if (!(el instanceof SVGElement) || el === canvas) return;
      const nx = Number.isFinite(x) ? x : 0;
      const ny = Number.isFinite(y) ? y : 0;
      const base = el.dataset.baseTransform !== undefined ? el.dataset.baseTransform : String(el.getAttribute("transform") || "").trim();
      const parent = el.parentNode instanceof SVGElement ? el.parentNode : canvas;
      const local = toParentLocalDelta(parent, nx, ny);
      const lx = Number(local.dx || 0);
      const ly = Number(local.dy || 0);
      el.dataset.baseTransform = base;
      el.dataset.tx = String(nx);
      el.dataset.ty = String(ny);
      if (base) {
        if (Math.abs(lx) < 1e-9 && Math.abs(ly) < 1e-9) el.setAttribute("transform", base);
        else el.setAttribute("transform", `translate(${lx},${ly}) ${base}`);
      } else {
        if (Math.abs(lx) < 1e-9 && Math.abs(ly) < 1e-9) el.removeAttribute("transform");
        else el.setAttribute("transform", `translate(${lx},${ly})`);
      }
    }

    function applySelectionStyles() {
      canvas.querySelectorAll(".fm-selected").forEach((el) => el.classList.remove("fm-selected"));
      canvas.querySelectorAll(".fm-group-selected").forEach((el) => el.classList.remove("fm-group-selected"));
      refreshAllGroupLabels();
      renderSelectionOutlines();
    }

    function requestSelectionVisualRefresh() {
      if (state.interaction && (state.interaction.type === "drag" || state.interaction.type === "resize" || state.interaction.type === "rotate")) {
        refreshAllGroupLabels();
        renderSelectionOutlines();
        return;
      }
      if (state.selectionRefreshRaf) return;
      state.selectionRefreshRaf = requestAnimationFrame(() => {
        state.selectionRefreshRaf = 0;
        refreshAllGroupLabels();
        renderSelectionOutlines();
      });
    }

    function renderSelectionOutlines() {
      canvas.querySelectorAll(".selection-outline,.selection-handle").forEach((el) => el.remove());
      const elements = getTopSelectedElements();
      const displayScale = getCanvasDisplayScale();
      const outlineStroke = Math.max(0.7, 1.5 / Math.max(displayScale, 1e-6));
      elements.forEach((el) => {
        if (el.tagName === "line") return;
        const b = getSelectionRenderBox(el) || safeBBox(el);
        if (!b || b.width <= 0 || b.height <= 0) return;
        const rect = document.createElementNS(SVG_NS, "rect");
        rect.setAttribute("class", "selection-outline");
        rect.setAttribute("stroke-width", String(outlineStroke));
        rect.setAttribute("x", String(b.x));
        rect.setAttribute("y", String(b.y));
        rect.setAttribute("width", String(b.width));
        rect.setAttribute("height", String(b.height));
        canvas.appendChild(rect);
      });
      renderResizeHandles(elements, displayScale);
    }

    function clearSmartGuides() {
      canvas.querySelectorAll(".smart-guide").forEach((el) => el.remove());
    }

    function drawSmartGuides(guides) {
      clearSmartGuides();
      if (!guides) return;
      const { minX, minY, width, height } = getWorkspaceDimensions();
      if (Number.isFinite(guides.x)) {
        const v = document.createElementNS(SVG_NS, "line");
        v.setAttribute("class", "smart-guide");
        v.setAttribute("x1", String(guides.x));
        v.setAttribute("y1", String(minY));
        v.setAttribute("x2", String(guides.x));
        v.setAttribute("y2", String(minY + height));
        canvas.appendChild(v);
      }
      if (Number.isFinite(guides.y)) {
        const h = document.createElementNS(SVG_NS, "line");
        h.setAttribute("class", "smart-guide");
        h.setAttribute("x1", String(minX));
        h.setAttribute("y1", String(guides.y));
        h.setAttribute("x2", String(minX + width));
        h.setAttribute("y2", String(guides.y));
        canvas.appendChild(h);
      }
    }

    function getSelectionRenderBox(el) {
      const it = state.interaction;
      if (!it || it.type !== "resize" || !it.liveBox) return null;
      if (!el || !el.dataset || el.dataset.id !== it.targetId) return null;
      return it.liveBox;
    }

    function isResizableElement(el) {
      if (!el) return false;
      if (isGroupLabel(el)) return false;
      return ["rect", "ellipse", "circle", "image", "line", "text", "polygon", "polyline", "path", "g"].includes(el.tagName);
    }

    function parseSvgPoints(pointsRaw) {
      const nums = String(pointsRaw || "").match(/[-+]?\d*\.?\d+(?:e[-+]?\d+)?/ig) || [];
      const out = [];
      for (let i = 0; i + 1 < nums.length; i += 2) {
        const x = Number(nums[i]);
        const y = Number(nums[i + 1]);
        if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
        out.push({ x, y });
      }
      return out;
    }

    function formatSvgPoints(points) {
      return (Array.isArray(points) ? points : [])
        .map((p) => `${Number((Number(p.x) || 0).toFixed(4))},${Number((Number(p.y) || 0).toFixed(4))}`)
        .join(" ");
    }

    function elementPointToCanvas(el, x, y) {
      if (!(el instanceof SVGElement)) return { x, y };
      const elCTM = el.getScreenCTM ? el.getScreenCTM() : null;
      const canvasCTM = canvas.getScreenCTM ? canvas.getScreenCTM() : null;
      if (!elCTM || !canvasCTM) return { x, y };
      try {
        const p = canvas.createSVGPoint();
        p.x = Number(x || 0);
        p.y = Number(y || 0);
        const toScreen = p.matrixTransform(elCTM);
        const toCanvas = toScreen.matrixTransform(canvasCTM.inverse());
        return { x: toCanvas.x, y: toCanvas.y };
      } catch (_) {
        return { x, y };
      }
    }

    function getCustomResizeHandles(target) {
      if (!(target instanceof SVGElement)) return [];
      if (target.tagName === "line") {
        const x1 = Number(target.getAttribute("x1") || 0);
        const y1 = Number(target.getAttribute("y1") || 0);
        const x2 = Number(target.getAttribute("x2") || 0);
        const y2 = Number(target.getAttribute("y2") || 0);
        const p1 = elementPointToCanvas(target, x1, y1);
        const p2 = elementPointToCanvas(target, x2, y2);
        return [
          { name: "line-start", x: p1.x, y: p1.y },
          { name: "line-end", x: p2.x, y: p2.y }
        ];
      }
      if (target.tagName === "polygon") {
        const pts = parseSvgPoints(target.getAttribute("points"));
        if (pts.length === 3) {
          return pts.map((p, idx) => {
            const cp = elementPointToCanvas(target, p.x, p.y);
            return { name: `vertex-${idx}`, x: cp.x, y: cp.y };
          });
        }
      }
      return [];
    }

    function renderResizeHandles(elements, precomputedScale = null) {
      if (elements.length !== 1) return;
      const target = elements[0];
      if (!isResizableElement(target)) return;
      const b = getSelectionRenderBox(target) || safeBBox(target);
      if (!b) return;
      const displayScale = precomputedScale || getCanvasDisplayScale();
      const size = 10 / Math.max(displayScale, 1e-6);
      const stroke = Math.max(0.7, 1.5 / Math.max(displayScale, 1e-6));
      const r = size / 2;
      const customHandles = getCustomResizeHandles(target);
      if (customHandles.length) {
        customHandles.forEach((c) => {
          const h = document.createElementNS(SVG_NS, "circle");
          h.setAttribute("class", "selection-handle");
          h.setAttribute("cx", String(c.x));
          h.setAttribute("cy", String(c.y));
          h.setAttribute("r", String(r));
          h.setAttribute("stroke-width", String(stroke));
          h.dataset.handle = c.name;
          h.dataset.targetId = target.dataset.id;
          canvas.appendChild(h);
        });
        return;
      }
      const corners = [
        { name: "nw", x: b.x, y: b.y },
        { name: "ne", x: b.x + b.width, y: b.y },
        { name: "sw", x: b.x, y: b.y + b.height },
        { name: "se", x: b.x + b.width, y: b.y + b.height }
      ];
      corners.forEach((c) => {
        const h = document.createElementNS(SVG_NS, "circle");
        h.setAttribute("class", "selection-handle");
        h.setAttribute("cx", String(c.x));
        h.setAttribute("cy", String(c.y));
        h.setAttribute("r", String(r));
        h.setAttribute("stroke-width", String(stroke));
        h.dataset.handle = c.name;
        h.dataset.targetId = target.dataset.id;
        canvas.appendChild(h);
      });
    }

    function setSelection(ids) {
      state.selectedIds = [...new Set(ids)].filter((id) => {
        const el = getById(id);
        return !!el && isEditableElement(el);
      });
      state.hoverRotateReady = false;
      applySelectionStyles();
      syncArrowControlsFromSelection();
      syncLineStrokeWidthControlFromSelection();
      syncMarkControlsFromSelection();
      syncTextControlsFromSelection();
      syncObjectColorControlsFromSelection();
      if (state.cropMode && !state.selectedIds.includes(state.cropMode.targetId)) {
        cancelImageCropMode({ silent: true });
      }
      updateToolCursor();
      setStatus(state.selectedIds.length ? `Selected: ${state.selectedIds.length}` : "Ready.");
    }

    function toggleSelection(id) {
      if (!id) return;
      if (state.selectedIds.includes(id)) {
        setSelection(state.selectedIds.filter((s) => s !== id));
      } else {
        setSelection([...state.selectedIds, id]);
      }
    }

    function clearSelection() {
      clearSmartGuides();
      setSelection([]);
    }

    function focusPasteSink() {
      if (state.textEdit) return;
      if (!(pasteSinkEl instanceof HTMLTextAreaElement)) return;
      try {
        pasteSinkEl.focus({ preventScroll: true });
      } catch (_) {}
    }

    function isTypingContextElement(el) {
      if (!el) return false;
      if (el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement || el instanceof HTMLSelectElement) return true;
      if (el instanceof HTMLElement && el.isContentEditable) return true;
      return false;
    }

    function closestEditableTarget(node) {
      let cur = node;
      while (cur && cur !== canvas) {
        if (isEditableElement(cur) && cur.dataset.id) return cur;
        cur = cur.parentNode;
      }
      return null;
    }

    function resolveOuterGroup(el) {
      let cur = el;
      let outer = null;
      while (cur && cur !== canvas) {
        if (cur.tagName === "g") outer = cur;
        cur = cur.parentNode;
      }
      return outer || el;
    }

    function resolveDirectTextLikeTarget(el) {
      if (!(el instanceof SVGElement)) return el;
      if (el.tagName === "text") return el;
      if (el.tagName === "tspan") {
        const t = el.closest("text");
        if (t instanceof SVGElement) return t;
      }
      let cur = el;
      while (cur && cur !== canvas) {
        if (!(cur instanceof SVGElement)) break;
        if (cur.tagName === "text") return cur;
        if (cur.tagName === "tspan") {
          const t = cur.closest("text");
          if (t instanceof SVGElement) return t;
        }
        cur = cur.parentNode;
      }
      return el;
    }

    function resolveTargetByTool(raw) {
      if (!raw) return null;
      const tool = getEffectiveTool();
      return (tool === "select" || tool === "hand") ? resolveOuterGroup(raw) : resolveDirectTextLikeTarget(raw);
    }

    function isTextLikeElement(el) {
      if (!(el instanceof SVGElement)) return false;
      return el.tagName === "text" || el.tagName === "tspan" || el.tagName === "use" || el.tagName === "foreignObject";
    }

    function hasLabelHint(el, depth = 4) {
      let cur = el;
      let n = 0;
      while (cur && cur !== canvas && n <= depth) {
        if (cur instanceof SVGElement) {
          const id = String(cur.getAttribute("id") || "");
          const cls = String(cur.getAttribute("class") || "");
          if (/(text|label|tick|axis|title|xlabel|ylabel|legend)/i.test(`${id} ${cls}`)) return true;
        }
        cur = cur.parentNode;
        n += 1;
      }
      return false;
    }

    function isLabelLikePath(el) {
      if (!(el instanceof SVGElement) || el.tagName !== "path") return false;
      if (hasLabelHint(el, 5)) return true;
      const fill = String(el.getAttribute("fill") || "").toLowerCase();
      const stroke = String(el.getAttribute("stroke") || "").toLowerCase();
      const hasFill = !!fill && fill !== "none";
      const noStroke = !stroke || stroke === "none";
      const b = safeBBox(el);
      if (!b) return false;
      return hasFill && noStroke && b.width <= 220 && b.height <= 90 && (b.width * b.height) <= 12000;
    }

    function isLabelLikeSelectable(el) {
      if (!(el instanceof SVGElement)) return false;
      if (isTextLikeElement(el)) return true;
      return isLabelLikePath(el);
    }

    function findNearestLabelLikeTargetByPoint(pt, maxDist = 44) {
      const all = Array.from(canvas.querySelectorAll("[data-id]"))
        .filter((n) => n instanceof SVGElement)
        .filter((n) => isEditableElement(n))
        .filter((n) => isLabelLikeSelectable(n));
      const cand = [];
      all.forEach((el) => {
        const b = safeBBox(el);
        if (!b) return;
        const dist = rectDistanceToPoint(pt, b);
        if (!Number.isFinite(dist) || dist > maxDist) return;
        cand.push({ el, dist, area: Math.max(1, b.width * b.height) });
      });
      if (!cand.length) return null;
      cand.sort((a, b) => {
        if (a.dist !== b.dist) return a.dist - b.dist;
        return a.area - b.area;
      });
      return cand[0];
    }

    function findEditableTargetByBBoxPoint(pt, preferTextLike = false) {
      const all = Array.from(canvas.querySelectorAll("[data-id]"))
        .filter((n) => n instanceof SVGElement)
        .filter((n) => isEditableElement(n));
      const hit = [];
      all.forEach((el) => {
        const b = safeBBox(el);
        if (!b) return;
        const pad = isTextLikeElement(el) ? 5 : 2;
        const inside = pt.x >= b.x - pad && pt.x <= b.x + b.width + pad && pt.y >= b.y - pad && pt.y <= b.y + b.height + pad;
        if (!inside) return;
        const area = Math.max(1, b.width * b.height);
        hit.push({ el, area, textLike: isTextLikeElement(el) ? 0 : 1 });
      });
      if (!hit.length) return null;
      hit.sort((a, b) => {
        if (preferTextLike && a.textLike !== b.textLike) return a.textLike - b.textLike;
        return a.area - b.area;
      });
      return hit[0].el || null;
    }

    function rectDistanceToPoint(pt, b) {
      const dx = Math.max(b.x - pt.x, 0, pt.x - (b.x + b.width));
      const dy = Math.max(b.y - pt.y, 0, pt.y - (b.y + b.height));
      return Math.hypot(dx, dy);
    }

    function findNearestEditableTargetByPoint(pt, preferTextLike = false, maxDist = 24, textOnly = false) {
      const all = Array.from(canvas.querySelectorAll("[data-id]"))
        .filter((n) => n instanceof SVGElement)
        .filter((n) => isEditableElement(n));
      const cand = [];
      all.forEach((el) => {
        if (textOnly && !isTextLikeElement(el)) return;
        const b = safeBBox(el);
        if (!b) return;
        const dist = rectDistanceToPoint(pt, b);
        if (!Number.isFinite(dist) || dist > maxDist) return;
        cand.push({
          el,
          dist,
          textLike: isTextLikeElement(el) ? 0 : 1,
          area: Math.max(1, b.width * b.height)
        });
      });
      if (!cand.length) return null;
      cand.sort((a, b) => {
        if (preferTextLike && a.textLike !== b.textLike) return a.textLike - b.textLike;
        if (a.dist !== b.dist) return a.dist - b.dist;
        return a.area - b.area;
      });
      return cand[0].el || null;
    }

    function getEditableTargetsAtPoint(clientX, clientY) {
      const stack = [];
      const seen = new Set();
      const els = document.elementsFromPoint(clientX, clientY);
      els.forEach((node) => {
        if (!(node instanceof SVGElement)) return;
        const target = closestEditableTarget(node);
        if (!target || !target.dataset.id) return;
        if (!canvas.contains(target)) return;
        if (seen.has(target.dataset.id)) return;
        seen.add(target.dataset.id);
        stack.push(target);
      });
      return stack;
    }

    function pickDirectTargetFromStack(stack) {
      if (!stack.length) return null;
      const normalized = [];
      const seen = new Set();
      stack.forEach((el) => {
        const n = resolveDirectTextLikeTarget(el);
        if (!n || !n.dataset?.id) return;
        if (seen.has(n.dataset.id)) return;
        seen.add(n.dataset.id);
        normalized.push(n);
      });
      if (!normalized.length) return null;
      const textFirst = normalized.find((el) => el.tagName === "text");
      if (textFirst) return textFirst;
      const nonGroup = normalized.find((el) => el.tagName !== "g");
      return nonGroup || normalized[0];
    }

    function getSvgPoint(clientX, clientY) {
      const pt = canvas.createSVGPoint();
      pt.x = clientX;
      pt.y = clientY;
      const matrix = canvas.getScreenCTM();
      return matrix ? pt.matrixTransform(matrix.inverse()) : { x: 0, y: 0 };
    }

    function intersects(a, b) {
      return a.x <= b.x + b.width && a.x + a.width >= b.x && a.y <= b.y + b.height && a.y + a.height >= b.y;
    }

    function safeBBox(el) {
      try {
        if (el.tagName === "g") {
          const childBoxes = getGroupContentBoxes(el);
          if (childBoxes.length) {
            const minX = Math.min(...childBoxes.map((b) => b.x));
            const minY = Math.min(...childBoxes.map((b) => b.y));
            const maxX = Math.max(...childBoxes.map((b) => b.x + b.width));
            const maxY = Math.max(...childBoxes.map((b) => b.y + b.height));
            return { x: minX, y: minY, width: Math.max(1, maxX - minX), height: Math.max(1, maxY - minY) };
          }
        }
        const local = el.getBBox();
        const elScreen = el.getScreenCTM ? el.getScreenCTM() : null;
        const canvasScreen = canvas.getScreenCTM ? canvas.getScreenCTM() : null;
        let invCanvas = null;
        if (canvasScreen) {
          try {
            invCanvas = canvasScreen.inverse();
          } catch (_) {
            invCanvas = null;
          }
        }
        if (elScreen && invCanvas) {
          const corners = [
            { x: local.x, y: local.y },
            { x: local.x + local.width, y: local.y },
            { x: local.x, y: local.y + local.height },
            { x: local.x + local.width, y: local.y + local.height }
          ];
          const mapped = corners.map((c) => {
            const p = canvas.createSVGPoint();
            p.x = c.x;
            p.y = c.y;
            return p.matrixTransform(elScreen).matrixTransform(invCanvas);
          });
          const minX = Math.min(...mapped.map((p) => p.x));
          const minY = Math.min(...mapped.map((p) => p.y));
          const maxX = Math.max(...mapped.map((p) => p.x));
          const maxY = Math.max(...mapped.map((p) => p.y));
          return {
            x: minX,
            y: minY,
            width: Math.max(1, maxX - minX),
            height: Math.max(1, maxY - minY)
          };
        }
        if (el.isConnected && typeof el.getBoundingClientRect === "function") {
          const er = el.getBoundingClientRect();
          const cr = canvas.getBoundingClientRect();
          if (cr.width > 0 && cr.height > 0) {
            const vb = (canvas.getAttribute("viewBox") || DEFAULT_VIEWBOX).split(/\s+/).map(Number);
            const minX = Number.isFinite(vb[0]) ? vb[0] : 0;
            const minY = Number.isFinite(vb[1]) ? vb[1] : 0;
            const vw = vb[2] || 1200;
            const vh = vb[3] || 700;
            const sx = vw / cr.width;
            const sy = vh / cr.height;
            return {
              x: minX + (er.left - cr.left) * sx,
              y: minY + (er.top - cr.top) * sy,
              width: er.width * sx,
              height: er.height * sy
            };
          }
        }
        const b = el.getBBox();
        const t = getTranslate(el);
        return { x: b.x + t.x, y: b.y + t.y, width: b.width, height: b.height };
      } catch (_) {
        return null;
      }
    }

    function getGroupContentBoxes(groupEl) {
      if (!(groupEl instanceof SVGElement) || groupEl.tagName !== "g") return [];
      return Array.from(groupEl.children)
        .filter((child) => child instanceof SVGElement && !isGroupLabel(child) && !isHelperElement(child))
        .map((child) => safeBBox(child))
        .filter(Boolean);
    }

    function getGroupContentBBox(groupEl) {
      const boxes = getGroupContentBoxes(groupEl);
      if (!boxes.length) return null;
      const minX = Math.min(...boxes.map((b) => b.x));
      const minY = Math.min(...boxes.map((b) => b.y));
      const maxX = Math.max(...boxes.map((b) => b.x + b.width));
      const maxY = Math.max(...boxes.map((b) => b.y + b.height));
      return { x: minX, y: minY, width: Math.max(1, maxX - minX), height: Math.max(1, maxY - minY) };
    }

    function applyMarkLabelCompensation(labelEl) {
      if (!(labelEl instanceof SVGElement) || !isGroupLabel(labelEl) || !labelEl.dataset?.id) return;
      const comp = state.markLabelComp[labelEl.dataset.id];
      if (!comp) return;
      const a = Number(comp.a);
      const b = Number(comp.b);
      const c = Number(comp.c);
      const d = Number(comp.d);
      const hasMatrix = Number.isFinite(a) && Number.isFinite(b) && Number.isFinite(c) && Number.isFinite(d);
      if (!hasMatrix) {
        const invX = Number(comp.invX || 0);
        const invY = Number(comp.invY || 0);
        if (!Number.isFinite(invX) || !Number.isFinite(invY) || invX <= 0 || invY <= 0) return;
        const x = Number(labelEl.getAttribute("x") || 0);
        const y = Number(labelEl.getAttribute("y") || 0);
        const baseLegacy = String(comp.baseTransform || "").trim();
        const headLegacy = `translate(${Number(x.toFixed(4))},${Number(y.toFixed(4))}) scale(${Number(invX.toFixed(6))},${Number(invY.toFixed(6))}) translate(${-Number(x.toFixed(4))},${-Number(y.toFixed(4))})`;
        labelEl.setAttribute("transform", `${headLegacy}${baseLegacy ? ` ${baseLegacy}` : ""}`.trim());
        return;
      }
      const x = Number(labelEl.getAttribute("x") || 0);
      const y = Number(labelEl.getAttribute("y") || 0);
      const base = String(comp.baseTransform || "").trim();
      const head = `translate(${Number(x.toFixed(4))},${Number(y.toFixed(4))}) matrix(${Number(a.toFixed(8))} ${Number(b.toFixed(8))} ${Number(c.toFixed(8))} ${Number(d.toFixed(8))} 0 0) translate(${-Number(x.toFixed(4))},${-Number(y.toFixed(4))})`;
      labelEl.setAttribute("transform", `${head}${base ? ` ${base}` : ""}`.trim());
    }

    function getElementLinearMatrix(el) {
      if (!(el instanceof SVGElement)) return { a: 1, b: 0, c: 0, d: 1 };
      const m = el.getCTM ? el.getCTM() : null;
      if (!m) return { a: 1, b: 0, c: 0, d: 1 };
      const a = Number(m.a);
      const b = Number(m.b);
      const c = Number(m.c);
      const d = Number(m.d);
      if (!Number.isFinite(a) || !Number.isFinite(b) || !Number.isFinite(c) || !Number.isFinite(d)) {
        return { a: 1, b: 0, c: 0, d: 1 };
      }
      return { a, b, c, d };
    }

    function invertLinearMatrix(m) {
      const a = Number(m?.a);
      const b = Number(m?.b);
      const c = Number(m?.c);
      const d = Number(m?.d);
      const det = a * d - b * c;
      if (!Number.isFinite(det) || Math.abs(det) < 1e-12) return null;
      return { a: d / det, b: -b / det, c: -c / det, d: a / det };
    }

    function multiplyLinearMatrix(l, r) {
      return {
        a: l.a * r.a + l.c * r.b,
        b: l.b * r.a + l.d * r.b,
        c: l.a * r.c + l.c * r.d,
        d: l.b * r.c + l.d * r.d
      };
    }

    function getMarkTargetBox(targetEl) {
      if (!(targetEl instanceof SVGElement)) return null;
      if (targetEl.tagName === "g") return getGroupContentBBox(targetEl) || safeBBox(targetEl);
      return safeBBox(targetEl);
    }

    function positionMarkLabelForTarget(targetEl, labelEl) {
      if (!(targetEl instanceof SVGElement) || !(labelEl instanceof SVGElement)) return false;
      const b = getMarkTargetBox(targetEl);
      if (!b) return false;
      const x = Number((b.x - 5).toFixed(4));
      const y = Number((b.y - 5).toFixed(4));
      labelEl.setAttribute("x", String(x));
      labelEl.setAttribute("y", String(y));
      labelEl.dataset.baseTransform = "";
      labelEl.dataset.tx = "0";
      labelEl.dataset.ty = "0";
      labelEl.removeAttribute("transform");
      const baseSize = Number(labelEl.dataset.markBaseSize || labelEl.getAttribute("font-size") || "");
      if (Number.isFinite(baseSize) && baseSize > 0) {
        const locked = Math.max(6, Math.round(baseSize));
        labelEl.dataset.markBaseSize = String(locked);
        labelEl.setAttribute("font-size", String(locked));
        labelEl.style.setProperty("font-size", `${locked}px`);
      }
      return true;
    }

    function refreshAllGroupLabels() {
      const labels = Array.from(canvas.querySelectorAll('[data-fm-group-label="1"], .fm-group-label'))
        .filter((n) => n instanceof SVGElement);
      labels.forEach((label) => {
        const linkedIdRaw = String(label.getAttribute("data-fm-mark-target-id") || "").trim();
        let target = linkedIdRaw ? getById(linkedIdRaw) : null;
        if (!(target instanceof SVGElement) || !isEditableElement(target) || target === label) {
          const parent = label.parentNode instanceof SVGElement ? label.parentNode : null;
          if (parent && parent.tagName === "g" && parent !== canvas && parent.dataset?.id) {
            target = parent;
            label.setAttribute("data-fm-mark-target-id", parent.dataset.id);
          }
        }
        if (!(target instanceof SVGElement) || !target.dataset?.id) {
          if (label.dataset?.id) delete state.markLabelComp[label.dataset.id];
          label.remove();
          return;
        }
        if (label.parentNode !== canvas) canvas.appendChild(label);
        positionMarkLabelForTarget(target, label);
        if (label.dataset?.id) delete state.markLabelComp[label.dataset.id];
      });
    }

    function getTopSelectedElements() {
      const selected = state.selectedIds.map(getById).filter((el) => !!el && isEditableElement(el));
      return selected.filter((el) => !selected.some((other) => other !== el && other.contains(el)));
    }

    function createShape(tag, attrs, text) {
      const el = document.createElementNS(SVG_NS, tag);
      Object.entries(attrs || {}).forEach(([k, v]) => el.setAttribute(k, String(v)));
      if (text) el.textContent = text;
      ensureId(el);
      applyPointerEventPolicy(el);
      setTranslate(el, 0, 0);
      canvas.appendChild(el);
      return el;
    }

    function addRect() {
      const dims = getCanvasDimensions();
      const width = 180;
      const height = 110;
      const x = dims.minX + dims.width * 0.35 - width / 2;
      const y = dims.minY + dims.height * 0.38 - height / 2;
      const el = createShape("rect", {
        x: Number(x.toFixed(2)),
        y: Number(y.toFixed(2)),
        width,
        height,
        fill: "#fef3c7",
        stroke: "#374151",
        "stroke-width": 2
      });
      setSelection([el.dataset.id]);
      pushHistory("add-rect");
    }

    function applyLineStyle(lineEl, stroke) {
      if (!(lineEl instanceof SVGElement) || lineEl.tagName !== "line") return;
      const nextStroke = Math.max(0.5, Math.min(20, Number(stroke || 3) || 3));
      lineEl.setAttribute("stroke-width", String(nextStroke));
      lineEl.setAttribute("stroke-linecap", "butt");
      // Do not force non-scaling-stroke on content lines:
      // it keeps resize stable but causes visually wrong thickness when zooming.
      lineEl.removeAttribute("vector-effect");
      lineEl.style.removeProperty("vector-effect");
    }

    function addLine() {
      const stroke = 3;
      const dims = getCanvasDimensions();
      const cx = dims.minX + dims.width * 0.5;
      const cy = dims.minY + dims.height * 0.55;
      const half = Math.max(60, Math.min(220, dims.width * 0.15));
      const el = createShape("line", {
        x1: Number((cx - half).toFixed(2)),
        y1: Number(cy.toFixed(2)),
        x2: Number((cx + half).toFixed(2)),
        y2: Number(cy.toFixed(2)),
        stroke: "#0f172a",
        "stroke-width": stroke
      });
      applyLineStyle(el, stroke);
      setSelection([el.dataset.id]);
      pushHistory("add-line");
    }

    function addTriangle() {
      const dims = getCanvasDimensions();
      const cx = dims.minX + dims.width * 0.68;
      const cy = dims.minY + dims.height * 0.38;
      const halfW = Math.max(40, Math.min(120, dims.width * 0.08));
      const h = Math.max(70, Math.min(180, dims.height * 0.16));
      const el = createShape("polygon", {
        points: `${Number(cx.toFixed(2))},${Number((cy - h / 2).toFixed(2))} ${Number((cx + halfW).toFixed(2))},${Number((cy + h / 2).toFixed(2))} ${Number((cx - halfW).toFixed(2))},${Number((cy + h / 2).toFixed(2))}`,
        fill: "#dbeafe",
        stroke: "#1e3a8a",
        "stroke-width": 2
      });
      setSelection([el.dataset.id]);
      pushHistory("add-triangle");
    }

    function getLineStrokeWidthValue() {
      const input = document.getElementById("lineStrokeWidthInput");
      const raw = Number(input?.value || 3);
      const stroke = Math.max(0.5, Math.min(20, Number.isFinite(raw) ? raw : 3));
      if (input) input.value = String(Number(stroke.toFixed(2)));
      return stroke;
    }

    function syncLineStrokeWidthControlFromSelection() {
      const input = document.getElementById("lineStrokeWidthInput");
      if (!(input instanceof HTMLInputElement)) return;
      const targets = collectSelectedShapeElements().filter((el) =>
        ["rect", "ellipse", "circle", "path", "polygon", "polyline", "line"].includes(el.tagName)
      );
      if (!targets.length) return;
      const first = targets[0];
      const fallback = first.tagName === "line" ? 3 : 2;
      const stroke = Math.max(0.5, Math.min(20, Number(first.getAttribute("stroke-width") || fallback) || fallback));
      input.value = String(Number(stroke.toFixed(2)));
    }

    function applyLineStrokeWidthToSelection(options = {}) {
      const push = options.push !== false;
      const withStatus = options.withStatus !== false;
      const stroke = getLineStrokeWidthValue();
      const targets = collectSelectedShapeElements().filter((el) =>
        ["rect", "ellipse", "circle", "path", "polygon", "polyline", "line"].includes(el.tagName)
      );
      if (!targets.length) {
        if (withStatus) setStatus("Select stroked object(s) first.");
        return false;
      }
      targets.forEach((el) => {
        if (!el.getAttribute("stroke-width")) {
          el.setAttribute("stroke-width", el.tagName === "line" ? "3" : "2");
        }
        if (el.tagName === "line") {
          applyLineStyle(el, stroke);
          if (el.dataset.arrow === "1") applyArrowStyle(el);
        } else {
          el.setAttribute("stroke-width", String(Number(stroke.toFixed(4))));
        }
      });
      requestSelectionVisualRefresh();
      if (push) pushHistory("stroke-width");
      if (withStatus) setStatus(`Stroke width: ${Number(stroke.toFixed(2))}`);
      return true;
    }

    function ensureCanvasDefs() {
      let defs = canvas.querySelector(":scope > defs");
      if (!defs) {
        defs = document.createElementNS(SVG_NS, "defs");
        canvas.insertBefore(defs, canvas.firstChild);
      }
      return defs;
    }

    function ensureArtboardLayer() {
      const defs = ensureCanvasDefs();
      const layers = Array.from(canvas.querySelectorAll(":scope > g.fm-artboard-layer"));
      let layer = layers[0] || null;
      layers.slice(1).forEach((el) => el.remove());
      if (!(layer instanceof SVGElement)) {
        layer = document.createElementNS(SVG_NS, "g");
        layer.classList.add("fm-artboard-layer");
        layer.setAttribute("aria-hidden", "true");
      }
      layer.classList.add("fm-artboard-layer");
      layer.removeAttribute("data-id");
      layer.removeAttribute("data-base-transform");
      layer.removeAttribute("data-tx");
      layer.removeAttribute("data-ty");
      layer.setAttribute("pointer-events", "none");

      const anchor = defs.nextSibling;
      if (anchor !== layer) {
        if (anchor) canvas.insertBefore(layer, anchor);
        else canvas.appendChild(layer);
      }
      let artboardRect = layer.querySelector(":scope > rect.fm-artboard-bg");
      if (!(artboardRect instanceof SVGElement)) {
        artboardRect = document.createElementNS(SVG_NS, "rect");
        artboardRect.classList.add("fm-artboard-bg");
        layer.innerHTML = "";
        layer.appendChild(artboardRect);
      } else {
        Array.from(layer.querySelectorAll(":scope > rect.fm-artboard-bg")).slice(1).forEach((n) => n.remove());
      }
      artboardRect.classList.add("fm-artboard-bg");
      artboardRect.removeAttribute("data-id");
      artboardRect.removeAttribute("data-base-transform");
      artboardRect.removeAttribute("data-tx");
      artboardRect.removeAttribute("data-ty");
      artboardRect.setAttribute("pointer-events", "none");
      return { layer, rect: artboardRect };
    }

    function updateArtboardVisual() {
      const { minX, minY, width, height } = getCanvasDimensions();
      const refs = ensureArtboardLayer();
      refs.rect.setAttribute("x", String(Number(minX.toFixed(4))));
      refs.rect.setAttribute("y", String(Number(minY.toFixed(4))));
      refs.rect.setAttribute("width", String(Number(width.toFixed(4))));
      refs.rect.setAttribute("height", String(Number(height.toFixed(4))));
    }

    function applyArrowStyle(lineEl) {
      if (!(lineEl instanceof SVGElement) || lineEl.tagName !== "line") return;
      ensureId(lineEl);
      const defs = ensureCanvasDefs();
      const markerId = lineEl.dataset.arrowMarkerId || `arrow-m-${lineEl.dataset.id || createId()}`;
      lineEl.dataset.arrowMarkerId = markerId;
      lineEl.dataset.arrow = "1";

      let marker = defs.querySelector(`#${CSS.escape(markerId)}`);
      if (!(marker instanceof SVGElement)) {
        marker = document.createElementNS(SVG_NS, "marker");
        marker.setAttribute("id", markerId);
        marker.setAttribute("orient", "auto");
        defs.appendChild(marker);
      }
      marker.setAttribute("markerUnits", "strokeWidth");
      const stroke = Math.max(0.5, Math.min(20, Number(lineEl.getAttribute("stroke-width") || 3) || 3));
      lineEl.setAttribute("stroke-width", String(stroke));
      // Arrow rule:
      // - marker height in rendered space = stroke * 3
      // - line endpoint is aligned to arrowhead center (base center)
      const headH = 3;
      const headW = 4;
      marker.setAttribute("markerWidth", String(headW));
      marker.setAttribute("markerHeight", String(headH));
      marker.setAttribute("refX", "0");
      marker.setAttribute("refY", String(headH / 2));
      marker.setAttribute("viewBox", `0 0 ${headW} ${headH}`);
      marker.setAttribute("preserveAspectRatio", "none");
      marker.setAttribute("overflow", "visible");
      marker.innerHTML = "";
      const p = document.createElementNS(SVG_NS, "path");
      p.setAttribute("d", `M 0 0 L ${headW} ${headH / 2} L 0 ${headH} z`);
      p.setAttribute("fill", String(lineEl.getAttribute("stroke") || "#0f172a"));
      marker.appendChild(p);
      lineEl.setAttribute("marker-end", `url(#${markerId})`);
      applyLineStyle(lineEl, stroke);
    }

    function syncArrowControlsFromSelection() {
      // No arrow numeric controls in current workflow.
    }

    function getSelectedLineElements() {
      const out = [];
      const seen = new Set();
      const push = (el) => {
        if (!(el instanceof SVGElement) || el.tagName !== "line") return;
        ensureId(el);
        const id = el.dataset.id || "";
        if (!id || seen.has(id)) return;
        seen.add(id);
        out.push(el);
      };
      getTopSelectedElements().forEach((el) => {
        if (!(el instanceof SVGElement)) return;
        push(el);
        if (el.tagName === "g") el.querySelectorAll("line").forEach((n) => push(n));
      });
      return out;
    }

    function matchSelectedLinesToArrow() {
      const selectedLines = getSelectedLineElements();
      if (!selectedLines.length) {
        setStatus("Select line object(s) first.");
        return;
      }
      selectedLines.forEach((line) => {
        applyArrowStyle(line);
      });
      requestSelectionVisualRefresh();
      pushHistory("apply-arrow");
      setStatus(`Applied arrow to ${selectedLines.length} line(s).`);
    }

    function syncMarkControlsFromSelection() {
      const markSizeEl = document.getElementById("markFontSizeInput");
      if (!(markSizeEl instanceof HTMLInputElement)) return;
      if (state.selectedIds.length !== 1) return;
      const selected = getById(state.selectedIds[0]);
      if (!(selected instanceof SVGElement) || !isGroupLabel(selected)) return;
      const computed = window.getComputedStyle(selected).fontSize || "";
      const fromComputed = Number.parseFloat(computed);
      const size = Number.isFinite(fromComputed) ? fromComputed : Number(selected.getAttribute("font-size") || 16);
      if (!Number.isFinite(size)) return;
      markSizeEl.value = String(Math.max(6, Math.min(120, Math.round(size))));
    }

    function getNormalSelectedTextElements() {
      const out = [];
      const seen = new Set();
      const push = (node) => {
        if (!(node instanceof SVGElement)) return;
        if (node.tagName !== "text") return;
        if (!node.dataset.id) ensureId(node);
        const id = node.dataset.id || "";
        if (!id || seen.has(id)) return;
        if (isGroupLabel(node) || isFigureTitle(node)) return;
        seen.add(id);
        out.push(node);
      };
      getTopSelectedElements().forEach((el) => {
        if (!(el instanceof SVGElement)) return;
        push(el);
        if (el.tagName === "g") {
          el.querySelectorAll("text").forEach((n) => push(n));
        }
      });
      return out;
    }

    function getTextFontSizeValue() {
      const input = document.getElementById("textFontSizeInput");
      const raw = Number(input?.value || 28);
      const size = Math.max(6, Math.min(240, Number.isFinite(raw) ? raw : 28));
      if (input) input.value = String(Math.round(size));
      return Math.round(size);
    }

    function normalizeTextScriptMode(raw) {
      const s = String(raw || "").trim().toLowerCase();
      if (s === "super" || s === "superscript") return "super";
      if (s === "sub" || s === "subscript") return "sub";
      return "normal";
    }

    function syncTextControlsFromSelection() {
      const textSizeEl = document.getElementById("textFontSizeInput");
      if (!(textSizeEl instanceof HTMLInputElement)) return;
      const texts = getNormalSelectedTextElements();
      if (!texts.length) return;
      const first = texts[0];
      const baseScript = Number(first.getAttribute("data-fm-script-base-size") || "");
      const attr = Number(first.getAttribute("font-size") || "");
      const computed = Number.parseFloat(window.getComputedStyle(first).fontSize || "");
      const size = Number.isFinite(baseScript) && baseScript > 0
        ? baseScript
        : (Number.isFinite(attr) && attr > 0 ? attr : (Number.isFinite(computed) && computed > 0 ? computed : 28));
      if (!Number.isFinite(size)) return;
      textSizeEl.value = String(Math.max(6, Math.min(240, Math.round(size))));
      const colorInput = document.getElementById("textColorInput");
      if (colorInput instanceof HTMLInputElement) {
        colorInput.value = normalizeCssColorToHex(first.getAttribute("fill"), "#111827");
      }
    }

    function applyTextFontSizeToSelection(options = {}) {
      const push = options.push !== false;
      const withStatus = options.withStatus !== false;
      const size = getTextFontSizeValue();
      const targets = getNormalSelectedTextElements();
      if (!targets.length) {
        if (withStatus) setStatus("Select text object(s) to change Text size.");
        return false;
      }
      targets.forEach((el) => {
        const directTspans = Array.from(el.children).filter((n) => n instanceof SVGElement && n.tagName === "tspan");
        if (directTspans.length) {
          el.setAttribute("font-size", String(size));
          el.style.setProperty("font-size", `${size}px`);
          el.removeAttribute("data-fm-script-base-size");
          el.removeAttribute("data-fm-script");
          el.removeAttribute("baseline-shift");
          directTspans.forEach((span) => {
            const mode = normalizeTextScriptMode(span.getAttribute("baseline-shift") || span.getAttribute("data-fm-script"));
            if (mode === "super" || mode === "sub") {
              const scaled = Math.max(6, Math.round(size * 0.75));
              span.setAttribute("baseline-shift", mode);
              span.setAttribute("data-fm-script", mode);
              span.setAttribute("font-size", String(scaled));
              span.style.setProperty("font-size", `${scaled}px`);
            } else {
              span.removeAttribute("baseline-shift");
              span.removeAttribute("data-fm-script");
              span.removeAttribute("font-size");
              span.style.removeProperty("font-size");
            }
          });
          return;
        }
        const scriptMode = String(el.getAttribute("data-fm-script") || "");
        if (scriptMode === "super" || scriptMode === "sub") {
          el.setAttribute("data-fm-script-base-size", String(size));
          const scaled = Math.max(6, Math.round(size * 0.75));
          el.setAttribute("font-size", String(scaled));
          el.style.setProperty("font-size", `${scaled}px`);
        } else {
          el.removeAttribute("data-fm-script-base-size");
          el.setAttribute("font-size", String(size));
          el.style.setProperty("font-size", `${size}px`);
        }
      });
      requestSelectionVisualRefresh();
      if (push) pushHistory("text-size");
      if (withStatus) setStatus(`Text size set: ${size}`);
      return true;
    }

    function normalizeCssColorToHex(value, fallback = "#111827") {
      const canvasTmp = normalizeCssColorToHex._canvas || document.createElement("canvas");
      normalizeCssColorToHex._canvas = canvasTmp;
      const ctx = normalizeCssColorToHex._ctx || canvasTmp.getContext("2d");
      normalizeCssColorToHex._ctx = ctx;
      if (!ctx) return fallback;
      let v = String(value || "").trim();
      if (!v || v === "none" || v === "transparent") return fallback;
      try {
        ctx.fillStyle = "#000000";
        ctx.fillStyle = v;
        const computed = String(ctx.fillStyle || "").trim();
        if (/^#[0-9a-f]{6}$/i.test(computed)) return computed.toLowerCase();
        const rgb = computed.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)/i);
        if (rgb) {
          const toHex = (n) => Number(n).toString(16).padStart(2, "0");
          return `#${toHex(rgb[1])}${toHex(rgb[2])}${toHex(rgb[3])}`;
        }
      } catch (_) {}
      return fallback;
    }

    function collectSelectedShapeElements() {
      const result = [];
      const seen = new Set();
      const push = (node) => {
        if (!(node instanceof SVGElement)) return;
        if (isGroupLabel(node) || isFigureTitle(node)) return;
        if (!isEditableElement(node)) return;
        if (!node.dataset.id) ensureId(node);
        const id = node.dataset.id || "";
        if (!id || seen.has(id)) return;
        seen.add(id);
        result.push(node);
      };
      getTopSelectedElements().forEach((el) => {
        if (!(el instanceof SVGElement)) return;
        if (el.tagName === "g") {
          el.querySelectorAll("rect,ellipse,circle,path,polygon,polyline,line").forEach((n) => push(n));
        } else {
          push(el);
        }
      });
      return result;
    }

    function syncObjectColorControlsFromSelection() {
      const fillInput = document.getElementById("objectFillColorInput");
      const strokeInput = document.getElementById("objectStrokeColorInput");
      const strokeToggleEl = document.getElementById("objectStrokeToggle");
      if (!(fillInput instanceof HTMLInputElement) || !(strokeInput instanceof HTMLInputElement)) return;
      const targets = collectSelectedShapeElements();
      if (!targets.length) return;
      const fillEl = targets.find((el) => ["rect", "ellipse", "circle", "path", "polygon", "polyline"].includes(el.tagName)) || targets[0];
      const strokeEl = targets.find((el) => ["rect", "ellipse", "circle", "path", "polygon", "polyline", "line"].includes(el.tagName)) || targets[0];
      fillInput.value = normalizeCssColorToHex(fillEl.getAttribute("fill"), "#dbeafe");
      strokeInput.value = normalizeCssColorToHex(strokeEl.getAttribute("stroke"), "#1e3a8a");
      if (strokeToggleEl instanceof HTMLInputElement) {
        const outlineTargets = targets.filter((el) => el.tagName === "rect" || el.tagName === "ellipse" || el.tagName === "circle");
        if (outlineTargets.length) {
          strokeToggleEl.checked = outlineTargets.every((el) => String(el.getAttribute("stroke") || "").trim().toLowerCase() !== "none");
        }
      }
    }

    function applyObjectFillColor(options = {}) {
      const push = options.push !== false;
      const withStatus = options.withStatus !== false;
      const input = document.getElementById("objectFillColorInput");
      const color = String(input?.value || "").trim();
      if (!/^#[0-9a-fA-F]{6}$/.test(color)) return false;
      const targets = collectSelectedShapeElements().filter((el) => ["rect", "ellipse", "circle", "path", "polygon", "polyline"].includes(el.tagName));
      if (!targets.length) {
        if (withStatus) setStatus("Select shape object(s) to change fill.");
        return false;
      }
      targets.forEach((el) => el.setAttribute("fill", color));
      if (push) pushHistory("object-fill");
      requestSelectionVisualRefresh();
      if (withStatus) setStatus(`Object fill set: ${color}`);
      return true;
    }

    function applyObjectStrokeColor(options = {}) {
      const push = options.push !== false;
      const withStatus = options.withStatus !== false;
      const input = document.getElementById("objectStrokeColorInput");
      const color = String(input?.value || "").trim();
      if (!/^#[0-9a-fA-F]{6}$/.test(color)) return false;
      const targets = collectSelectedShapeElements().filter((el) => ["rect", "ellipse", "circle", "path", "polygon", "polyline", "line"].includes(el.tagName));
      if (!targets.length) {
        if (withStatus) setStatus("Select shape object(s) to change stroke.");
        return false;
      }
      targets.forEach((el) => {
        el.setAttribute("stroke", color);
        if (el.tagName === "rect" || el.tagName === "ellipse" || el.tagName === "circle") {
          el.dataset.prevStrokeColor = color;
          if (!el.getAttribute("stroke-width")) el.setAttribute("stroke-width", "2");
        }
        if (el.dataset.arrow === "1") {
          const markerId = el.dataset.arrowMarkerId || "";
          const marker = markerId ? canvas.querySelector(`#${CSS.escape(markerId)} path`) : null;
          if (marker instanceof SVGElement) marker.setAttribute("fill", color);
        }
      });
      if (push) pushHistory("object-stroke");
      requestSelectionVisualRefresh();
      if (withStatus) setStatus(`Object stroke set: ${color}`);
      return true;
    }

    function applyObjectStrokeToggle(options = {}) {
      const push = options.push !== false;
      const withStatus = options.withStatus !== false;
      const toggle = document.getElementById("objectStrokeToggle");
      const strokeInput = document.getElementById("objectStrokeColorInput");
      if (!(toggle instanceof HTMLInputElement)) return false;
      const enabled = !!toggle.checked;
      const strokeColor = String((strokeInput instanceof HTMLInputElement ? strokeInput.value : "#1e3a8a") || "#1e3a8a");
      const targets = collectSelectedShapeElements().filter((el) => el.tagName === "rect" || el.tagName === "ellipse" || el.tagName === "circle");
      if (!targets.length) {
        if (withStatus) setStatus("Select rect/circle/ellipse object(s) first.");
        return false;
      }
      targets.forEach((el) => {
        if (enabled) {
          const restore = String(el.dataset.prevStrokeColor || "").trim();
          el.setAttribute("stroke", /^#[0-9a-f]{6}$/i.test(restore) ? restore : strokeColor);
          const w = Number(el.dataset.prevStrokeWidth || el.getAttribute("stroke-width") || 2);
          el.setAttribute("stroke-width", String(Math.max(0.5, Number.isFinite(w) ? w : 2)));
        } else {
          const current = String(el.getAttribute("stroke") || "").trim();
          if (current && current.toLowerCase() !== "none") el.dataset.prevStrokeColor = current;
          const currentW = Number(el.getAttribute("stroke-width") || "");
          if (Number.isFinite(currentW) && currentW > 0) el.dataset.prevStrokeWidth = String(currentW);
          el.setAttribute("stroke", "none");
        }
      });
      if (push) pushHistory(enabled ? "stroke-on" : "stroke-off");
      requestSelectionVisualRefresh();
      if (withStatus) setStatus(enabled ? "Stroke enabled." : "Stroke disabled.");
      return true;
    }

    function applyTextColorToSelection(options = {}) {
      const push = options.push !== false;
      const withStatus = options.withStatus !== false;
      const input = document.getElementById("textColorInput");
      const color = String(input?.value || "").trim();
      if (!/^#[0-9a-fA-F]{6}$/.test(color)) return false;
      const targets = getNormalSelectedTextElements();
      if (!targets.length) {
        if (withStatus) setStatus("Select text object(s) to change color.");
        return false;
      }
      targets.forEach((el) => el.setAttribute("fill", color));
      if (push) pushHistory("text-color");
      requestSelectionVisualRefresh();
      if (withStatus) setStatus(`Text color set: ${color}`);
      return true;
    }

    function toggleTextBold() {
      const targets = getNormalSelectedTextElements();
      if (!targets.length) {
        setStatus("Select text object(s) first.");
        return;
      }
      const allBold = targets.every((el) => {
        const attr = String(el.getAttribute("font-weight") || "").toLowerCase();
        if (attr === "bold") return true;
        const n = Number(attr);
        return Number.isFinite(n) && n >= 600;
      });
      targets.forEach((el) => el.setAttribute("font-weight", allBold ? "400" : "700"));
      pushHistory("text-bold");
      setStatus(allBold ? "Text bold off." : "Text bold on.");
    }

    function toggleTextItalic() {
      const targets = getNormalSelectedTextElements();
      if (!targets.length) {
        setStatus("Select text object(s) first.");
        return;
      }
      const allItalic = targets.every((el) => String(el.getAttribute("font-style") || "").toLowerCase() === "italic");
      targets.forEach((el) => el.setAttribute("font-style", allItalic ? "normal" : "italic"));
      pushHistory("text-italic");
      setStatus(allItalic ? "Text italic off." : "Text italic on.");
    }

    function normalizeScriptRuns(textLength, runs) {
      const len = Math.max(0, Number(textLength || 0));
      if (!len) return [];
      const list = Array.isArray(runs) ? runs : [];
      const clipped = list
        .map((run) => ({
          start: Math.max(0, Math.min(len, Number(run?.start || 0))),
          end: Math.max(0, Math.min(len, Number(run?.end || 0))),
          mode: normalizeTextScriptMode(run?.mode)
        }))
        .filter((run) => run.end > run.start)
        .sort((a, b) => a.start - b.start || a.end - b.end);
      if (!clipped.length) return [{ start: 0, end: len, mode: "normal" }];
      const merged = [];
      let cursor = 0;
      clipped.forEach((run) => {
        if (cursor < run.start) merged.push({ start: cursor, end: run.start, mode: "normal" });
        const s = Math.max(cursor, run.start);
        const e = Math.max(s, run.end);
        if (!merged.length || merged[merged.length - 1].mode !== run.mode || merged[merged.length - 1].end !== s) {
          merged.push({ start: s, end: e, mode: run.mode });
        } else {
          merged[merged.length - 1].end = e;
        }
        cursor = Math.max(cursor, e);
      });
      if (cursor < len) merged.push({ start: cursor, end: len, mode: "normal" });
      return merged.filter((run) => run.end > run.start);
    }

    function scriptRunsToModeArray(textLength, runs) {
      const len = Math.max(0, Number(textLength || 0));
      const arr = new Array(len).fill("normal");
      normalizeScriptRuns(len, runs).forEach((run) => {
        for (let i = run.start; i < run.end; i += 1) arr[i] = run.mode;
      });
      return arr;
    }

    function modeArrayToScriptRuns(modeArray) {
      if (!Array.isArray(modeArray) || !modeArray.length) return [];
      const runs = [];
      let start = 0;
      let cur = normalizeTextScriptMode(modeArray[0]);
      for (let i = 1; i <= modeArray.length; i += 1) {
        const mode = i < modeArray.length ? normalizeTextScriptMode(modeArray[i]) : null;
        if (mode !== cur) {
          runs.push({ start, end: i, mode: cur });
          start = i;
          cur = mode;
        }
      }
      return runs;
    }

    function extractTextRunsForEditing(textEl) {
      if (!(textEl instanceof SVGElement) || textEl.tagName !== "text") {
        return { text: "", runs: [] };
      }
      const chunks = [];
      const pushChunk = (txt, mode) => {
        const value = String(txt || "");
        if (!value) return;
        chunks.push({ text: value, mode: normalizeTextScriptMode(mode) });
      };
      const children = Array.from(textEl.childNodes);
      if (!children.length) {
        const plain = String(textEl.textContent || "");
        return {
          text: plain,
          runs: plain ? [{ start: 0, end: plain.length, mode: normalizeTextScriptMode(textEl.getAttribute("data-fm-script")) }] : []
        };
      }
      children.forEach((node) => {
        if (node.nodeType === Node.TEXT_NODE) {
          pushChunk(node.textContent || "", textEl.getAttribute("data-fm-script"));
          return;
        }
        if (node instanceof SVGElement && node.tagName === "tspan") {
          pushChunk(node.textContent || "", node.getAttribute("baseline-shift") || node.getAttribute("data-fm-script"));
          return;
        }
        pushChunk(node.textContent || "", "normal");
      });
      const text = chunks.map((c) => c.text).join("");
      let cursor = 0;
      const runs = chunks.map((c) => {
        const run = { start: cursor, end: cursor + c.text.length, mode: c.mode };
        cursor += c.text.length;
        return run;
      });
      return { text, runs: normalizeScriptRuns(text.length, runs) };
    }

    function applyTextRunsToElement(textEl, text, runs, options = {}) {
      if (!(textEl instanceof SVGElement) || textEl.tagName !== "text") return;
      const rawText = String(text || "");
      const currentSizeAttr = Number(textEl.getAttribute("font-size") || "");
      const currentSizeCss = Number.parseFloat(window.getComputedStyle(textEl).fontSize || "");
      const baseSize = Math.max(6, Number(options.baseSize || (Number.isFinite(currentSizeAttr) && currentSizeAttr > 0 ? currentSizeAttr : (Number.isFinite(currentSizeCss) && currentSizeCss > 0 ? currentSizeCss : 28))));
      const normalizedRuns = normalizeScriptRuns(rawText.length, runs);
      while (textEl.firstChild) textEl.removeChild(textEl.firstChild);
      textEl.removeAttribute("baseline-shift");
      textEl.removeAttribute("data-fm-script");
      textEl.removeAttribute("data-fm-script-base-size");
      textEl.setAttribute("font-size", String(Math.round(baseSize)));
      textEl.style.setProperty("font-size", `${Math.round(baseSize)}px`);
      if (!rawText) return;
      if (normalizedRuns.length === 1 && normalizedRuns[0].mode === "normal") {
        textEl.textContent = rawText;
        return;
      }
      normalizedRuns.forEach((run) => {
        const segment = rawText.slice(run.start, run.end);
        if (!segment) return;
        if (run.mode === "normal") {
          textEl.appendChild(document.createTextNode(segment));
          return;
        }
        const span = document.createElementNS(SVG_NS, "tspan");
        span.textContent = segment;
        span.setAttribute("baseline-shift", run.mode);
        span.setAttribute("data-fm-script", run.mode);
        const scaled = Math.max(6, Math.round(baseSize * 0.75));
        span.setAttribute("font-size", String(scaled));
        span.style.setProperty("font-size", `${scaled}px`);
        textEl.appendChild(span);
      });
    }

    function setScriptModeInRange(textLength, runs, start, end, mode) {
      const len = Math.max(0, Number(textLength || 0));
      const s = Math.max(0, Math.min(len, Number(start || 0)));
      const e = Math.max(0, Math.min(len, Number(end || 0)));
      if (e <= s) return normalizeScriptRuns(len, runs);
      const normalizedMode = normalizeTextScriptMode(mode);
      const arr = scriptRunsToModeArray(len, runs);
      for (let i = s; i < e; i += 1) arr[i] = normalizedMode;
      return modeArrayToScriptRuns(arr);
    }

    function isRangeAllMode(textLength, runs, start, end, mode) {
      const len = Math.max(0, Number(textLength || 0));
      const s = Math.max(0, Math.min(len, Number(start || 0)));
      const e = Math.max(0, Math.min(len, Number(end || 0)));
      if (e <= s) return false;
      const target = normalizeTextScriptMode(mode);
      const arr = scriptRunsToModeArray(len, runs);
      for (let i = s; i < e; i += 1) {
        if (arr[i] !== target) return false;
      }
      return true;
    }

    function toggleTextScript(mode) {
      const targetMode = mode === "sub" ? "sub" : "super";
      if (state.textEdit) {
        const target = getById(state.textEdit.targetId || "");
        if (!(target instanceof SVGElement) || target.tagName !== "text") {
          setStatus("Text editing target not found.");
          return;
        }
        const text = String(textEditorInput.value || "");
        const selStart = Number(textEditorInput.selectionStart || 0);
        const selEnd = Number(textEditorInput.selectionEnd || 0);
        if (selEnd <= selStart) {
          setStatus("Select characters in the text editor first.");
          return;
        }
        const currentRuns = normalizeScriptRuns(text.length, state.textEdit.runs);
        const allSame = isRangeAllMode(text.length, currentRuns, selStart, selEnd, targetMode);
        const nextMode = allSame ? "normal" : targetMode;
        const nextRuns = setScriptModeInRange(text.length, currentRuns, selStart, selEnd, nextMode);
        state.textEdit.text = text;
        state.textEdit.runs = nextRuns;
        applyTextRunsToElement(target, text, nextRuns);
        requestSelectionVisualRefresh();
        setStatus(nextMode === "normal" ? "Selected script cleared." : `Selected text ${nextMode}script.`);
        return;
      }
      const targets = getNormalSelectedTextElements();
      if (!targets.length) {
        setStatus("Select text object(s) first.");
        return;
      }
      const allSame = targets.every((el) => String(el.getAttribute("data-fm-script") || "") === targetMode);
      const nextMode = allSame ? "normal" : targetMode;
      targets.forEach((el) => {
        const currentSizeAttr = Number(el.getAttribute("font-size") || "");
        const currentSizeCss = Number.parseFloat(window.getComputedStyle(el).fontSize || "");
        let base = Number(el.getAttribute("data-fm-script-base-size") || "");
        if (!Number.isFinite(base) || base <= 0) {
          base = Number.isFinite(currentSizeAttr) && currentSizeAttr > 0
            ? currentSizeAttr
            : (Number.isFinite(currentSizeCss) && currentSizeCss > 0 ? currentSizeCss : 28);
        }
        if (nextMode === "normal") {
          el.setAttribute("font-size", String(Math.round(base)));
          el.style.setProperty("font-size", `${Math.round(base)}px`);
          el.removeAttribute("baseline-shift");
          el.removeAttribute("data-fm-script");
          el.removeAttribute("data-fm-script-base-size");
        } else {
          el.setAttribute("data-fm-script", nextMode);
          el.setAttribute("data-fm-script-base-size", String(Math.round(base)));
          const scaled = Math.max(6, Math.round(base * 0.75));
          el.setAttribute("font-size", String(scaled));
          el.style.setProperty("font-size", `${scaled}px`);
          el.setAttribute("baseline-shift", nextMode === "super" ? "super" : "sub");
        }
      });
      syncTextControlsFromSelection();
      pushHistory(`text-${nextMode}`);
      setStatus(nextMode === "normal" ? "Text script cleared." : `Text ${nextMode}script on.`);
    }

    function addEllipse() {
      const dims = getCanvasDimensions();
      const cx = dims.minX + dims.width * 0.62;
      const cy = dims.minY + dims.height * 0.42;
      const rx = Math.max(40, Math.min(120, dims.width * 0.12));
      const ry = Math.max(28, Math.min(90, dims.height * 0.08));
      const el = createShape("ellipse", {
        cx: Number(cx.toFixed(2)),
        cy: Number(cy.toFixed(2)),
        rx: Number(rx.toFixed(2)),
        ry: Number(ry.toFixed(2)),
        fill: "#dbeafe",
        stroke: "#1e3a8a",
        "stroke-width": 2
      });
      setSelection([el.dataset.id]);
      pushHistory("add-ellipse");
    }

    function addText() {
      const dims = getCanvasDimensions();
      const x = dims.minX + dims.width * 0.5;
      const y = dims.minY + dims.height * 0.62;
      const el = createShape("text", {
        x: Number(x.toFixed(2)),
        y: Number(y.toFixed(2)),
        fill: "#111827",
        "font-size": 28,
        "font-family": "Arial"
      }, "Text");
      setSelection([el.dataset.id]);
      pushHistory("add-text");
    }

    function normalizeFigureNumber(value) {
      const n = Number(value);
      if (!Number.isFinite(n)) return 1;
      return Math.max(0, Math.min(9999, Math.round(n)));
    }

    function normalizeFigureFontSize(value) {
      const n = Number(value);
      if (!Number.isFinite(n)) return FIGURE_TITLE_DEFAULT_FONT_SIZE;
      return Math.max(8, Math.min(200, Math.round(n)));
    }

    function normalizeFigureKind(value) {
      return String(value || "").toLowerCase() === "supplementary" ? "supplementary" : "figure";
    }

    function getFigurePrefixLabel(kind) {
      return normalizeFigureKind(kind) === "supplementary" ? "Supplementary Figure" : "Figure";
    }

    function readFigureNumber(el) {
      if (!(el instanceof SVGElement)) return 1;
      const fromData = Number(el.getAttribute("data-figure-number") || "");
      if (Number.isFinite(fromData)) return normalizeFigureNumber(fromData);
      const txt = String(el.textContent || "");
      const m = txt.match(/(\d+)/);
      return normalizeFigureNumber(m ? Number(m[1]) : 1);
    }

    function readFigureKind(el) {
      if (!(el instanceof SVGElement)) return "figure";
      const raw = String(el.getAttribute("data-figure-kind") || "").trim().toLowerCase();
      if (raw === "supplementary" || raw === "figure") return raw;
      const txt = String(el.textContent || "").trim().toLowerCase();
      return txt.startsWith("supplementary figure") ? "supplementary" : "figure";
    }

    function readFigureFontSize(el) {
      if (!(el instanceof SVGElement)) return FIGURE_TITLE_DEFAULT_FONT_SIZE;
      const attr = Number(el.getAttribute("font-size") || "");
      if (Number.isFinite(attr) && attr > 0) return normalizeFigureFontSize(attr);
      const cs = window.getComputedStyle(el);
      const px = Number.parseFloat(cs?.fontSize || "");
      if (Number.isFinite(px) && px > 0) return normalizeFigureFontSize(px);
      return FIGURE_TITLE_DEFAULT_FONT_SIZE;
    }

    function setFigureTitleNumber(el, numberValue, kindValue, fontSizeValue) {
      if (!(el instanceof SVGElement)) return;
      const number = normalizeFigureNumber(numberValue);
      const kind = normalizeFigureKind(kindValue || readFigureKind(el));
      const prefix = getFigurePrefixLabel(kind);
      const fontSize = normalizeFigureFontSize(fontSizeValue || readFigureFontSize(el));
      el.setAttribute("data-fm-figure-title", "1");
      el.setAttribute("data-figure-number", String(number));
      el.setAttribute("data-figure-kind", kind);
      el.classList.add("fm-figure-title");
      if (!el.getAttribute("font-family")) el.setAttribute("font-family", "Arial");
      el.setAttribute("font-size", String(fontSize));
      if (!el.getAttribute("font-weight")) el.setAttribute("font-weight", "700");
      if (!el.getAttribute("fill")) el.setAttribute("fill", "#111827");
      el.textContent = `${prefix} ${number}`;
      applyPointerEventPolicy(el);
    }

    function ensureFigureTitle(options = {}) {
      const select = options.select === true;
      const push = options.push === true;
      let title = canvas.querySelector('[data-fm-figure-title="1"], .fm-figure-title');
      if (!(title instanceof SVGElement) || title.tagName !== "text") {
        const dims = getCanvasDimensions();
        title = document.createElementNS(SVG_NS, "text");
        title.setAttribute("x", String(Number((dims.minX + 24).toFixed(2))));
        title.setAttribute("y", String(Number((dims.minY + 42).toFixed(2))));
        setFigureTitleNumber(title, 1);
        ensureId(title);
        setTranslate(title, 0, 0);
        canvas.appendChild(title);
        if (push) pushHistory("figure-title-add");
      } else {
        ensureId(title);
        ensureTransformState(title);
        setFigureTitleNumber(title, readFigureNumber(title));
      }
      if (select && title.dataset?.id) setSelection([title.dataset.id]);
      return title;
    }

    function closeFigureEditor() {
      if (!figureEditorEl || figureEditorEl.style.display === "none") return false;
      figureEditorEl.style.display = "none";
      figureEditorEl.dataset.targetId = "";
      return true;
    }

    function cycleFigureEditorNumber(step) {
      if (!(figureEditorInputEl instanceof HTMLInputElement)) return;
      const dir = Number(step || 0) >= 0 ? 1 : -1;
      const next = normalizeFigureNumber(Number(figureEditorInputEl.value || 1) + dir);
      figureEditorInputEl.value = String(next);
    }

    function openFigureEditorFor(titleEl, clientX, clientY) {
      if (!(titleEl instanceof SVGElement) || !isFigureTitle(titleEl) || !titleEl.dataset?.id) return;
      if (!(figureEditorEl instanceof HTMLElement) || !(figureEditorInputEl instanceof HTMLInputElement)) return;
      const number = readFigureNumber(titleEl);
      const kind = readFigureKind(titleEl);
      figureEditorInputEl.value = String(number);
      if (figureEditorTypeEl instanceof HTMLSelectElement) {
        figureEditorTypeEl.value = kind;
      }
      const prefixEl = figureEditorEl.querySelector(".figure-editor-prefix");
      if (prefixEl) prefixEl.textContent = getFigurePrefixLabel(kind);
      figureEditorEl.dataset.targetId = titleEl.dataset.id;
      const box = titleEl.getBoundingClientRect();
      const rawX = Number.isFinite(clientX) ? clientX : (box.right + 8);
      const rawY = Number.isFinite(clientY) ? clientY : box.top;
      const x = Math.max(8, Math.min(rawX, window.innerWidth - 220));
      const y = Math.max(8, Math.min(rawY, window.innerHeight - 56));
      figureEditorEl.style.left = `${x}px`;
      figureEditorEl.style.top = `${y}px`;
      figureEditorEl.style.display = "inline-flex";
      figureEditorInputEl.focus();
      figureEditorInputEl.select();
    }

    function applyFigureFromEditor() {
      const id = String(figureEditorEl?.dataset.targetId || "");
      const target = id ? getById(id) : null;
      if (!(target instanceof SVGElement) || !isFigureTitle(target)) {
        closeFigureEditor();
        return;
      }
      const before = readFigureNumber(target);
      const beforeKind = readFigureKind(target);
      const next = normalizeFigureNumber(Number(figureEditorInputEl?.value || before));
      const nextKind = normalizeFigureKind(figureEditorTypeEl?.value || beforeKind);
      setFigureTitleNumber(target, next, nextKind);
      closeFigureEditor();
      requestSelectionVisualRefresh();
      if (next !== before || nextKind !== beforeKind) pushHistory("figure-title-number");
      setStatus(`${getFigurePrefixLabel(nextKind)} ${next}`);
    }

    function getCleanCanvasMarkup() {
      const clone = canvas.cloneNode(true);
      clone.querySelectorAll(".selection-outline,.selection-handle,.marquee,.smart-guide,.crop-boundary,.crop-draft,.crop-mask,.crop-handle").forEach((el) => el.remove());
      clone.querySelectorAll(".fm-selected,.fm-group-selected").forEach((el) => {
        el.classList.remove("fm-selected");
        el.classList.remove("fm-group-selected");
        if (el.classList.length === 0) el.removeAttribute("class");
      });
      clone.querySelectorAll("[data-id],[data-tx],[data-ty],[data-base-transform]").forEach((el) => {
        el.removeAttribute("data-id");
        el.removeAttribute("data-tx");
        el.removeAttribute("data-ty");
        el.removeAttribute("data-base-transform");
      });
      return clone.innerHTML;
    }

    function getCanvasMeta() {
      return {
        viewBox: state.artboardViewBox || DEFAULT_ARTBOARD_VIEWBOX,
        artboardViewBox: state.artboardViewBox || DEFAULT_ARTBOARD_VIEWBOX,
        workspaceViewBox: WORKSPACE_VIEWBOX
      };
    }

    function centerViewportOnArtboard() {
      const art = getCanvasDimensions();
      const z = Math.max(MIN_VIEW_SCALE, Math.min(MAX_VIEW_SCALE, Number(state.viewScale) || 1));
      const centerX = (art.minX + art.width / 2) * z;
      const centerY = (art.minY + art.height / 2) * z;
      const maxScrollX = Math.max(0, canvas.scrollWidth - canvasWrapEl.clientWidth);
      const maxScrollY = Math.max(0, canvas.scrollHeight - canvasWrapEl.clientHeight);
      canvasWrapEl.scrollLeft = Math.max(0, Math.min(maxScrollX, centerX - canvasWrapEl.clientWidth / 2));
      canvasWrapEl.scrollTop = Math.max(0, Math.min(maxScrollY, centerY - canvasWrapEl.clientHeight / 2));
    }

    function applyCanvasMeta(meta, options = {}) {
      const rawArtboard = meta?.artboardViewBox || meta?.viewBox || state.artboardViewBox || DEFAULT_ARTBOARD_VIEWBOX;
      const art = normalizeArtboardBox(rawArtboard, { centerIfLegacy: true });
      state.artboardViewBox = formatViewBoxString(art);
      canvas.setAttribute("viewBox", WORKSPACE_VIEWBOX);
      canvas.setAttribute("width", String(WORKSPACE_SIZE));
      canvas.setAttribute("height", String(WORKSPACE_SIZE));
      ensureArtboardLayer();
      updateArtboardVisual();
      syncCanvasDisplaySizeFromViewBox();
      if (options.centerScroll) centerViewportOnArtboard();
    }

    function getCanvasDimensions() {
      const parts = parseViewBoxString(state.artboardViewBox || DEFAULT_ARTBOARD_VIEWBOX, parseViewBoxString(DEFAULT_ARTBOARD_VIEWBOX));
      const minX = Number.isFinite(parts.minX) ? parts.minX : 0;
      const minY = Number.isFinite(parts.minY) ? parts.minY : 0;
      const width = Number.isFinite(parts.width) && parts.width > 0 ? parts.width : 794;
      const height = Number.isFinite(parts.height) && parts.height > 0 ? parts.height : 1123;
      return { minX, minY, width, height };
    }

    function getCanvasDisplayScale() {
      const rect = canvas.getBoundingClientRect();
      const { width, height } = getWorkspaceDimensions();
      const sx = rect.width / Math.max(width, 1e-6);
      const sy = rect.height / Math.max(height, 1e-6);
      const s = Math.min(sx, sy);
      return Number.isFinite(s) && s > 0 ? s : 1;
    }

    function getCanvasDisplaySize() {
      const { width, height } = getWorkspaceDimensions();
      const z = Math.max(MIN_VIEW_SCALE, Math.min(MAX_VIEW_SCALE, Number(state.viewScale) || 1));
      return { width: width * z, height: height * z };
    }

    function syncCanvasDisplaySizeFromViewBox() {
      const display = getCanvasDisplaySize();
      canvas.style.width = `${Math.round(display.width)}px`;
      canvas.style.height = `${Math.round(display.height)}px`;
    }

    function clampViewScale(scale) {
      const n = Number(scale);
      if (!Number.isFinite(n)) return state.viewScale || 1;
      return Math.max(MIN_VIEW_SCALE, Math.min(MAX_VIEW_SCALE, n));
    }

    function setCanvasZoom(scale, anchorClientX = null, anchorClientY = null, options = {}) {
      const next = clampViewScale(scale);
      const prev = clampViewScale(state.viewScale || 1);
      if (Math.abs(next - prev) < 1e-6) return;
      const wrapRect = canvasWrapEl.getBoundingClientRect();
      const oldSize = getCanvasDisplaySize();
      const viewportX = Number.isFinite(anchorClientX) ? anchorClientX - wrapRect.left : canvasWrapEl.clientWidth / 2;
      const viewportY = Number.isFinite(anchorClientY) ? anchorClientY - wrapRect.top : canvasWrapEl.clientHeight / 2;
      const anchorContentX = canvasWrapEl.scrollLeft + viewportX;
      const anchorContentY = canvasWrapEl.scrollTop + viewportY;
      const rx = oldSize.width > 0 ? anchorContentX / oldSize.width : 0.5;
      const ry = oldSize.height > 0 ? anchorContentY / oldSize.height : 0.5;

      state.viewScale = next;
      syncCanvasDisplaySizeFromViewBox();
      requestSelectionVisualRefresh();
      syncZoomControls();
      renderStatus();

      const newSize = getCanvasDisplaySize();
      const maxScrollX = Math.max(0, newSize.width - canvasWrapEl.clientWidth);
      const maxScrollY = Math.max(0, newSize.height - canvasWrapEl.clientHeight);
      const targetLeft = Math.max(0, Math.min(maxScrollX, rx * newSize.width - viewportX));
      const targetTop = Math.max(0, Math.min(maxScrollY, ry * newSize.height - viewportY));
      canvasWrapEl.scrollLeft = targetLeft;
      canvasWrapEl.scrollTop = targetTop;

      if (!options.silent) {
        setStatus(`Zoom ${Math.round(next * 100)}%.`);
      }
    }

    function zoomByFactor(factor, anchorClientX = null, anchorClientY = null, options = {}) {
      const f = Number.isFinite(factor) && factor > 0 ? factor : 1;
      setCanvasZoom((state.viewScale || 1) * f, anchorClientX, anchorClientY, options);
    }

    function getTouchMetrics(touches) {
      if (!touches || touches.length < 2) return null;
      const t0 = touches[0];
      const t1 = touches[1];
      const dx = t0.clientX - t1.clientX;
      const dy = t0.clientY - t1.clientY;
      const distance = Math.hypot(dx, dy);
      return {
        distance,
        centerX: (t0.clientX + t1.clientX) / 2,
        centerY: (t0.clientY + t1.clientY) / 2
      };
    }

    function getCleanSvgDocument() {
      const { minX, minY, width, height } = getCanvasDimensions();
      return `<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="${minX} ${minY} ${width} ${height}" width="${width}" height="${height}">${getCleanCanvasMarkup()}</svg>`;
    }

    function getEffectiveTool() {
      return state.spacePanActive ? "hand" : state.tool;
    }

    function syncToolButtons() {
      const effective = getEffectiveTool();
      const selectBtn = document.getElementById("toolSelect");
      const directBtn = document.getElementById("toolDirect");
      const handBtn = document.getElementById("toolHand");
      if (selectBtn) selectBtn.classList.toggle("active", effective === "select");
      if (directBtn) directBtn.classList.toggle("active", effective === "direct");
      if (handBtn) handBtn.classList.toggle("active", effective === "hand");
    }

    function setTool(tool, options = {}) {
      const withStatus = options.withStatus !== false;
      const next = tool === "direct" || tool === "hand" ? tool : "select";
      state.tool = next;
      if (options.clearSpacePan !== false) state.spacePanActive = false;
      syncToolButtons();
      updateToolCursor();
      if (withStatus) {
        const label = next === "direct" ? "White Arrow" : (next === "hand" ? "Hand" : "Black Arrow");
        setStatus(`Tool: ${label}`);
      }
    }

    function switchToolbarTab(tab, options = {}) {
      const next = tab === "object" || tab === "text" ? tab : "tool";
      if (state.cropMode && next !== "tool") {
        cancelImageCropMode({ silent: true });
      }
      state.toolbarTab = next;
      document.querySelectorAll("[data-toolbar-tab-btn]").forEach((btn) => {
        btn.classList.toggle("active", btn.getAttribute("data-toolbar-tab-btn") === next);
      });
      document.querySelectorAll(".toolbar .group[data-toolbar-tab]").forEach((group) => {
        const groupTab = group.getAttribute("data-toolbar-tab") || "";
        group.hidden = groupTab !== "all" && groupTab !== next;
      });
      if (!options.silent) setStatus(`Toolbar tab: ${next}`);
    }

    function setupToolbarTabs() {
      const bar = document.getElementById("toolbarTabBar");
      if (!bar) return;
      bar.addEventListener("click", (e) => {
        const btn = e.target instanceof Element ? e.target.closest("[data-toolbar-tab-btn]") : null;
        if (!btn) return;
        const tab = btn.getAttribute("data-toolbar-tab-btn") || "tool";
        switchToolbarTab(tab);
      });
      switchToolbarTab(state.toolbarTab || "tool", { silent: true });
    }

    function syncZoomControls() {
      const slider = document.getElementById("zoomSlider");
      const input = document.getElementById("zoomPercentInput");
      const pct = Math.round(Math.max(MIN_VIEW_SCALE, Math.min(MAX_VIEW_SCALE, Number(state.viewScale) || 1)) * 100);
      if (slider) slider.value = String(pct);
      if (input) input.value = String(pct);
    }

    function updateToolCursor() {
      const effective = getEffectiveTool();
      if (effective === "hand") {
        canvas.style.cursor = state.interaction && state.interaction.type === "pan" ? "grabbing" : "grab";
      } else if (state.hoverRotateReady && !state.interaction) {
        canvas.style.cursor = CURSOR_ROTATE;
      } else if (effective === "direct") {
        canvas.style.cursor = CURSOR_WHITE;
      } else {
        canvas.style.cursor = CURSOR_BLACK;
      }
      if (canvasWrapEl) {
        canvasWrapEl.classList.toggle("hand-mode", effective === "hand");
      }
    }

    function updateCropUi() {
      const cropBtn = document.getElementById("cropImageBtn");
      const applyBtn = document.getElementById("cropApplyBtn");
      const cancelBtn = document.getElementById("cropCancelBtn");
      const active = !!state.cropMode;
      if (cropBtn) cropBtn.textContent = active ? "Crop (Active)" : "Crop";
      if (applyBtn) {
        applyBtn.hidden = !active;
        applyBtn.disabled = !active || !state.cropMode?.draftRect;
      }
      if (cancelBtn) cancelBtn.hidden = !active;
    }

    function setCanvasSize(width, height, options = {}) {
      const w = Math.round(Number(width || 0));
      const h = Math.round(Number(height || 0));
      if (!Number.isFinite(w) || !Number.isFinite(h) || w < 200 || h < 150 || w > 8000 || h > 8000) {
        setStatus("Canvas size must be between 200x150 and 8000x8000.");
        return;
      }
      const { minX, minY } = getCanvasDimensions();
      applyCanvasMeta({ viewBox: `${minX} ${minY} ${w} ${h}` });
      requestSelectionVisualRefresh();
      if (options.push !== false) pushHistory("canvas-size");
      setStatus(`Canvas size set to ${w} x ${h}.`);
    }

    function promptCanvasSize() {
      const cur = getCanvasDimensions();
      const input = window.prompt("Canvas size (width,height)", `${Math.round(cur.width)},${Math.round(cur.height)}`);
      if (!input) return;
      const parts = input.split(/[x, ]+/).map((v) => Number(v.trim())).filter((v) => Number.isFinite(v));
      if (parts.length < 2) {
        setStatus("Invalid canvas size input.");
        return;
      }
      setCanvasSize(parts[0], parts[1], { push: true });
    }

    function closeAppMenus() {
      state.activeMenu = "";
      document.querySelectorAll(".menu-root.open").forEach((el) => el.classList.remove("open"));
    }

    function setupButtonTooltips() {
      const explicit = {
        toolSelect: "Select tool",
        toolDirect: "Direct select tool",
        matchArrowBtn: "Apply Arrow: selected line(s) get an arrowhead. Arrowhead height follows stroke width x3."
      };
      Object.entries(explicit).forEach(([id, text]) => {
        const el = document.getElementById(id);
        if (!(el instanceof HTMLButtonElement)) return;
        el.dataset.tooltip = text;
        el.setAttribute("title", text);
        if (!el.getAttribute("aria-label")) el.setAttribute("aria-label", text);
      });

      document.querySelectorAll("button").forEach((btn) => {
        if (!(btn instanceof HTMLButtonElement)) return;
        const cur = String(btn.getAttribute("title") || "").trim();
        if (cur) return;
        const aria = String(btn.getAttribute("aria-label") || "").trim();
        const label = aria || String(btn.textContent || "").replace(/\s+/g, " ").trim();
        if (label) {
          btn.dataset.tooltip = label;
          btn.setAttribute("title", label);
        }
      });

      document.querySelectorAll("button[title]").forEach((btn) => {
        if (!(btn instanceof HTMLButtonElement)) return;
        const t = String(btn.getAttribute("title") || "").trim();
        if (t && !btn.dataset.tooltip) btn.dataset.tooltip = t;
      });
    }

    function setupHoverTooltips() {
      const tooltip = document.createElement("div");
      tooltip.id = "uiTooltip";
      tooltip.setAttribute("role", "tooltip");
      document.body.appendChild(tooltip);

      let activeBtn = null;

      const hideTooltip = () => {
        tooltip.classList.remove("show");
        tooltip.style.transform = "translate(-9999px, -9999px)";
        activeBtn = null;
      };

      const placeTooltip = (x, y) => {
        const ox = 12;
        const oy = 14;
        tooltip.style.transform = "translate(-9999px, -9999px)";
        tooltip.classList.add("show");
        const rect = tooltip.getBoundingClientRect();
        const maxX = Math.max(8, window.innerWidth - rect.width - 8);
        const maxY = Math.max(8, window.innerHeight - rect.height - 8);
        const nx = Math.max(8, Math.min(maxX, Number(x || 0) + ox));
        const ny = Math.max(8, Math.min(maxY, Number(y || 0) + oy));
        tooltip.style.transform = `translate(${Math.round(nx)}px, ${Math.round(ny)}px)`;
      };

      const showTooltip = (btn, x, y) => {
        if (!(btn instanceof HTMLButtonElement) || btn.hidden) {
          hideTooltip();
          return;
        }
        const text = String(btn.dataset.tooltip || btn.getAttribute("title") || btn.getAttribute("aria-label") || "").trim();
        if (!text) {
          hideTooltip();
          return;
        }
        if (btn.hasAttribute("title")) btn.removeAttribute("title");
        tooltip.textContent = text;
        activeBtn = btn;
        placeTooltip(x, y);
      };

      document.addEventListener("pointerover", (e) => {
        const btn = e.target instanceof Element ? e.target.closest("button") : null;
        if (!(btn instanceof HTMLButtonElement)) {
          hideTooltip();
          return;
        }
        showTooltip(btn, e.clientX, e.clientY);
      });

      document.addEventListener("pointermove", (e) => {
        if (!activeBtn) return;
        placeTooltip(e.clientX, e.clientY);
      });

      document.addEventListener("pointerout", (e) => {
        if (!activeBtn) return;
        const to = e.relatedTarget instanceof Element ? e.relatedTarget.closest("button") : null;
        if (to === activeBtn) return;
        hideTooltip();
      });

      document.addEventListener("focusin", (e) => {
        const btn = e.target instanceof Element ? e.target.closest("button") : null;
        if (!(btn instanceof HTMLButtonElement)) return;
        const r = btn.getBoundingClientRect();
        showTooltip(btn, r.right, r.top);
      });

      document.addEventListener("focusout", () => {
        hideTooltip();
      });

      window.addEventListener("blur", hideTooltip);
      document.addEventListener("pointerdown", hideTooltip, true);
      document.addEventListener("scroll", hideTooltip, true);
    }

    function openAppMenu(name) {
      closeAppMenus();
      const root = document.querySelector(`.menu-root[data-menu-root="${CSS.escape(name)}"]`);
      if (!root) return;
      root.classList.add("open");
      state.activeMenu = name;
    }

    function toggleAppMenu(name) {
      if (!name) return;
      if (state.activeMenu === name) closeAppMenus();
      else openAppMenu(name);
    }

    function runMenuAction(action) {
      if (!action) return;
      if (action === "file.new") return newCanvas();
      if (action === "file.open") return void openSvgFile();
      if (action === "file.import") {
        const fileInput = document.getElementById("importFileInput");
        if (fileInput) fileInput.click();
        return;
      }
      if (action === "file.save") return void saveSvg();
      if (action === "file.saveAs") return void saveSvg({ saveAs: true });
      if (action === "file.pdf") return exportPdf();
      if (action === "edit.undo") return undo();
      if (action === "edit.redo") return redo();
      if (action === "edit.copy") return copySelected();
      if (action === "edit.copyImage") return copySelectedAsImage();
      if (action === "edit.cut") return cutSelected();
      if (action === "edit.paste") return pasteInternalClipboard();
      if (action === "edit.group") return groupSelected();
      if (action === "edit.ungroup") return ungroupSelected();
      if (action === "page.canvas.a4.portrait" || action === "view.canvas.a4.portrait") return setCanvasSize(794, 1123);
      if (action === "page.canvas.a4.landscape" || action === "view.canvas.a4.landscape") return setCanvasSize(1123, 794);
      if (action === "page.canvas.custom" || action === "view.canvas.custom") return promptCanvasSize();
      if (action === "maintenance.shortcuts" || action === "window.shortcuts") return showShortcutHelp();
      if (action === "maintenance.restore" || action === "window.restore") return restoreLatest();
      if (action === "maintenance.pasteReport" || action === "window.pasteReport") return showPasteReport();
      if (action === "maintenance.pasteReport.copy" || action === "window.pasteReport.copy") return copyPasteReport();
      if (action === "maintenance.pasteReport.save" || action === "window.pasteReport.save") return downloadPasteReport();
      if (action === "maintenance.pasteReport.history" || action === "window.pasteReport.history") return showPasteReportHistory();
      if (action === "maintenance.pasteReport.history.copy" || action === "window.pasteReport.history.copy") return copyPasteReportHistory();
      if (action === "maintenance.pasteReport.history.clear" || action === "window.pasteReport.history.clear") return clearPasteReportHistory();
    }

    function getSnapshot(reason = "", options = {}) {
      refreshAllGroupLabels();
      let markup = getCleanCanvasMarkup();
      if (options.useRefs) {
        markup = processMarkupForRefs(markup);
      }
      const snap = { markup, selectedIds: [...state.selectedIds], canvasMeta: getCanvasMeta(), at: Date.now(), reason };
      snap.sizeBytes = estimateSnapshotBytes(snap);
      return snap;
    }

    function updateHistoryButtons() {
      const undoBtn = document.getElementById("undoBtn");
      const redoBtn = document.getElementById("redoBtn");
      if (undoBtn) undoBtn.disabled = state.history.length <= 1;
      if (redoBtn) redoBtn.disabled = state.future.length === 0;
    }

    function pushHistory(reason, options = {}) {
      const snap = getSnapshot(reason, { useRefs: true });
      if (Number(snap.sizeBytes || 0) > MAX_HISTORY_SNAPSHOT_BYTES) {
        scheduleLiveAutosave(reason || "history-too-large");
        if (!state.historySizeWarned) {
          state.historySizeWarned = true;
          setStatus("History snapshot skipped: canvas is too large. Use Save SVG.");
        }
        return;
      }
      state.historySizeWarned = false;
      const last = state.history[state.history.length - 1];
      if (last && last.markup === snap.markup && JSON.stringify(last.selectedIds) === JSON.stringify(snap.selectedIds)) {
        scheduleLiveAutosave(reason || "history-nochange");
        return;
      }
      const sameSelection = last && JSON.stringify(last.selectedIds || []) === JSON.stringify(snap.selectedIds || []);
      if (options.coalesce && last && last.reason === reason && sameSelection) {
        const withinMs = Number(options.withinMs || 0);
        if (withinMs > 0 && Math.abs((snap.at || 0) - (last.at || 0)) > withinMs) {
          // outside the merge window: keep as a new history point
        } else {
          state.history[state.history.length - 1] = snap;
          state.future = [];
          updateHistoryButtons();
          scheduleLiveAutosave(reason || "history-coalesce");
          setStatus(`Saved state (${reason}).`);
          return;
        }
      }
      state.history.push(snap);
      if (state.history.length > state.maxHistory) state.history.shift();
      let totalBytes = state.history.reduce((sum, s) => sum + Number(s?.sizeBytes || estimateSnapshotBytes(s)), 0);
      while (state.history.length > 1 && totalBytes > MAX_HISTORY_TOTAL_BYTES) {
        const removed = state.history.shift();
        totalBytes -= Number(removed?.sizeBytes || estimateSnapshotBytes(removed));
      }
      garbageCollectImagePool();
      state.future = [];
      updateHistoryButtons();
      scheduleLiveAutosave(reason || "history");
      setStatus(`Saved state (${reason}).`);
    }

    function resetHistory(reason) {
      const snap = getSnapshot(reason, { useRefs: true });
      state.history = [snap];
      state.future = [];
      garbageCollectImagePool();
      updateHistoryButtons();
      scheduleLiveAutosave(reason || "reset-history");
    }

    function restoreSnapshot(snap) {
      if (!snap) return;
      cancelImageCropMode({ silent: true });
      applyCanvasMeta(snap.canvasMeta);
      applySnapshotMarkup(snap.markup, snap.imageRefs || null);
      assignIds();
      setSelection(snap.selectedIds || []);
      garbageCollectImagePool();
    }

    function undo() {
      if (state.history.length <= 1) {
        setStatus("Undo unavailable.");
        return;
      }
      const current = state.history.pop();
      state.future.push(current);
      restoreSnapshot(state.history[state.history.length - 1]);
      updateHistoryButtons();
      scheduleLiveAutosave("undo");
      setStatus("Undo.");
    }

    function redo() {
      if (!state.future.length) {
        setStatus("Redo unavailable.");
        return;
      }
      const next = state.future.pop();
      state.history.push(next);
      restoreSnapshot(next);
      updateHistoryButtons();
      scheduleLiveAutosave("redo");
      setStatus("Redo.");
    }

    function moveSelection(dx, dy, options = {}) {
      if (!state.selectedIds.length) return;
      for (const el of getTopSelectedElements()) {
        const t = getTranslate(el);
        setTranslate(el, t.x + dx, t.y + dy);
      }
      requestSelectionVisualRefresh();
      pushHistory(options.reason || "move", { coalesce: !!options.coalesce });
    }

    function alignSelected(mode) {
      const elements = getTopSelectedElements();
      if (elements.length < 2) {
        setStatus("Align needs 2+ selected objects.");
        return;
      }
      const bounds = elements.map(safeBBox).filter(Boolean);
      if (!bounds.length) return;
      let baseMinX = Math.min(...bounds.map((b) => b.x));
      let baseMaxX = Math.max(...bounds.map((b) => b.x + b.width));
      let baseMinY = Math.min(...bounds.map((b) => b.y));
      let baseMaxY = Math.max(...bounds.map((b) => b.y + b.height));
      let anchorEl = null;
      if (state.alignBasis === "first") {
        const firstId = state.selectedIds.find((id) => elements.some((el) => el.dataset.id === id));
        anchorEl = firstId ? getById(firstId) : elements[0];
        const anchorBox = anchorEl ? safeBBox(anchorEl) : null;
        if (anchorBox) {
          baseMinX = anchorBox.x;
          baseMaxX = anchorBox.x + anchorBox.width;
          baseMinY = anchorBox.y;
          baseMaxY = anchorBox.y + anchorBox.height;
        }
      }
      const centerX = (baseMinX + baseMaxX) / 2;
      const centerY = (baseMinY + baseMaxY) / 2;

      elements.forEach((el) => {
        if (state.alignBasis === "first" && anchorEl && el === anchorEl) return;
        const cur = safeBBox(el);
        if (!cur) return;
        const t = getTranslate(el);
        let dx = 0;
        let dy = 0;
        if (mode === "left") dx = baseMinX - cur.x;
        if (mode === "hcenter") dx = centerX - (cur.x + cur.width / 2);
        if (mode === "right") dx = baseMaxX - (cur.x + cur.width);
        if (mode === "top") dy = baseMinY - cur.y;
        if (mode === "vcenter") dy = centerY - (cur.y + cur.height / 2);
        if (mode === "bottom") dy = baseMaxY - (cur.y + cur.height);
        setTranslate(el, t.x + dx, t.y + dy);
      });
      applySelectionStyles();
      pushHistory(`align-${mode}-${state.alignBasis}`);
    }

    function distributeSelected(axis) {
      const elements = getTopSelectedElements();
      if (elements.length < 3) {
        setStatus("Distribute needs 3+ selected objects.");
        return;
      }
      const items = elements.map((el) => {
        const b = safeBBox(el);
        return b ? { el, b } : null;
      }).filter(Boolean);
      if (items.length < 3) {
        setStatus("Distribute needs 3+ measurable objects.");
        return;
      }

      if (axis === "h") {
        items.sort((a, b) => a.b.x - b.b.x);
        const start = items[0].b.x;
        const end = items[items.length - 1].b.x + items[items.length - 1].b.width;
        const totalSize = items.reduce((sum, item) => sum + item.b.width, 0);
        const gap = (end - start - totalSize) / (items.length - 1);
        let cursor = start;
        items.forEach((item) => {
          const t = getTranslate(item.el);
          const dx = cursor - item.b.x;
          setTranslate(item.el, t.x + dx, t.y);
          cursor += item.b.width + gap;
        });
      } else {
        items.sort((a, b) => a.b.y - b.b.y);
        const start = items[0].b.y;
        const end = items[items.length - 1].b.y + items[items.length - 1].b.height;
        const totalSize = items.reduce((sum, item) => sum + item.b.height, 0);
        const gap = (end - start - totalSize) / (items.length - 1);
        let cursor = start;
        items.forEach((item) => {
          const t = getTranslate(item.el);
          const dy = cursor - item.b.y;
          setTranslate(item.el, t.x, t.y + dy);
          cursor += item.b.height + gap;
        });
      }

      applySelectionStyles();
      pushHistory(`distribute-${axis}`);
    }

    function groupSelected() {
      const elements = getTopSelectedElements();
      if (elements.length < 2) {
        setStatus("Group needs 2+ selected objects.");
        return;
      }
      const parent = elements[0].parentNode;
      if (!elements.every((el) => el.parentNode === parent)) {
        setStatus("Group requires same parent level.");
        return;
      }
      const g = document.createElementNS(SVG_NS, "g");
      ensureId(g);
      setTranslate(g, 0, 0);
      parent.insertBefore(g, elements[0]);
      elements.forEach((el) => g.appendChild(el));
      setSelection([g.dataset.id]);
      pushHistory("group");
    }

    function reparentChildPreserveWorldTransform(child, newParent, worldMatrix = null) {
      if (!(child instanceof SVGElement) || !(newParent instanceof SVGElement)) return;
      const childMatrix = worldMatrix || (child.getScreenCTM ? child.getScreenCTM() : null);
      const parentMatrix = newParent.getScreenCTM ? newParent.getScreenCTM() : null;
      if (!childMatrix || !parentMatrix || typeof parentMatrix.inverse !== "function" || typeof parentMatrix.multiply !== "function") return;
      let relative;
      try {
        relative = parentMatrix.inverse().multiply(childMatrix);
      } catch (_) {
        return;
      }
      if (!relative) return;
      const toNum = (v) => Number(Number(v || 0).toFixed(8));
      child.setAttribute(
        "transform",
        `matrix(${toNum(relative.a)} ${toNum(relative.b)} ${toNum(relative.c)} ${toNum(relative.d)} ${toNum(relative.e)} ${toNum(relative.f)})`
      );
      child.removeAttribute("data-base-transform");
      child.removeAttribute("data-tx");
      child.removeAttribute("data-ty");
      ensureTransformState(child);
    }

    function ungroupSelected() {
      const groups = getTopSelectedElements().filter((el) => el.tagName === "g");
      if (!groups.length) {
        setStatus("Ungroup needs selected group.");
        return;
      }
      const selected = [];
      groups.forEach((g) => {
        const parent = g.parentNode;
        const children = Array.from(g.childNodes);
        children.forEach((child) => {
          if (child instanceof SVGElement && isGroupLabel(child)) {
            child.remove();
            return;
          }
          const preserve = child instanceof SVGElement ? (child.getScreenCTM ? child.getScreenCTM() : null) : null;
          parent.insertBefore(child, g);
          reparentChildPreserveWorldTransform(child, parent, preserve);
          if (child instanceof SVGElement && child.dataset.id) selected.push(child.dataset.id);
        });
        g.remove();
      });
      setSelection(selected);
      pushHistory("ungroup");
    }

    function duplicateSelected() {
      const elements = getTopSelectedElements();
      if (!elements.length) {
        setStatus("Duplicate needs selected object.");
        return;
      }
      const clones = cloneElements(elements, { offsetX: 20, offsetY: 20, stripGroupLabels: false });
      setSelection(clones);
      pushHistory("duplicate");
      setStatus(`Duplicated ${clones.length} object(s).`);
    }

    function collectSelectedClipboardItems() {
      const elements = getTopSelectedElements();
      if (!elements.length) return [];
      return elements.map((el) => ({
        markup: serializeElementForClipboard(el),
        parentId: el.parentElement instanceof SVGElement ? el.parentElement.dataset.id || "" : ""
      }));
    }

    function serializeElementForClipboard(el) {
      const clone = el.cloneNode(true);
      if (clone instanceof SVGElement) {
        clone.querySelectorAll?.('[data-fm-group-label="1"]').forEach((n) => n.remove());
        clone.classList.remove("fm-selected");
        clone.classList.remove("fm-group-selected");
        clone.querySelectorAll(".fm-selected,.fm-group-selected,.selection-outline,.selection-handle,.marquee,.smart-guide").forEach((n) => {
          if (n instanceof SVGElement) {
            n.classList.remove("fm-selected");
            n.classList.remove("fm-group-selected");
            if (isHelperElement(n)) n.remove();
          }
        });
      }
      return clone.outerHTML;
    }

    function buildSelectedSvgClipboardText(items) {
      if (!items || !items.length) return "";
      const { minX, minY, width, height } = getCanvasDimensions();
      const body = items.map((it) => String(it.markup || "")).join("");
      return `<svg xmlns="${SVG_NS}" xmlns:xlink="${XLINK_NS}" viewBox="${minX} ${minY} ${width} ${height}" width="${width}" height="${height}">${body}</svg>`;
    }

    async function copySelectedAsImage() {
      const elements = getTopSelectedElements();
      if (!elements.length) {
        setStatus("Select object(s) to copy for Excel.");
        return;
      }
      
      // Calculate bounds of selection
      const boxes = elements.map(safeBBox).filter(Boolean);
      const bounds = combineBoxes(boxes);
      if (!bounds || bounds.width <= 0 || bounds.height <= 0) return;

      setStatus("Rendering for Excel/PPT...");

      // Create a temporary SVG string of just the selected items
      // We need to bake styles and ensure it's standalone
      const cloneContainer = document.createElement("div");
      const tempSvg = document.createElementNS(SVG_NS, "svg");
      // Add generous padding to avoid clipping strokes
      const padding = 10;
      tempSvg.setAttribute("viewBox", `${bounds.x - padding} ${bounds.y - padding} ${bounds.width + padding * 2} ${bounds.height + padding * 2}`);
      tempSvg.setAttribute("width", String(bounds.width + padding * 2));
      tempSvg.setAttribute("height", String(bounds.height + padding * 2));
      tempSvg.setAttribute("xmlns", SVG_NS);
      
      // Clone elements into temp SVG
      // Need to handle defs (markers) if arrows are selected
      const defs = ensureCanvasDefs().cloneNode(true);
      tempSvg.appendChild(defs);
      
      elements.forEach(el => {
        const clone = el.cloneNode(true);
        // Clean up UI-specific classes if any
        clone.classList.remove("fm-selected", "fm-group-selected");
        tempSvg.appendChild(clone);
      });
      
      const svgString = new XMLSerializer().serializeToString(tempSvg);
      
      // Render to Canvas at High DPI (3x = ~300dpi visual feel)
      const scale = 3;
      const canvasTmp = document.createElement("canvas");
      canvasTmp.width = (bounds.width + padding * 2) * scale;
      canvasTmp.height = (bounds.height + padding * 2) * scale;
      const ctx = canvasTmp.getContext("2d");
      
      if (!window.canvg || !window.canvg.Canvg) {
        setStatus("Error: canvg library missing.");
        return;
      }

      try {
        const v = await window.canvg.Canvg.fromString(ctx, svgString, {
          ignoreMouse: true,
          ignoreAnimation: true,
          scaleWidth: canvasTmp.width,
          scaleHeight: canvasTmp.height
        });
        await v.render();
        
        canvasTmp.toBlob(async (blob) => {
          if (!blob) {
            setStatus("Failed to create image blob.");
            return;
          }
          try {
            const item = new ClipboardItem({ "image/png": blob });
            await navigator.clipboard.write([item]);
            setStatus("Copied as Image (Excel/PPT safe).");
          } catch (err) {
            setStatus("Clipboard write failed: " + err.message);
          }
        }, "image/png");
      } catch (e) {
        console.error(e);
        setStatus("Rendering failed.");
      }
    }

    async function copySelectedToSystemClipboard(items) {
      if (!navigator.clipboard?.writeText) return false;
      const text = buildSelectedSvgClipboardText(items);
      if (!text) return false;
      try {
        await navigator.clipboard.writeText(text);
        return true;
      } catch (_) {
        return false;
      }
    }

    function copySelected() {
      const items = collectSelectedClipboardItems();
      if (!items.length) {
        setStatus("Copy needs selected object.");
        return;
      }
      state.clipboardItems = items;
      copySelectedToSystemClipboard(items).then((ok) => {
        if (ok) {
          setStatus(`Copied ${items.length} object(s) to internal + system clipboard.`);
        } else {
          setStatus(`Copied ${items.length} object(s).`);
        }
      });
    }

    function cutSelected() {
      const elements = getTopSelectedElements();
      if (!elements.length) {
        setStatus("Cut needs selected object.");
        return;
      }
      copySelected();
      elements.forEach((el) => el.remove());
      clearSelection();
      pushHistory("cut");
    }

    function resolvePasteParent(parentId) {
      if (!parentId) return canvas;
      const parent = getById(parentId);
      if (parent instanceof SVGElement && (parent === canvas || parent.tagName === "g")) return parent;
      return canvas;
    }

    function toParentLocalDelta(parentEl, dx, dy) {
      if (!(parentEl instanceof SVGElement) || parentEl === canvas) return { dx, dy };
      const parentCTM = parentEl.getScreenCTM ? parentEl.getScreenCTM() : null;
      const canvasCTM = canvas.getScreenCTM ? canvas.getScreenCTM() : null;
      if (!parentCTM || !canvasCTM) return { dx, dy };
      try {
        const p0 = canvas.createSVGPoint();
        const p1 = canvas.createSVGPoint();
        p0.x = 0;
        p0.y = 0;
        p1.x = dx;
        p1.y = dy;
        const s0 = p0.matrixTransform(canvasCTM);
        const s1 = p1.matrixTransform(canvasCTM);
        const invParent = parentCTM.inverse();
        const l0 = s0.matrixTransform(invParent);
        const l1 = s1.matrixTransform(invParent);
        return { dx: l1.x - l0.x, dy: l1.y - l0.y };
      } catch (_) {
        return { dx, dy };
      }
    }

    function fromParentLocalDelta(parentEl, dx, dy) {
      if (!(parentEl instanceof SVGElement) || parentEl === canvas) return { dx, dy };
      const parentCTM = parentEl.getScreenCTM ? parentEl.getScreenCTM() : null;
      const canvasCTM = canvas.getScreenCTM ? canvas.getScreenCTM() : null;
      if (!parentCTM || !canvasCTM) return { dx, dy };
      try {
        const p0 = canvas.createSVGPoint();
        const p1 = canvas.createSVGPoint();
        p0.x = 0;
        p0.y = 0;
        p1.x = dx;
        p1.y = dy;
        const s0 = p0.matrixTransform(parentCTM);
        const s1 = p1.matrixTransform(parentCTM);
        const invCanvas = canvasCTM.inverse();
        const c0 = s0.matrixTransform(invCanvas);
        const c1 = s1.matrixTransform(invCanvas);
        return { dx: c1.x - c0.x, dy: c1.y - c0.y };
      } catch (_) {
        return { dx, dy };
      }
    }

    function canvasPointToParentLocal(parentEl, x, y) {
      if (!(parentEl instanceof SVGElement) || parentEl === canvas) return { x, y };
      const parentCTM = parentEl.getScreenCTM ? parentEl.getScreenCTM() : null;
      const canvasCTM = canvas.getScreenCTM ? canvas.getScreenCTM() : null;
      if (!parentCTM || !canvasCTM) return { x, y };
      try {
        const p = canvas.createSVGPoint();
        p.x = x;
        p.y = y;
        const screen = p.matrixTransform(canvasCTM);
        const local = screen.matrixTransform(parentCTM.inverse());
        return { x: local.x, y: local.y };
      } catch (_) {
        return { x, y };
      }
    }

    function canvasPointToElementLocal(el, x, y) {
      if (!(el instanceof SVGElement) || el === canvas) return { x, y };
      const elCTM = el.getScreenCTM ? el.getScreenCTM() : null;
      const canvasCTM = canvas.getScreenCTM ? canvas.getScreenCTM() : null;
      if (!elCTM || !canvasCTM) return { x, y };
      try {
        const p = canvas.createSVGPoint();
        p.x = x;
        p.y = y;
        const screen = p.matrixTransform(canvasCTM);
        const local = screen.matrixTransform(elCTM.inverse());
        return { x: local.x, y: local.y };
      } catch (_) {
        return { x, y };
      }
    }

    function shouldUseTransformResize(el) {
      if (!(el instanceof SVGElement) || el === canvas) return false;
      if (el.tagName === "g") return true;
      const base = String(el.dataset.baseTransform || "").trim();
      if (base) return true;
      const raw = String(el.getAttribute("transform") || "").trim();
      return !!raw && !/^translate\(\s*[-+]?\d*\.?\d+(?:e[-+]?\d+)?(?:[\s,]+[-+]?\d*\.?\d+(?:e[-+]?\d+)?)?\s*\)$/i.test(raw);
    }

    function applyResizeByTransform(el, oldBox, newBox, baseTransformOverride = null) {
      if (!(el instanceof SVGElement)) return false;
      const sx = newBox.width / Math.max(oldBox.width, 1e-6);
      const sy = newBox.height / Math.max(oldBox.height, 1e-6);
      if (!Number.isFinite(sx) || !Number.isFinite(sy) || sx <= 0 || sy <= 0) return false;
      const parent = el.parentNode instanceof SVGElement ? el.parentNode : canvas;
      const oldOrigin = canvasPointToParentLocal(parent, oldBox.x, oldBox.y);
      const newOrigin = canvasPointToParentLocal(parent, newBox.x, newBox.y);
      const current = baseTransformOverride === null ? String(el.getAttribute("transform") || "").trim() : String(baseTransformOverride || "").trim();
      const prefix = `translate(${newOrigin.x},${newOrigin.y}) scale(${sx},${sy}) translate(${-oldOrigin.x},${-oldOrigin.y})`;
      el.dataset.baseTransform = `${prefix}${current ? ` ${current}` : ""}`.trim();
      el.dataset.tx = "0";
      el.dataset.ty = "0";
      setTranslate(el, 0, 0);
      return true;
    }

    function identityTransformMatrix() {
      return { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 };
    }

    function matrixFromSvgMatrix(m) {
      if (!m) return identityTransformMatrix();
      const a = Number(m.a);
      const b = Number(m.b);
      const c = Number(m.c);
      const d = Number(m.d);
      const e = Number(m.e);
      const f = Number(m.f);
      if (![a, b, c, d, e, f].every(Number.isFinite)) return identityTransformMatrix();
      return { a, b, c, d, e, f };
    }

    function matrixFromTransformString(raw) {
      const text = String(raw || "").trim();
      if (!text) return identityTransformMatrix();
      try {
        const temp = document.createElementNS(SVG_NS, "g");
        temp.setAttribute("transform", text);
        const list = temp.transform?.baseVal;
        if (!list || !list.numberOfItems) return identityTransformMatrix();
        const consolidated = list.consolidate();
        return matrixFromSvgMatrix(consolidated?.matrix);
      } catch (_) {
        return identityTransformMatrix();
      }
    }

    function multiplyTransformMatrices(left, right) {
      return {
        a: left.a * right.a + left.c * right.b,
        b: left.b * right.a + left.d * right.b,
        c: left.a * right.c + left.c * right.d,
        d: left.b * right.c + left.d * right.d,
        e: left.a * right.e + left.c * right.f + left.e,
        f: left.b * right.e + left.d * right.f + left.f
      };
    }

    function isIdentityTransformMatrix(m, eps = 1e-8) {
      return (
        Math.abs(m.a - 1) < eps &&
        Math.abs(m.b) < eps &&
        Math.abs(m.c) < eps &&
        Math.abs(m.d - 1) < eps &&
        Math.abs(m.e) < eps &&
        Math.abs(m.f) < eps
      );
    }

    function isAxisAlignedTransformMatrix(m, eps = 1e-8) {
      return Math.abs(m.b) < eps && Math.abs(m.c) < eps;
    }

    function transformPointByMatrix(m, x, y) {
      const nx = m.a * x + m.c * y + m.e;
      const ny = m.b * x + m.d * y + m.f;
      return { x: nx, y: ny };
    }

    function transformScaleX(m) {
      return Math.hypot(m.a, m.b);
    }

    function transformScaleY(m) {
      return Math.hypot(m.c, m.d);
    }

    function toNumString(value, digits = 4) {
      const n = Number(value || 0);
      if (!Number.isFinite(n)) return "0";
      return String(Number(n.toFixed(digits)));
    }

    function toMatrixTransformString(m, digits = 8) {
      return `matrix(${toNumString(m.a, digits)} ${toNumString(m.b, digits)} ${toNumString(m.c, digits)} ${toNumString(m.d, digits)} ${toNumString(m.e, digits)} ${toNumString(m.f, digits)})`;
    }

    function setElementMatrixTransform(el, matrix) {
      if (!(el instanceof SVGElement) || el === canvas) return;
      if (isIdentityTransformMatrix(matrix)) el.removeAttribute("transform");
      else el.setAttribute("transform", toMatrixTransformString(matrix));
      el.removeAttribute("data-base-transform");
      el.removeAttribute("data-tx");
      el.removeAttribute("data-ty");
      ensureTransformState(el);
    }

    function clearElementTransformState(el) {
      if (!(el instanceof SVGElement) || el === canvas) return;
      el.removeAttribute("transform");
      el.dataset.baseTransform = "";
      el.dataset.tx = "0";
      el.dataset.ty = "0";
    }

    function getAttrNumber(el, name, fallback = 0) {
      const raw = String(el.getAttribute(name) || "").trim();
      if (!raw) return fallback;
      const first = raw.split(/[\s,]+/).find((v) => v.length);
      const n = Number(first);
      return Number.isFinite(n) ? n : fallback;
    }

    function transformPathDataByMatrix(d, matrix) {
      const tokens = [];
      const re = /([a-zA-Z])|([-+]?\d*\.?\d+(?:e[-+]?\d+)?)/g;
      let m;
      while ((m = re.exec(String(d || ""))) !== null) {
        if (m[1]) tokens.push({ type: "cmd", value: m[1] });
        else tokens.push({ type: "num", value: Number(m[2]) });
      }
      if (!tokens.length) return "";
      const out = [];
      let i = 0;
      let cmd = "";
      let cx = 0;
      let cy = 0;
      let sx = 0;
      let sy = 0;
      const hasNums = (count) => {
        if (i + count > tokens.length) return false;
        for (let k = 0; k < count; k += 1) {
          if (tokens[i + k].type !== "num") return false;
        }
        return true;
      };
      const readNum = () => {
        if (i >= tokens.length || tokens[i].type !== "num") return null;
        return tokens[i++].value;
      };
      const emit = (c, vals = []) => {
        out.push(c);
        vals.forEach((v) => out.push(toNumString(v)));
      };
      const det = matrix.a * matrix.d - matrix.b * matrix.c;
      const canTransformArc = isAxisAlignedTransformMatrix(matrix);
      while (i < tokens.length) {
        const loopStart = i;
        if (tokens[i].type === "cmd") {
          cmd = tokens[i].value;
          i += 1;
        } else if (!cmd) {
          break;
        }
        const lower = cmd.toLowerCase();
        const rel = cmd === lower;
        if (lower === "z") {
          emit("Z");
          cx = sx;
          cy = sy;
          if (i === loopStart) break;
          continue;
        }
        if (lower === "m") {
          let first = true;
          while (hasNums(2)) {
            let x = readNum();
            let y = readNum();
            if (rel) {
              x += cx;
              y += cy;
            }
            const p = transformPointByMatrix(matrix, x, y);
            emit(first ? "M" : "L", [p.x, p.y]);
            cx = x;
            cy = y;
            if (first) {
              sx = x;
              sy = y;
              first = false;
            }
          }
          if (i === loopStart) break;
          continue;
        }
        if (lower === "l") {
          while (hasNums(2)) {
            let x = readNum();
            let y = readNum();
            if (rel) {
              x += cx;
              y += cy;
            }
            const p = transformPointByMatrix(matrix, x, y);
            emit("L", [p.x, p.y]);
            cx = x;
            cy = y;
          }
          if (i === loopStart) break;
          continue;
        }
        if (lower === "h") {
          while (hasNums(1)) {
            let x = readNum();
            if (rel) x += cx;
            const p = transformPointByMatrix(matrix, x, cy);
            emit("L", [p.x, p.y]);
            cx = x;
          }
          if (i === loopStart) break;
          continue;
        }
        if (lower === "v") {
          while (hasNums(1)) {
            let y = readNum();
            if (rel) y += cy;
            const p = transformPointByMatrix(matrix, cx, y);
            emit("L", [p.x, p.y]);
            cy = y;
          }
          if (i === loopStart) break;
          continue;
        }
        if (lower === "c") {
          while (hasNums(6)) {
            let x1 = readNum(); let y1 = readNum();
            let x2 = readNum(); let y2 = readNum();
            let x = readNum(); let y = readNum();
            if (rel) {
              x1 += cx; y1 += cy;
              x2 += cx; y2 += cy;
              x += cx; y += cy;
            }
            const p1 = transformPointByMatrix(matrix, x1, y1);
            const p2 = transformPointByMatrix(matrix, x2, y2);
            const p = transformPointByMatrix(matrix, x, y);
            emit("C", [p1.x, p1.y, p2.x, p2.y, p.x, p.y]);
            cx = x;
            cy = y;
          }
          if (i === loopStart) break;
          continue;
        }
        if (lower === "s") {
          while (hasNums(4)) {
            let x2 = readNum(); let y2 = readNum();
            let x = readNum(); let y = readNum();
            if (rel) {
              x2 += cx; y2 += cy;
              x += cx; y += cy;
            }
            const p2 = transformPointByMatrix(matrix, x2, y2);
            const p = transformPointByMatrix(matrix, x, y);
            emit("S", [p2.x, p2.y, p.x, p.y]);
            cx = x;
            cy = y;
          }
          if (i === loopStart) break;
          continue;
        }
        if (lower === "q") {
          while (hasNums(4)) {
            let x1 = readNum(); let y1 = readNum();
            let x = readNum(); let y = readNum();
            if (rel) {
              x1 += cx; y1 += cy;
              x += cx; y += cy;
            }
            const p1 = transformPointByMatrix(matrix, x1, y1);
            const p = transformPointByMatrix(matrix, x, y);
            emit("Q", [p1.x, p1.y, p.x, p.y]);
            cx = x;
            cy = y;
          }
          if (i === loopStart) break;
          continue;
        }
        if (lower === "t") {
          while (hasNums(2)) {
            let x = readNum();
            let y = readNum();
            if (rel) {
              x += cx;
              y += cy;
            }
            const p = transformPointByMatrix(matrix, x, y);
            emit("T", [p.x, p.y]);
            cx = x;
            cy = y;
          }
          if (i === loopStart) break;
          continue;
        }
        if (lower === "a") {
          if (!canTransformArc) return "";
          while (hasNums(7)) {
            const rx = readNum();
            const ry = readNum();
            const xAxisRotation = readNum();
            const largeArc = readNum();
            let sweep = readNum();
            let x = readNum();
            let y = readNum();
            if (rel) {
              x += cx;
              y += cy;
            }
            const sxScale = Math.max(1e-6, transformScaleX(matrix));
            const syScale = Math.max(1e-6, transformScaleY(matrix));
            const p = transformPointByMatrix(matrix, x, y);
            if (det < 0) sweep = sweep ? 0 : 1;
            emit("A", [
              Math.max(0.5, Math.abs(rx * sxScale)),
              Math.max(0.5, Math.abs(ry * syScale)),
              xAxisRotation,
              largeArc ? 1 : 0,
              sweep ? 1 : 0,
              p.x,
              p.y
            ]);
            cx = x;
            cy = y;
          }
          if (i === loopStart) break;
          continue;
        }
        break;
      }
      return out.join(" ");
    }

    function bakeGeometryByMatrix(el, matrix) {
      if (!(el instanceof SVGElement)) return false;
      if (isIdentityTransformMatrix(matrix)) return true;
      if (el.tagName === "line") {
        const x1 = getAttrNumber(el, "x1");
        const y1 = getAttrNumber(el, "y1");
        const x2 = getAttrNumber(el, "x2");
        const y2 = getAttrNumber(el, "y2");
        const p1 = transformPointByMatrix(matrix, x1, y1);
        const p2 = transformPointByMatrix(matrix, x2, y2);
        el.setAttribute("x1", toNumString(p1.x));
        el.setAttribute("y1", toNumString(p1.y));
        el.setAttribute("x2", toNumString(p2.x));
        el.setAttribute("y2", toNumString(p2.y));
        return true;
      }
      if (el.tagName === "polygon" || el.tagName === "polyline") {
        const points = parseSvgPoints(el.getAttribute("points"));
        if (!points.length) return true;
        const mapped = points.map((p) => transformPointByMatrix(matrix, p.x, p.y));
        el.setAttribute("points", formatSvgPoints(mapped));
        return true;
      }
      if (el.tagName === "path") {
        const d = String(el.getAttribute("d") || "");
        if (!d) return true;
        const mappedD = transformPathDataByMatrix(d, matrix);
        if (!mappedD) return false;
        el.setAttribute("d", mappedD);
        return true;
      }
      if (el.tagName === "rect" || el.tagName === "image" || el.tagName === "foreignObject" || el.tagName === "use") {
        if (!isAxisAlignedTransformMatrix(matrix)) return false;
        const x = getAttrNumber(el, "x", 0);
        const y = getAttrNumber(el, "y", 0);
        const w = Math.max(0, getAttrNumber(el, "width", 0));
        const h = Math.max(0, getAttrNumber(el, "height", 0));
        const corners = [
          transformPointByMatrix(matrix, x, y),
          transformPointByMatrix(matrix, x + w, y),
          transformPointByMatrix(matrix, x, y + h),
          transformPointByMatrix(matrix, x + w, y + h)
        ];
        const minX = Math.min(...corners.map((p) => p.x));
        const minY = Math.min(...corners.map((p) => p.y));
        const maxX = Math.max(...corners.map((p) => p.x));
        const maxY = Math.max(...corners.map((p) => p.y));
        el.setAttribute("x", toNumString(minX));
        el.setAttribute("y", toNumString(minY));
        el.setAttribute("width", toNumString(Math.max(1e-6, maxX - minX)));
        el.setAttribute("height", toNumString(Math.max(1e-6, maxY - minY)));
        if (el.tagName === "rect") {
          const sx = Math.max(1e-6, transformScaleX(matrix));
          const sy = Math.max(1e-6, transformScaleY(matrix));
          const rx = getAttrNumber(el, "rx", NaN);
          const ry = getAttrNumber(el, "ry", NaN);
          if (Number.isFinite(rx)) el.setAttribute("rx", toNumString(Math.max(0, rx * sx)));
          if (Number.isFinite(ry)) el.setAttribute("ry", toNumString(Math.max(0, ry * sy)));
        }
        return true;
      }
      if (el.tagName === "ellipse") {
        if (!isAxisAlignedTransformMatrix(matrix)) return false;
        const cx = getAttrNumber(el, "cx");
        const cy = getAttrNumber(el, "cy");
        const rx = Math.max(0, getAttrNumber(el, "rx"));
        const ry = Math.max(0, getAttrNumber(el, "ry"));
        const center = transformPointByMatrix(matrix, cx, cy);
        const sx = Math.max(1e-6, transformScaleX(matrix));
        const sy = Math.max(1e-6, transformScaleY(matrix));
        el.setAttribute("cx", toNumString(center.x));
        el.setAttribute("cy", toNumString(center.y));
        el.setAttribute("rx", toNumString(Math.max(0.5, rx * sx)));
        el.setAttribute("ry", toNumString(Math.max(0.5, ry * sy)));
        return true;
      }
      if (el.tagName === "circle") {
        if (!isAxisAlignedTransformMatrix(matrix)) return false;
        const cx = getAttrNumber(el, "cx");
        const cy = getAttrNumber(el, "cy");
        const r = Math.max(0, getAttrNumber(el, "r"));
        const center = transformPointByMatrix(matrix, cx, cy);
        const sx = Math.max(1e-6, transformScaleX(matrix));
        const sy = Math.max(1e-6, transformScaleY(matrix));
        const nr = Math.max(0.5, r * ((sx + sy) / 2));
        el.setAttribute("cx", toNumString(center.x));
        el.setAttribute("cy", toNumString(center.y));
        el.setAttribute("r", toNumString(nr));
        return true;
      }
      if (el.tagName === "text") {
        const x = getAttrNumber(el, "x");
        const y = getAttrNumber(el, "y");
        const p = transformPointByMatrix(matrix, x, y);
        el.setAttribute("x", toNumString(p.x));
        el.setAttribute("y", toNumString(p.y));
        if (isGroupLabel(el)) {
          if (el.dataset?.id) delete state.markLabelComp[el.dataset.id];
          const baseSize = Number(el.dataset.markBaseSize || el.getAttribute("font-size") || "");
          if (Number.isFinite(baseSize) && baseSize > 0) {
            const locked = Math.max(6, Math.round(baseSize));
            el.dataset.markBaseSize = String(locked);
            el.setAttribute("font-size", String(locked));
            el.style.setProperty("font-size", `${locked}px`);
          }
          return true;
        }
        if (!isAxisAlignedTransformMatrix(matrix)) return false;
        const fsRaw = Number(el.getAttribute("font-size") || Number.parseFloat(window.getComputedStyle(el).fontSize || ""));
        if (Number.isFinite(fsRaw) && fsRaw > 0) {
          const sx = Math.max(1e-6, transformScaleX(matrix));
          const sy = Math.max(1e-6, transformScaleY(matrix));
          el.setAttribute("font-size", toNumString(Math.max(1, fsRaw * ((sx + sy) / 2))));
        }
        return true;
      }
      return false;
    }

    function bakeElementTransformTree(el, inheritedMatrix = null) {
      if (!(el instanceof SVGElement) || el === canvas || isHelperElement(el)) return true;
      const parentMatrix = inheritedMatrix || identityTransformMatrix();
      const ownRaw = String(el.getAttribute("transform") || "").trim();
      const ownMatrix = ownRaw ? matrixFromTransformString(ownRaw) : identityTransformMatrix();
      const combined = multiplyTransformMatrices(parentMatrix, ownMatrix);
      if (el.tagName === "g") {
        Array.from(el.children).forEach((child) => {
          if (!(child instanceof SVGElement)) return;
          bakeElementTransformTree(child, combined);
        });
        clearElementTransformState(el);
        return true;
      }
      const baked = bakeGeometryByMatrix(el, combined);
      if (baked) {
        clearElementTransformState(el);
        return true;
      }
      setElementMatrixTransform(el, combined);
      return false;
    }

    function bakeTransformsAfterInteraction(elements) {
      const targets = (Array.isArray(elements) ? elements : [])
        .filter((el) => el instanceof SVGElement)
        .filter((el) => el.isConnected)
        .filter((el, idx, arr) => arr.indexOf(el) === idx);
      if (!targets.length) return;
      targets.forEach((el) => bakeElementTransformTree(el, identityTransformMatrix()));
      requestSelectionVisualRefresh();
    }

    function importMarkupFragment(markup, offsetX = 0, offsetY = 0, parentId = "") {
      const parserDoc = new DOMParser().parseFromString(`<svg xmlns="${SVG_NS}">${markup}</svg>`, "image/svg+xml");
      if (parserDoc.querySelector("parsererror")) return "";
      const tempRoot = parserDoc.querySelector("svg");
      const node = tempRoot?.firstElementChild;
      if (!(node instanceof SVGElement)) return "";
      const imported = document.importNode(node, true);
      sanitizeSvgTree(imported);
      imported.removeAttribute("data-id");
      imported.querySelectorAll("[data-id]").forEach((n) => n.removeAttribute("data-id"));
      ensureId(imported);
      ensureTransformState(imported);
      const pasteParent = resolvePasteParent(parentId);
      const delta = toParentLocalDelta(pasteParent, offsetX, offsetY);
      const t = getTranslate(imported);
      setTranslate(imported, t.x + delta.dx, t.y + delta.dy);
      pasteParent.appendChild(imported);
      assignIds(imported);
      return imported.dataset.id || "";
    }

    function pasteInternalClipboard() {
      const items = state.clipboardItems || [];
      if (!items.length) {
        setStatus("Clipboard is empty.");
        return false;
      }
      const baseNudge = getPasteNudgeOffset();
      const inserted = [];
      items.forEach((item, idx) => {
        const id = importMarkupFragment(
          item.markup,
          baseNudge.x + 24 * (idx + 1),
          baseNudge.y + 24 * (idx + 1),
          item.parentId || ""
        );
        if (id) inserted.push(id);
      });
      if (!inserted.length) {
        setStatus("Clipboard paste failed.");
        return false;
      }
      setSelection(inserted);
      pushHistory("paste-internal");
      setStatus(`Pasted ${inserted.length} object(s).`);
      return true;
    }

    function getMarkFontSizeValue() {
      const input = document.getElementById("markFontSizeInput");
      const raw = Number(input?.value || 16);
      const size = Math.max(6, Math.min(120, Number.isFinite(raw) ? raw : 16));
      if (input) input.value = String(Math.round(size));
      return Math.round(size);
    }

    function applyGlobalMarkFontSize(options = {}) {
      const push = options.push !== false;
      const withStatus = options.withStatus !== false;
      const size = getMarkFontSizeValue();
      const labels = Array.from(canvas.querySelectorAll('[data-fm-group-label="1"], .fm-group-label')).filter((n) => n instanceof SVGElement);
      labels.forEach((label) => {
        if (!label.getAttribute("data-fm-group-label")) label.setAttribute("data-fm-group-label", "1");
        label.classList.add("fm-group-label");
        label.setAttribute("font-size", String(size));
        label.style.setProperty("font-size", `${size}px`);
        label.dataset.markBaseSize = String(size);
        if (label.dataset?.id) applyMarkLabelCompensation(label);
      });
      if (push && labels.length) pushHistory("mark-size");
      if (withStatus) setStatus(labels.length ? `Mark size set: ${size}` : "No mark labels to resize.");
      requestSelectionVisualRefresh();
    }

    function getExistingMarkLabelForTarget(targetEl) {
      if (!(targetEl instanceof SVGElement) || !targetEl.dataset?.id) return null;
      const id = targetEl.dataset.id;
      const byLinked = canvas.querySelector(`:scope > [data-fm-group-label="1"][data-fm-mark-target-id="${CSS.escape(id)}"]`);
      if (byLinked instanceof SVGElement) return byLinked;
      if (targetEl.tagName === "g") {
        const legacy = targetEl.querySelector(':scope > [data-fm-group-label="1"]');
        if (legacy instanceof SVGElement) return legacy;
      }
      return null;
    }

    function addOrReplaceMarkLabel(targetEl, letter) {
      if (!(targetEl instanceof SVGElement) || !targetEl.dataset?.id) return false;
      let label = getExistingMarkLabelForTarget(targetEl);
      if (!(label instanceof SVGElement)) {
        label = document.createElementNS(SVG_NS, "text");
      }
      label.setAttribute("class", "fm-group-label");
      label.setAttribute("data-fm-group-label", "1");
      label.setAttribute("data-fm-mark-target-id", targetEl.dataset.id);
      const markSize = getMarkFontSizeValue();
      label.setAttribute("font-size", String(markSize));
      label.style.setProperty("font-size", `${markSize}px`);
      label.dataset.markBaseSize = String(markSize);
      label.textContent = letter;
      ensureId(label);
      applyPointerEventPolicy(label);
      if (label.parentNode !== canvas) canvas.appendChild(label);
      positionMarkLabelForTarget(targetEl, label);
      if (label.dataset?.id) delete state.markLabelComp[label.dataset.id];
      pushHistory(`label-${letter}`);
      return true;
    }

    function resolveContextMarkTarget() {
      const byTarget = getById(state.contextTargetId || "");
      if (byTarget instanceof SVGElement) {
        if (isGroupLabel(byTarget)) {
          const linkedId = String(byTarget.getAttribute("data-fm-mark-target-id") || "").trim();
          const linked = linkedId ? getById(linkedId) : null;
          if (linked instanceof SVGElement && isEditableElement(linked)) return linked;
        }
        if (isEditableElement(byTarget) && !isGroupLabel(byTarget)) return byTarget;
      }
      const byGroup = getById(state.contextGroupId || "");
      if (byGroup instanceof SVGElement && isEditableElement(byGroup) && !isGroupLabel(byGroup)) return byGroup;
      if (state.selectedIds.length === 1) {
        const selected = getById(state.selectedIds[0]);
        if (selected instanceof SVGElement && isEditableElement(selected) && !isGroupLabel(selected)) return selected;
      }
      return null;
    }

    function closeMarkEditor() {
      if (!markEditorEl || markEditorEl.style.display === "none") return false;
      markEditorEl.style.display = "none";
      markEditorEl.dataset.targetId = "";
      return true;
    }

    function cycleMarkEditorLetter(step) {
      if (!(markEditorInputEl instanceof HTMLInputElement)) return;
      const s = Number(step || 1);
      const dir = s >= 0 ? 1 : -1;
      const now = String(markEditorInputEl.value || "").trim().toUpperCase();
      if (!/^[A-Z]$/.test(now)) {
        markEditorInputEl.value = dir > 0 ? "A" : "Z";
        return;
      }
      const base = now.charCodeAt(0) - 65;
      const next = ((base + dir + 26) % 26) + 65;
      markEditorInputEl.value = String.fromCharCode(next);
    }

    function applyMarkFromEditor() {
      const targetId = String(markEditorEl?.dataset.targetId || "");
      const target = targetId ? getById(targetId) : null;
      if (!(target instanceof SVGElement) || !isEditableElement(target) || isGroupLabel(target)) {
        setStatus("Mark needs a target.");
        closeMarkEditor();
        return;
      }
      const letter = String(markEditorInputEl?.value || "").trim().toUpperCase();
      if (!/^[A-Z]$/.test(letter)) {
        setStatus("Mark must be A-Z.");
        if (markEditorInputEl) {
          markEditorInputEl.focus();
          markEditorInputEl.select();
        }
        return;
      }
      addOrReplaceMarkLabel(target, letter);
      closeMarkEditor();
      setStatus(`Label ${letter} set.`);
    }

    function promptGroupMark() {
      const target = resolveContextMarkTarget();
      if (!(target instanceof SVGElement) || !target.dataset?.id) {
        setStatus("Mark needs a target.");
        return;
      }
      const existing = getExistingMarkLabelForTarget(target);
      const current = existing instanceof SVGElement ? String(existing.textContent || "").trim().toUpperCase() : "";
      const menuRect = ctxMenu?.getBoundingClientRect?.() || { left: 24, top: 24, right: 24, width: 0 };
      const x = Math.max(8, Math.min(menuRect.right + 6, window.innerWidth - 180));
      const y = Math.max(8, Math.min(menuRect.top, window.innerHeight - 56));
      if (markEditorEl) {
        markEditorEl.dataset.targetId = target.dataset.id;
        markEditorEl.style.left = `${x}px`;
        markEditorEl.style.top = `${y}px`;
        markEditorEl.style.display = "inline-flex";
      }
      if (markEditorInputEl) {
        markEditorInputEl.value = /^[A-Z]$/.test(current) ? current : "";
        markEditorInputEl.focus();
        markEditorInputEl.select();
      }
    }

    function clearGroupMark() {
      const target = resolveContextMarkTarget();
      if (!(target instanceof SVGElement) || !target.dataset?.id) {
        setStatus("Clear Mark needs a target.");
        return;
      }
      const existing = getExistingMarkLabelForTarget(target);
      if (!(existing instanceof SVGElement)) {
        setStatus("No mark to clear.");
        return;
      }
      if (existing.dataset?.id) delete state.markLabelComp[existing.dataset.id];
      existing.remove();
      pushHistory("label-clear");
      setStatus("Mark cleared.");
    }

    function openContextMenu(clientX, clientY, options = {}) {
      closeMarkEditor();
      state.contextGroupId = options.groupId || "";
      state.contextTargetId = options.targetId || "";
      const hasSelection = state.selectedIds.length > 0;
      const hasGroupSelection = getTopSelectedElements().some((el) => el && el.tagName === "g");
      const singleSelectedImage = getSingleSelectedImageElement();
      const canRasterizeImage = !!singleSelectedImage;
      const markTarget = resolveContextMarkTarget();
      const canMark = !!markTarget;
      const canMarkClear = !!(markTarget && getExistingMarkLabelForTarget(markTarget));
      const canPaste = Array.isArray(state.clipboardItems) && state.clipboardItems.length > 0;
      ctxMenu.querySelectorAll("button[data-ctx-action]").forEach((btn) => {
        const action = btn.dataset.ctxAction || "";
        let disabled = false;
        if (action === "copy" || action === "cut" || action === "duplicate") disabled = !hasSelection;
        if (action === "paste") disabled = !canPaste;
        if (action === "rasterize-image") disabled = !canRasterizeImage;
        if (action === "group") disabled = state.selectedIds.length < 2;
        if (action === "ungroup") disabled = !hasGroupSelection;
        if (action === "mark") disabled = !canMark;
        if (action === "mark-clear") disabled = !canMarkClear;
        if (action === "rasterize-image") btn.hidden = !canRasterizeImage;
        else btn.hidden = false;
        btn.disabled = disabled;
        btn.classList.toggle("disabled", disabled);
      });
      ctxMenu.style.left = `${clientX}px`;
      ctxMenu.style.top = `${clientY}px`;
      ctxMenu.style.display = "block";
      const menuRect = ctxMenu.getBoundingClientRect();
      const nextX = Math.max(4, Math.min(clientX, window.innerWidth - menuRect.width - 4));
      const nextY = Math.max(4, Math.min(clientY, window.innerHeight - menuRect.height - 4));
      ctxMenu.style.left = `${nextX}px`;
      ctxMenu.style.top = `${nextY}px`;
    }

    function closeContextMenu() {
      ctxMenu.style.display = "none";
      state.contextGroupId = null;
      state.contextTargetId = null;
    }

    function supportsFileSystemSaveApi() {
      return typeof window.showSaveFilePicker === "function";
    }

    function supportsFileSystemOpenApi() {
      return typeof window.showOpenFilePicker === "function";
    }

    function getDefaultSvgFileName() {
      const handleName = String(state.fileHandle?.name || "").trim();
      if (handleName) return handleName.toLowerCase().endsWith(".svg") ? handleName : `${handleName}.svg`;
      return "figure.svg";
    }

    function downloadSvgFallback(markup, fileName = "figure.svg") {
      const blob = new Blob([markup], { type: "image/svg+xml;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = fileName;
      a.click();
      setTimeout(() => URL.revokeObjectURL(url), 1500);
    }

    async function saveSvg(options = {}) {
      const saveAs = !!options.saveAs;
      const markup = getCleanSvgDocument();
      const suggestedName = getDefaultSvgFileName();
      if (!supportsFileSystemSaveApi()) {
        downloadSvgFallback(markup, suggestedName);
        setStatus("SVG saved (download fallback).");
        return true;
      }
      try {
        let handle = saveAs ? null : state.fileHandle;
        if (!handle) {
          handle = await window.showSaveFilePicker({
            suggestedName,
            types: [{
              description: "SVG file",
              accept: { "image/svg+xml": [".svg"] }
            }]
          });
        }
        if (!handle) {
          setStatus("Save canceled.");
          return false;
        }
        const writable = await handle.createWritable();
        await writable.write(markup);
        await writable.close();
        state.fileHandle = handle;
        setStatus(saveAs ? "SVG saved as new file." : "SVG saved.");
        return true;
      } catch (err) {
        if (String(err?.name || "") === "AbortError") {
          setStatus("Save canceled.");
          return false;
        }
        captureError("save-svg", err, { userMessage: "SVG save failed." });
        downloadSvgFallback(markup, suggestedName);
        setStatus("SVG save failed; downloaded instead.");
        return false;
      }
    }

    async function exportPdf() {
      if (state.isExportingPdf) {
        setStatus("PDF export is already running.");
        return;
      }
      state.isExportingPdf = true;
      const exportBtn = document.getElementById("exportPdf");
      if (exportBtn) exportBtn.disabled = true;
      try {
        if (!window.jspdf || !window.jspdf.jsPDF) {
          setStatus("jsPDF unavailable.");
          return;
        }
        const { width: w, height: h } = getCanvasDimensions();
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({ unit: "pt", format: [w, h], orientation: w >= h ? "landscape" : "portrait" });
        try {
          const cleanSvg = new DOMParser().parseFromString(getCleanSvgDocument(), "image/svg+xml").documentElement;
          await pdf.svg(cleanSvg, { x: 0, y: 0, width: w, height: h });
        } catch (_) {
          if (!window.canvg || !window.canvg.Canvg) throw new Error("svg2pdf failed and canvg unavailable");
          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = Math.max(1, Math.round(w));
          tempCanvas.height = Math.max(1, Math.round(h));
          const ctx = tempCanvas.getContext("2d");
          if (!ctx) throw new Error("Canvas context unavailable");
          const v = await window.canvg.Canvg.fromString(ctx, getCleanSvgDocument());
          await v.render();
          const pngData = tempCanvas.toDataURL("image/png");
          pdf.addImage(pngData, "PNG", 0, 0, w, h);
        }
        pdf.save("figure.pdf");
        setStatus("PDF exported.");
      } catch (err) {
        setStatus(`PDF export failed: ${err.message}`);
      } finally {
        state.isExportingPdf = false;
        if (exportBtn) exportBtn.disabled = false;
      }
    }

    function loadSvgText(text, options = {}) {
      const doc = new DOMParser().parseFromString(text, "image/svg+xml");
      if (doc.querySelector("parsererror")) {
        setStatus("Invalid SVG file.");
        return false;
      }
      const root = doc.querySelector("svg");
      if (!root) {
        setStatus("Invalid SVG file.");
        return false;
      }
      cancelImageCropMode({ silent: true });
      sanitizeSvgTree(root);
      applyCanvasMeta({ viewBox: root.getAttribute("viewBox") || DEFAULT_VIEWBOX }, { centerScroll: true });
      applySnapshotMarkup(root.innerHTML);
      assignIds();
      ensureFigureTitle();
      clearSelection();
      resetHistory("open-svg");
      state.fileHandle = options.fileHandle || null;
      setStatus("SVG opened.");
      return true;
    }

    async function openSvgFile() {
      if (supportsFileSystemOpenApi()) {
        try {
          const handles = await window.showOpenFilePicker({
            multiple: false,
            types: [{
              description: "SVG file",
              accept: { "image/svg+xml": [".svg"] }
            }]
          });
          const handle = handles?.[0];
          if (!handle) {
            setStatus("Open canceled.");
            return false;
          }
          const file = await handle.getFile();
          const text = await file.text();
          const loaded = loadSvgText(text, { fileHandle: handle });
          if (!loaded) state.fileHandle = null;
          return loaded;
        } catch (err) {
          if (String(err?.name || "") === "AbortError") {
            setStatus("Open canceled.");
            return false;
          }
          captureError("open-svg-picker", err, { userMessage: "Open SVG failed." });
          const fileInput = document.getElementById("openFileInput");
          if (fileInput) {
            fileInput.click();
            setStatus("Open picker failed. Switched to file input.");
            return false;
          }
          setStatus("Open failed.");
          return false;
        }
      }
      const fileInput = document.getElementById("openFileInput");
      if (fileInput) fileInput.click();
      return false;
    }

    function fitImportedWrapperToCanvas(wrapper, options = {}) {
      if (!(wrapper instanceof SVGElement)) return false;
      const dims = getCanvasDimensions();
      const margin = Math.max(8, Number(options.margin || 24));
      const availW = Math.max(24, dims.width - margin * 2);
      const availH = Math.max(24, dims.height - margin * 2);
      
      let initial = null;
      try {
        initial = wrapper.getBBox();
      } catch (_) {
        initial = safeBBox(wrapper);
      }

      if (!initial || initial.width <= 0 || initial.height <= 0) return false;
      let scale = Math.min(1, availW / initial.width, availH / initial.height);
      if (!Number.isFinite(scale) || scale <= 0) scale = 1;
      
      if (scale < 0.9999) {
        const cx = initial.x + initial.width / 2;
        const cy = initial.y + initial.height / 2;
        wrapper.dataset.baseTransform = `translate(${Number(cx.toFixed(4))},${Number(cy.toFixed(4))}) scale(${Number(scale.toFixed(6))}) translate(${Number((-cx).toFixed(4))},${Number((-cy).toFixed(4))})`;
        const t0 = getTranslate(wrapper);
        setTranslate(wrapper, t0.x, t0.y);
      }
      
      // Re-measure after scaling to center it correctly
      let fitted = null;
      try {
        // Force a layout/reflow check if possible, or trust safeBBox which uses screenCTM
        fitted = safeBBox(wrapper); 
      } catch(_) {}
      
      if (!fitted) fitted = initial; // Fallback (might be off if scaled, but better than crash)

      const targetCx = dims.minX + dims.width / 2;
      const targetCy = dims.minY + dims.height / 2;
      const currentCx = fitted.x + fitted.width / 2;
      const currentCy = fitted.y + fitted.height / 2;
      const t = getTranslate(wrapper);
      setTranslate(wrapper, t.x + (targetCx - currentCx), t.y + (targetCy - currentCy));
      return true;
    }

    function importSvgTextFitted(svgText) {
      const importedIds = importSvgText(svgText, { push: false, setMessage: false, select: false, wrap: true, offsetX: 0, offsetY: 0 });
      if (!importedIds.length) return [];
      const wrapper = getById(importedIds[0]);
      if (wrapper instanceof SVGElement) fitImportedWrapperToCanvas(wrapper, { margin: 28 });
      setSelection(importedIds);
      pushHistory("import-svg");
      setStatus("SVG imported and fitted to canvas.");
      return importedIds;
    }

    function newCanvas() {
      cancelImageCropMode({ silent: true });
      applyCanvasMeta({ viewBox: DEFAULT_VIEWBOX }, { centerScroll: true });
      applySnapshotMarkup("");
      ensureFigureTitle();
      clearSelection();
      state.fileHandle = null;
      resetHistory("new-canvas");
      setStatus("New canvas created.");
    }

    function readAutosaveRecordsFromLocalStorage() {
      try {
        const parsed = JSON.parse(localStorage.getItem(AUTOSAVE_KEY) || "[]");
        return normalizeAutosaveRecords(parsed);
      } catch (_) {
        return [];
      }
    }

    function setAutosaveRecordsLocalFallback(records, droppedByCap = 0) {
      const capped = normalizeAutosaveRecords(records).slice(-AUTOSAVE_MAX_RECORDS);
      let working = capped.slice();
      while (true) {
        try {
          if (!working.length) {
            localStorage.removeItem(AUTOSAVE_KEY);
            return { stored: 0, dropped: droppedByCap + capped.length };
          }
          localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(working));
          return { stored: working.length, dropped: droppedByCap + (capped.length - working.length) };
        } catch (err) {
          if (!isQuotaExceededError(err)) throw err;
          if (!working.length) {
            localStorage.removeItem(AUTOSAVE_KEY);
            return { stored: 0, dropped: droppedByCap + capped.length };
          }
          working = working.slice(1);
        }
      }
    }

    function readLiveAutosaveRecordFromLocalStorage() {
      try {
        const raw = localStorage.getItem(LIVE_AUTOSAVE_KEY);
        if (!raw) return null;
        return cloneAutosaveRecord(JSON.parse(raw));
      } catch (_) {
        return null;
      }
    }

    function writeLiveAutosaveRecordToLocalStorage(record) {
      if (!record) {
        localStorage.removeItem(LIVE_AUTOSAVE_KEY);
        return;
      }
      localStorage.setItem(LIVE_AUTOSAVE_KEY, JSON.stringify(record));
    }

    async function readAutosaveRecordsFromIndexedDb() {
      const db = await openAutosaveDb();
      const tx = db.transaction(AUTOSAVE_RECORDS_STORE, "readonly");
      const store = tx.objectStore(AUTOSAVE_RECORDS_STORE);
      const result = await idbRequestToPromise(store.getAll());
      await idbTransactionToPromise(tx);
      return normalizeAutosaveRecords(result);
    }

    async function writeAutosaveRecordsToIndexedDb(records) {
      const normalized = normalizeAutosaveRecords(records).slice(-AUTOSAVE_MAX_RECORDS);
      const db = await openAutosaveDb();
      const tx = db.transaction(AUTOSAVE_RECORDS_STORE, "readwrite");
      const store = tx.objectStore(AUTOSAVE_RECORDS_STORE);
      store.clear();
      normalized.forEach((record) => store.put(record));
      await idbTransactionToPromise(tx);
      return normalized;
    }

    async function readLiveAutosaveRecordFromIndexedDb() {
      const db = await openAutosaveDb();
      const tx = db.transaction(AUTOSAVE_META_STORE, "readonly");
      const store = tx.objectStore(AUTOSAVE_META_STORE);
      const entry = await idbRequestToPromise(store.get(AUTOSAVE_META_LIVE_KEY));
      await idbTransactionToPromise(tx);
      return cloneAutosaveRecord(entry?.value || null);
    }

    async function writeLiveAutosaveRecordToIndexedDb(record) {
      const normalized = cloneAutosaveRecord(record);
      if (!normalized) return null;
      const db = await openAutosaveDb();
      const tx = db.transaction(AUTOSAVE_META_STORE, "readwrite");
      const store = tx.objectStore(AUTOSAVE_META_STORE);
      store.put({ key: AUTOSAVE_META_LIVE_KEY, value: normalized, at: Date.now() });
      await idbTransactionToPromise(tx);
      return normalized;
    }

    async function migrateLegacyAutosaveStorage() {
      if (!isIndexedDbAvailable()) return;
      const legacyRecords = readAutosaveRecordsFromLocalStorage();
      const legacyLive = readLiveAutosaveRecordFromLocalStorage();
      if (!legacyRecords.length && !legacyLive) return;
      try {
        const indexedRecords = await readAutosaveRecordsFromIndexedDb();
        const mergedMap = new Map();
        indexedRecords.forEach((record) => mergedMap.set(record.id, record));
        legacyRecords.forEach((record) => mergedMap.set(record.id, record));
        const merged = normalizeAutosaveRecords(Array.from(mergedMap.values())).slice(-AUTOSAVE_MAX_RECORDS);
        await writeAutosaveRecordsToIndexedDb(merged);
        if (legacyLive) {
          const currentLive = await readLiveAutosaveRecordFromIndexedDb();
          if (!currentLive || Number(legacyLive.at || 0) >= Number(currentLive.at || 0)) {
            await writeLiveAutosaveRecordToIndexedDb(legacyLive);
          }
        }
        localStorage.removeItem(AUTOSAVE_KEY);
        localStorage.removeItem(LIVE_AUTOSAVE_KEY);
      } catch (err) {
        captureError("autosave-migrate", err, { userMessage: "Autosave migration failed." });
      }
    }

    async function getAutosaveRecords() {
      try {
        if (!isIndexedDbAvailable()) return readAutosaveRecordsFromLocalStorage();
        return await readAutosaveRecordsFromIndexedDb();
      } catch (err) {
        if (!state.autosaveParseWarned) {
          state.autosaveParseWarned = true;
          setStatus("Autosave storage read failed. Fallback storage was used.");
          captureError("autosave-read", err, { userMessage: "Autosave data could not be read." });
        }
        return readAutosaveRecordsFromLocalStorage();
      }
    }

    async function setAutosaveRecords(records) {
      const normalized = normalizeAutosaveRecords(records);
      const capped = normalized.slice(-AUTOSAVE_MAX_RECORDS);
      const droppedByCap = Math.max(0, normalized.length - capped.length);
      if (!isIndexedDbAvailable()) {
        return setAutosaveRecordsLocalFallback(capped, droppedByCap);
      }
      try {
        const stored = await writeAutosaveRecordsToIndexedDb(capped);
        return { stored: stored.length, dropped: droppedByCap };
      } catch (err) {
        throw err;
      }
    }

    async function getLiveAutosaveRecord() {
      try {
        if (!isIndexedDbAvailable()) return readLiveAutosaveRecordFromLocalStorage();
        return await readLiveAutosaveRecordFromIndexedDb();
      } catch (err) {
        captureError("live-autosave-read", err, { userMessage: "Live autosave data could not be read." });
        return readLiveAutosaveRecordFromLocalStorage();
      }
    }

    async function setLiveAutosaveRecord(record) {
      const normalized = cloneAutosaveRecord(record);
      if (!normalized) return;
      if (!isIndexedDbAvailable()) {
        writeLiveAutosaveRecordToLocalStorage(normalized);
        return;
      }
      await writeLiveAutosaveRecordToIndexedDb(normalized);
    }

    async function writeLiveAutosave(reason = "live") {
      try {
        const rec = makeAutosaveRecord("live", reason);
        if (!rec) return;
        await setLiveAutosaveRecord(rec);
        state.liveAutosaveQuotaWarned = false;
        state.liveAutosaveSizeWarned = false;
      } catch (err) {
        if (isQuotaExceededError(err)) {
          if (!state.liveAutosaveQuotaWarned) {
            state.liveAutosaveQuotaWarned = true;
            setStatus("Live autosave skipped: storage is full. Use Save SVG.");
          }
          try { localStorage.removeItem(LIVE_AUTOSAVE_KEY); } catch (_) {}
          return;
        }
        captureError("live-autosave-write", err, { userMessage: "Autosave write failed." });
      }
    }

    function scheduleLiveAutosave(reason = "live") {
      if (state.liveAutosaveTimer) clearTimeout(state.liveAutosaveTimer);
      state.liveAutosaveTimer = window.setTimeout(() => {
        state.liveAutosaveTimer = 0;
        void writeLiveAutosave(reason);
      }, 450);
    }

    async function saveAutosave() {
      const rec = makeAutosaveRecord("as", "timed");
      if (!rec) return;
      const records = await getAutosaveRecords();
      records.push(rec);
      let result = { stored: 0, dropped: 0 };
      try {
        result = await setAutosaveRecords(records);
      } catch (err) {
        captureError("autosave-write", err, { userMessage: "Autosave write failed." });
        return;
      }
      await writeLiveAutosave("timed");
      await refreshRestoreList();
      if (!result.stored) {
        if (!state.autosaveQuotaWarned) {
          state.autosaveQuotaWarned = true;
          setStatus("Autosave skipped: storage is full. Use Save SVG.");
        }
        return;
      }
      state.autosaveQuotaWarned = false;
      const dropped = result.dropped > 0 ? ` (${result.dropped} old record(s) dropped)` : "";
      setStatus(`Autosave snapshot written.${dropped}`);
    }

    async function refreshRestoreList() {
      const records = await getAutosaveRecords();
      restoreListEl.innerHTML = "";
      records.slice().reverse().forEach((r) => {
        const option = document.createElement("option");
        option.value = r.id;
        option.textContent = new Date(r.at).toLocaleString();
        restoreListEl.appendChild(option);
      });
    }

    async function restoreLatest() {
      cancelImageCropMode({ silent: true });
      try {
        const records = await getAutosaveRecords();
        const timed = records[records.length - 1] || null;
        const live = await getLiveAutosaveRecord();
        const r = live && (!timed || Number(live.at || 0) >= Number(timed.at || 0)) ? live : timed;
        if (!r || !r.markup) {
          setStatus("No autosave records.");
          return;
        }
        applyCanvasMeta(r.canvasMeta);
        applySnapshotMarkup(r.markup, r.imageRefs || null);
        assignIds();
        ensureFigureTitle();
        setSelection(r.selectedIds || []);
        resetHistory("restore-latest");
        const source = r.id && String(r.id).startsWith("live-") ? "live" : "timed";
        const stamp = r.at ? new Date(r.at).toLocaleString() : "";
        setStatus(`Latest autosave restored (${source}${stamp ? `: ${stamp}` : ""}).`);
      } catch (err) {
        captureError("autosave-restore-latest", err, { userMessage: "Restore latest failed." });
        setStatus("Restore latest failed.");
      }
    }

    async function restoreFromList() {
      cancelImageCropMode({ silent: true });
      try {
        const records = await getAutosaveRecords();
        const id = restoreListEl.value;
        const r = records.find((x) => x.id === id);
        if (!r) {
          setStatus("Selected autosave not found.");
          return;
        }
        applyCanvasMeta(r.canvasMeta);
        applySnapshotMarkup(r.markup, r.imageRefs || null);
        assignIds();
        ensureFigureTitle();
        setSelection(r.selectedIds || []);
        resetHistory("restore-from-list");
        setStatus("Autosave restored.");
      } catch (err) {
        captureError("autosave-restore-selected", err, { userMessage: "Restore selected failed." });
        setStatus("Restore selected failed.");
      }
    }

    function updateAutosaveTimer() {
      if (state.autosaveTimer) {
        clearInterval(state.autosaveTimer);
        state.autosaveTimer = null;
      }
      const val = document.getElementById("autosaveSelect").value;
      localStorage.setItem(AUTOSAVE_INTERVAL_KEY, val);
      if (val !== "off") {
        state.autosaveTimer = setInterval(() => { void saveAutosave(); }, Number(val) * 60 * 1000);
      }
      if (val === "off") setStatus("Autosave off. Live restore snapshot remains available.");
      else setStatus(`Autosave set: ${val} min (timed) + live snapshot on edit.`);
    }

    function consumePasteNudgeStep() {
      state.pasteNudgeCounter = (Number(state.pasteNudgeCounter || 0) + 1) % 16;
      return state.pasteNudgeCounter;
    }

    function getPasteNudgeOffset(stepMultiplier = 1) {
      const idx = consumePasteNudgeStep();
      const step = 18 * Math.max(1, Number(stepMultiplier || 1));
      return { x: idx * step, y: idx * step };
    }

    function insertImageElement(src, width, height, offsetIndex = 0, options = {}) {
      const step = 24;
      const extraX = Number(options.offsetX || 0);
      const extraY = Number(options.offsetY || 0);
      const dims = getCanvasDimensions();
      const baseX = dims.minX + dims.width / 2 - width / 2;
      const baseY = dims.minY + dims.height / 2 - height / 2;
      const x = baseX + offsetIndex * step + extraX;
      const y = baseY + offsetIndex * step + extraY;
      const el = document.createElementNS(SVG_NS, "image");
      el.setAttribute("x", String(x));
      el.setAttribute("y", String(y));
      el.setAttribute("width", String(width));
      el.setAttribute("height", String(height));
      el.setAttribute("href", src);
      el.setAttributeNS(XLINK_NS, "href", src);
      ensureId(el);
      setTranslate(el, 0, 0);
      canvas.appendChild(el);
      if (options.select !== false) setSelection([el.dataset.id]);
      return el.dataset.id || "";
    }

    function fileToDataUrl(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(String(reader.result || ""));
        reader.onerror = () => reject(new Error("File read failed"));
        reader.readAsDataURL(file);
      });
    }

    function getImageSize(src) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => resolve({ width: Math.max(1, img.width || 320), height: Math.max(1, img.height || 240) });
        img.onerror = () => resolve({ width: 320, height: 240 });
        img.src = src;
      });
    }

    function isImageFile(file) {
      if (!file) return false;
      const t = String(file.type || "").toLowerCase();
      if (t.startsWith("image/")) return true;
      return /\.(png|jpe?g|gif|webp|bmp|svg)$/i.test(String(file.name || ""));
    }

    async function importImageFile(file, options = {}) {
      if (!isImageFile(file)) return "";
      const dataUrl = await fileToDataUrl(file);
      if (!dataUrl) return "";
      const nativeSize = await getImageSize(dataUrl);
      const dims = getCanvasDimensions();
      const maxW = Math.max(80, dims.width * 0.82);
      const maxH = Math.max(80, dims.height * 0.82);
      let scale = Math.min(1, maxW / Math.max(1, nativeSize.width), maxH / Math.max(1, nativeSize.height));
      if (!Number.isFinite(scale) || scale <= 0) scale = 1;
      const width = Math.max(1, Math.round(nativeSize.width * scale));
      const height = Math.max(1, Math.round(nativeSize.height * scale));
      const nudge = options.usePasteNudge === false ? { x: 0, y: 0 } : getPasteNudgeOffset();
      const id = insertImageElement(dataUrl, width, height, 0, {
        select: options.select !== false,
        offsetX: nudge.x + Number(options.offsetX || 0),
        offsetY: nudge.y + Number(options.offsetY || 0)
      });
      return id;
    }

    function loadImageElement(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.decoding = "async";
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error("Image decode failed."));
        img.src = src;
      });
    }

    function getSingleSelectedImageElement() {
      if (state.selectedIds.length !== 1) return null;
      const el = getById(state.selectedIds[0]);
      if (!(el instanceof SVGElement) || el.tagName !== "image") return null;
      return el;
    }

    function readDataUrlMime(src) {
      const m = String(src || "").match(/^data:([^;,]+)[;,]/i);
      return m ? String(m[1] || "").toLowerCase() : "";
    }

    function canvasHasTransparency(ctx, w, h) {
      const width = Math.max(1, Math.floor(Number(w || 0)));
      const height = Math.max(1, Math.floor(Number(h || 0)));
      const maxPixelsForFullScan = 8_000_000;
      if (width * height > maxPixelsForFullScan) return false;
      const data = ctx.getImageData(0, 0, width, height).data;
      const step = Math.max(4, Math.floor((width * height) / 250_000) * 4);
      for (let i = 3; i < data.length; i += step) {
        if (data[i] < 250) return true;
      }
      return false;
    }

    async function rasterizeSelectedImage(targetDpi) {
      const imgEl = getSingleSelectedImageElement();
      if (!imgEl) {
        setStatus("Rasterize requires one selected image.");
        return false;
      }
      const dpi = Math.max(30, Math.min(1200, Number(targetDpi || 0)));
      if (!Number.isFinite(dpi)) {
        setStatus("Invalid rasterize DPI.");
        return false;
      }
      const hrefRaw = imgEl.getAttribute("href") || imgEl.getAttribute("xlink:href") || "";
      const source = resolveImage(hrefRaw) || hrefRaw;
      if (!source) {
        setStatus("Image source not found.");
        return false;
      }
      const displayBox = getSelectionRenderBox(imgEl) || safeBBox(imgEl);
      if (!displayBox || displayBox.width < 1 || displayBox.height < 1) {
        setStatus("Image size is invalid for rasterize.");
        return false;
      }

      setStatus("Rasterizing...");
      try {
        const img = await loadImageElement(source);
        const naturalW = Math.max(1, Math.floor(Number(img.naturalWidth || img.width || 1)));
        const naturalH = Math.max(1, Math.floor(Number(img.naturalHeight || img.height || 1)));
        let targetW = Math.max(1, Math.round((displayBox.width / 96) * dpi));
        let targetH = Math.max(1, Math.round((displayBox.height / 96) * dpi));
        targetW = Math.min(targetW, naturalW);
        targetH = Math.min(targetH, naturalH);
        if (!Number.isFinite(targetW) || !Number.isFinite(targetH) || targetW < 1 || targetH < 1) {
          setStatus("Rasterize target size is invalid.");
          return false;
        }
        const canvasTmp = document.createElement("canvas");
        canvasTmp.width = targetW;
        canvasTmp.height = targetH;
        const ctx = canvasTmp.getContext("2d");
        if (!ctx) {
          setStatus("Rasterize failed: canvas unavailable.");
          return false;
        }
        ctx.clearRect(0, 0, targetW, targetH);
        ctx.drawImage(img, 0, 0, targetW, targetH);

        const sourceMime = readDataUrlMime(source);
        let outputMime = "image/jpeg";
        const preferPngSource = sourceMime === "image/png" || sourceMime === "image/svg+xml";
        if (preferPngSource) outputMime = "image/png";
        const alphaCandidate = sourceMime === "image/png" || sourceMime === "image/webp" || sourceMime === "image/gif" || sourceMime === "image/svg+xml";
        if (alphaCandidate && outputMime !== "image/png") {
          try {
            if (canvasHasTransparency(ctx, targetW, targetH)) outputMime = "image/png";
          } catch (_) {
            outputMime = "image/png";
          }
        }
        const nextSrc = outputMime === "image/png"
          ? canvasTmp.toDataURL("image/png")
          : canvasTmp.toDataURL("image/jpeg", 0.92);
        if (!nextSrc || nextSrc === source) {
          setStatus(`Image already near target (${targetW}x${targetH}).`);
          return false;
        }
        imgEl.setAttribute("href", nextSrc);
        imgEl.setAttributeNS(XLINK_NS, "href", nextSrc);
        requestSelectionVisualRefresh();
        pushHistory("rasterize-image");
        setStatus(`Image rasterized to ${targetW}x${targetH} (${outputMime === "image/png" ? "PNG" : "JPEG q0.92"}).`);
        return true;
      } catch (err) {
        setStatus("Image rasterize failed.");
        captureError("image-rasterize", err, { userMessage: "Image rasterize failed." });
        return false;
      }
    }

    function promptRasterizeSelectedImage() {
      const imgEl = getSingleSelectedImageElement();
      if (!imgEl) {
        setStatus("Rasterize requires one selected image.");
        return;
      }
      const box = getSelectionRenderBox(imgEl) || safeBBox(imgEl);
      const defaultDpi = 220;
      const hintW = Math.max(1, Math.round(((box?.width || 0) / 96) * defaultDpi));
      const hintH = Math.max(1, Math.round(((box?.height || 0) / 96) * defaultDpi));
      const input = window.prompt("Rasterize target DPI (72 / 150 / 220 / 300)\n220 is recommended for balanced quality and size.\nCurrent draft target: " + `${hintW} x ${hintH}px`, String(defaultDpi));
      if (input == null) return;
      const dpi = Number(String(input).trim());
      if (!Number.isFinite(dpi) || dpi < 30 || dpi > 1200) {
        setStatus("Invalid DPI. Enter 72, 150, 220, or 300.");
        return;
      }
      rasterizeSelectedImage(dpi);
    }

    async function cropImageSourceToDataUrl(src, crop) {
      const img = await loadImageElement(src);
      const naturalW = Math.max(1, Number(img.naturalWidth || img.width || 1));
      const naturalH = Math.max(1, Number(img.naturalHeight || img.height || 1));
      const renderW = Math.max(1, Number(crop.renderW || naturalW));
      const renderH = Math.max(1, Number(crop.renderH || naturalH));
      const scaleX = naturalW / renderW;
      const scaleY = naturalH / renderH;
      const sx = Math.max(0, Math.min(naturalW - 1, Number(crop.left || 0) * scaleX));
      const sy = Math.max(0, Math.min(naturalH - 1, Number(crop.top || 0) * scaleY));
      const sw = Math.max(1, Math.min(naturalW - sx, Number(crop.width || renderW) * scaleX));
      const sh = Math.max(1, Math.min(naturalH - sy, Number(crop.height || renderH) * scaleY));
      let outW = Math.max(1, Math.round(sw));
      let outH = Math.max(1, Math.round(sh));
      const maxCanvasDim = 16384;
      const dimScale = Math.min(1, maxCanvasDim / Math.max(outW, outH));
      if (dimScale < 0.9999) {
        outW = Math.max(1, Math.round(outW * dimScale));
        outH = Math.max(1, Math.round(outH * dimScale));
      }
      const tmp = document.createElement("canvas");
      tmp.width = outW;
      tmp.height = outH;
      const ctx = tmp.getContext("2d");
      if (!ctx) throw new Error("Crop canvas context unavailable.");
      ctx.drawImage(img, sx, sy, sw, sh, 0, 0, outW, outH);
      const beforePpuX = naturalW / renderW;
      const beforePpuY = naturalH / renderH;
      const afterPpuX = outW / Math.max(1, Number(crop.width || renderW));
      const afterPpuY = outH / Math.max(1, Number(crop.height || renderH));
      return {
        dataUrl: tmp.toDataURL("image/png"),
        outputWidth: outW,
        outputHeight: outH,
        beforePpuX,
        beforePpuY,
        afterPpuX,
        afterPpuY,
        limitedByCanvas: dimScale < 0.9999
      };
    }

    function pointInRect(pt, rect) {
      if (!pt || !rect) return false;
      return pt.x >= rect.x && pt.x <= rect.x + rect.width && pt.y >= rect.y && pt.y <= rect.y + rect.height;
    }

    function renderCropOverlay() {
      const cm = state.cropMode;
      if (!cm) return;
      const ensureRect = (key, className) => {
        let el = cm[key];
        if (!(el instanceof SVGElement)) {
          el = document.createElementNS(SVG_NS, "rect");
          el.setAttribute("class", className);
          canvas.appendChild(el);
          cm[key] = el;
        }
        return el;
      };
      const ensureMask = (idx) => {
        cm.maskEls = Array.isArray(cm.maskEls) ? cm.maskEls : [];
        let el = cm.maskEls[idx];
        if (!(el instanceof SVGElement)) {
          el = document.createElementNS(SVG_NS, "rect");
          el.setAttribute("class", "crop-mask");
          canvas.appendChild(el);
          cm.maskEls[idx] = el;
        }
        return el;
      };
      const ensureHandle = (name) => {
        cm.handleEls = cm.handleEls && typeof cm.handleEls === "object" ? cm.handleEls : {};
        let el = cm.handleEls[name];
        if (!(el instanceof SVGElement)) {
          el = document.createElementNS(SVG_NS, "rect");
          el.setAttribute("class", "crop-handle");
          el.dataset.handle = name;
          canvas.appendChild(el);
          cm.handleEls[name] = el;
        }
        return el;
      };
      const boundary = ensureRect("boundaryEl", "crop-boundary");
      boundary.setAttribute("x", String(cm.imageBox.x));
      boundary.setAttribute("y", String(cm.imageBox.y));
      boundary.setAttribute("width", String(cm.imageBox.width));
      boundary.setAttribute("height", String(cm.imageBox.height));
      if (cm.draftRect && cm.draftRect.width > 1 && cm.draftRect.height > 1) {
        const draft = ensureRect("draftEl", "crop-draft");
        draft.setAttribute("x", String(cm.draftRect.x));
        draft.setAttribute("y", String(cm.draftRect.y));
        draft.setAttribute("width", String(cm.draftRect.width));
        draft.setAttribute("height", String(cm.draftRect.height));
        const imgX = cm.imageBox.x;
        const imgY = cm.imageBox.y;
        const imgR = cm.imageBox.x + cm.imageBox.width;
        const imgB = cm.imageBox.y + cm.imageBox.height;
        const dX = cm.draftRect.x;
        const dY = cm.draftRect.y;
        const dR = cm.draftRect.x + cm.draftRect.width;
        const dB = cm.draftRect.y + cm.draftRect.height;
        const masks = [
          { x: imgX, y: imgY, width: cm.imageBox.width, height: Math.max(0, dY - imgY) },
          { x: imgX, y: Math.max(imgY, dY), width: Math.max(0, dX - imgX), height: Math.max(0, dB - dY) },
          { x: Math.min(imgR, dR), y: Math.max(imgY, dY), width: Math.max(0, imgR - dR), height: Math.max(0, dB - dY) },
          { x: imgX, y: Math.min(imgB, dB), width: cm.imageBox.width, height: Math.max(0, imgB - dB) }
        ];
        masks.forEach((m, idx) => {
          const maskEl = ensureMask(idx);
          maskEl.setAttribute("x", String(m.x));
          maskEl.setAttribute("y", String(m.y));
          maskEl.setAttribute("width", String(m.width));
          maskEl.setAttribute("height", String(m.height));
          if (m.width <= 0.01 || m.height <= 0.01) maskEl.setAttribute("display", "none");
          else maskEl.removeAttribute("display");
        });
        const displayScale = getCanvasDisplayScale();
        const cornerSize = Math.max(11, 13 / Math.max(displayScale, 1e-6));
        const edgeThickness = Math.max(6, 7 / Math.max(displayScale, 1e-6));
        const edgeWidth = Math.max(edgeThickness + 2, Math.min(cm.draftRect.width, 22 / Math.max(displayScale, 1e-6)));
        const edgeHeight = Math.max(edgeThickness + 2, Math.min(cm.draftRect.height, 22 / Math.max(displayScale, 1e-6)));
        const cx = cm.draftRect.x + cm.draftRect.width / 2;
        const cy = cm.draftRect.y + cm.draftRect.height / 2;
        const handles = [
          { name: "nw", cx: cm.draftRect.x, cy: cm.draftRect.y, w: cornerSize, h: cornerSize },
          { name: "ne", cx: dR, cy: cm.draftRect.y, w: cornerSize, h: cornerSize },
          { name: "sw", cx: cm.draftRect.x, cy: dB, w: cornerSize, h: cornerSize },
          { name: "se", cx: dR, cy: dB, w: cornerSize, h: cornerSize },
          { name: "n", cx, cy: cm.draftRect.y, w: edgeWidth, h: edgeThickness },
          { name: "s", cx, cy: dB, w: edgeWidth, h: edgeThickness },
          { name: "w", cx: cm.draftRect.x, cy, w: edgeThickness, h: edgeHeight },
          { name: "e", cx: dR, cy, w: edgeThickness, h: edgeHeight }
        ];
        handles.forEach((h) => {
          const handleEl = ensureHandle(h.name);
          handleEl.setAttribute("x", String(h.cx - h.w / 2));
          handleEl.setAttribute("y", String(h.cy - h.h / 2));
          handleEl.setAttribute("width", String(h.w));
          handleEl.setAttribute("height", String(h.h));
        });
      } else if (cm.draftEl instanceof SVGElement) {
        cm.draftEl.remove();
        cm.draftEl = null;
        (Array.isArray(cm.maskEls) ? cm.maskEls : []).forEach((el) => el instanceof SVGElement && el.remove());
        cm.maskEls = [];
        if (cm.handleEls && typeof cm.handleEls === "object") {
          Object.values(cm.handleEls).forEach((el) => el instanceof SVGElement && el.remove());
        }
        cm.handleEls = {};
      }
      updateCropUi();
    }

    function clearCropOverlay(cm) {
      if (!cm) return;
      if (cm.boundaryEl instanceof SVGElement) cm.boundaryEl.remove();
      if (cm.draftEl instanceof SVGElement) cm.draftEl.remove();
      (Array.isArray(cm.maskEls) ? cm.maskEls : []).forEach((el) => {
        if (el instanceof SVGElement) el.remove();
      });
      if (cm.handleEls && typeof cm.handleEls === "object") {
        Object.values(cm.handleEls).forEach((el) => {
          if (el instanceof SVGElement) el.remove();
        });
      }
      cm.boundaryEl = null;
      cm.draftEl = null;
      cm.maskEls = [];
      cm.handleEls = {};
    }

    function createDefaultCropRect(imageBox) {
      return {
        x: Number(imageBox.x || 0),
        y: Number(imageBox.y || 0),
        width: Math.max(2, Number(imageBox.width || 0)),
        height: Math.max(2, Number(imageBox.height || 0))
      };
    }

    function clampCropRectToImage(rect, imageBox) {
      const width = Math.max(2, Math.min(Number(rect?.width || 0), imageBox.width));
      const height = Math.max(2, Math.min(Number(rect?.height || 0), imageBox.height));
      const minX = imageBox.x;
      const minY = imageBox.y;
      const maxX = imageBox.x + imageBox.width - width;
      const maxY = imageBox.y + imageBox.height - height;
      const x = Math.max(minX, Math.min(maxX, Number(rect?.x || minX)));
      const y = Math.max(minY, Math.min(maxY, Number(rect?.y || minY)));
      return { x, y, width, height };
    }

    function startCropResize(handle) {
      const cm = state.cropMode;
      if (!cm || !cm.draftRect || !handle) return;
      cm.resize = {
        handle: String(handle),
        startRect: { ...cm.draftRect }
      };
      state.interaction = { type: "crop-resize", pointerId: null };
    }

    function updateCropResize(pt) {
      const cm = state.cropMode;
      if (!cm || !cm.resize || !cm.resize.startRect) return;
      const handle = String(cm.resize.handle || "");
      if (!handle) return;
      const start = cm.resize.startRect;
      const minSize = 2;
      const b = cm.imageBox;
      const px = Math.max(b.x, Math.min(b.x + b.width, Number(pt?.x || start.x)));
      const py = Math.max(b.y, Math.min(b.y + b.height, Number(pt?.y || start.y)));
      let left = start.x;
      let right = start.x + start.width;
      let top = start.y;
      let bottom = start.y + start.height;

      if (handle.includes("w")) left = Math.min(px, right - minSize);
      if (handle.includes("e")) right = Math.max(px, left + minSize);
      if (handle.includes("n")) top = Math.min(py, bottom - minSize);
      if (handle.includes("s")) bottom = Math.max(py, top + minSize);

      left = Math.max(b.x, Math.min(left, b.x + b.width - minSize));
      right = Math.max(left + minSize, Math.min(right, b.x + b.width));
      top = Math.max(b.y, Math.min(top, b.y + b.height - minSize));
      bottom = Math.max(top + minSize, Math.min(bottom, b.y + b.height));

      cm.draftRect = {
        x: left,
        y: top,
        width: Math.max(minSize, right - left),
        height: Math.max(minSize, bottom - top)
      };
      renderCropOverlay();
    }

    function finishCropResize() {
      const cm = state.cropMode;
      if (!cm) return;
      cm.resize = null;
      if (cm.draftRect) setStatus("Crop handles updated. Press Enter (or Apply Crop) to confirm.");
      updateCropUi();
      state.interaction = null;
    }

    function startCropMove(pt) {
      const cm = state.cropMode;
      if (!cm || !cm.draftRect) return;
      cm.moveOffset = {
        x: Number(pt?.x || cm.draftRect.x) - cm.draftRect.x,
        y: Number(pt?.y || cm.draftRect.y) - cm.draftRect.y
      };
      state.interaction = { type: "crop-move", pointerId: null };
    }

    function updateCropMove(pt) {
      const cm = state.cropMode;
      if (!cm || !cm.draftRect || !cm.moveOffset) return;
      const nx = Number(pt?.x || 0) - Number(cm.moveOffset.x || 0);
      const ny = Number(pt?.y || 0) - Number(cm.moveOffset.y || 0);
      cm.draftRect = clampCropRectToImage({
        x: nx,
        y: ny,
        width: cm.draftRect.width,
        height: cm.draftRect.height
      }, cm.imageBox);
      renderCropOverlay();
    }

    function finishCropMove() {
      const cm = state.cropMode;
      if (!cm) return;
      cm.moveOffset = null;
      if (cm.draftRect) {
        setStatus("Crop box moved. Press Enter (or Apply Crop) to confirm.");
      }
      updateCropUi();
      state.interaction = null;
    }

    function cancelImageCropMode(options = {}) {
      const cm = state.cropMode;
      if (!cm) return false;
      if (state.interaction && (state.interaction.type === "crop-move" || state.interaction.type === "crop-resize")) state.interaction = null;
      cm.moveOffset = null;
      cm.resize = null;
      clearCropOverlay(cm);
      state.cropMode = null;
      updateCropUi();
      if (!options.silent) setStatus("Crop canceled.");
      return true;
    }

    async function applyCropFromMode() {
      const cm = state.cropMode;
      if (!cm || !cm.draftRect) {
        setStatus("Move crop box first.");
        return;
      }
      const imgEl = getById(cm.targetId);
      if (!(imgEl instanceof SVGElement) || imgEl.tagName !== "image") {
        cancelImageCropMode({ silent: true });
        setStatus("Crop target not found.");
        return;
      }
      const xAttr = Number(imgEl.getAttribute("x") || 0);
      const yAttr = Number(imgEl.getAttribute("y") || 0);
      const wAttr = Number(imgEl.getAttribute("width") || 0);
      const hAttr = Number(imgEl.getAttribute("height") || 0);
      if (wAttr < 2 || hAttr < 2) {
        setStatus("Image size is invalid for crop.");
        return;
      }
      const p1 = canvasPointToElementLocal(imgEl, cm.draftRect.x, cm.draftRect.y);
      const p2 = canvasPointToElementLocal(imgEl, cm.draftRect.x + cm.draftRect.width, cm.draftRect.y + cm.draftRect.height);
      const leftLocal = Math.max(xAttr, Math.min(xAttr + wAttr, Math.min(p1.x, p2.x)));
      const topLocal = Math.max(yAttr, Math.min(yAttr + hAttr, Math.min(p1.y, p2.y)));
      const rightLocal = Math.max(xAttr, Math.min(xAttr + wAttr, Math.max(p1.x, p2.x)));
      const bottomLocal = Math.max(yAttr, Math.min(yAttr + hAttr, Math.max(p1.y, p2.y)));
      const cropW = rightLocal - leftLocal;
      const cropH = bottomLocal - topLocal;
      if (cropW < 2 || cropH < 2) {
        setStatus("Crop area too small.");
        return;
      }
      const hrefRaw = imgEl.getAttribute("href") || imgEl.getAttribute("xlink:href") || "";
      const source = resolveImage(hrefRaw) || hrefRaw;
      if (!source) {
        setStatus("Image source not found.");
        return;
      }
      try {
        const cropped = await cropImageSourceToDataUrl(source, {
          left: leftLocal - xAttr,
          top: topLocal - yAttr,
          width: cropW,
          height: cropH,
          renderW: wAttr,
          renderH: hAttr
        });
        imgEl.setAttribute("x", String(leftLocal));
        imgEl.setAttribute("y", String(topLocal));
        imgEl.setAttribute("width", String(cropW));
        imgEl.setAttribute("height", String(cropH));
        imgEl.setAttribute("href", cropped.dataUrl);
        imgEl.setAttributeNS(XLINK_NS, "href", cropped.dataUrl);
        requestSelectionVisualRefresh();
        pushHistory("crop-image");
        cancelImageCropMode({ silent: true });
        const ratioX = Number(cropped.afterPpuX || 0) / Math.max(1e-9, Number(cropped.beforePpuX || 0));
        const ratioY = Number(cropped.afterPpuY || 0) / Math.max(1e-9, Number(cropped.beforePpuY || 0));
        const ratio = Math.min(ratioX, ratioY);
        let densityNote = "";
        if (ratio >= 0.98 && ratio <= 1.02) {
          densityNote = "resolution preserved";
        } else if (ratio < 0.98) {
          densityNote = `resolution reduced to ${Math.max(1, Math.round(ratio * 100))}%`;
        } else {
          densityNote = `resolution increased to ${Math.max(1, Math.round(ratio * 100))}%`;
        }
        if (cropped.limitedByCanvas) densityNote += " (canvas limit applied)";
        setStatus(`Image cropped: ${Math.round(cropW)}x${Math.round(cropH)} | data ${cropped.outputWidth}x${cropped.outputHeight} | ${densityNote}`);
      } catch (err) {
        setStatus("Image crop failed.");
        captureError("image-crop", err, { userMessage: "Image crop failed." });
      }
    }

    function cropSelectedImage() {
      if (state.selectedIds.length !== 1) {
        setStatus("Select one image to crop.");
        return;
      }
      const imgEl = getById(state.selectedIds[0]);
      if (!(imgEl instanceof SVGElement) || imgEl.tagName !== "image") {
        setStatus("Crop requires one selected image.");
        return;
      }
      const width = Number(imgEl.getAttribute("width") || 0);
      const height = Number(imgEl.getAttribute("height") || 0);
      if (!Number.isFinite(width) || !Number.isFinite(height) || width < 2 || height < 2) {
        setStatus("Image size is invalid for crop.");
        return;
      }
      const box = safeBBox(imgEl);
      if (!box || box.width < 2 || box.height < 2) {
        setStatus("Image bounding box is invalid for crop.");
        return;
      }
      const draftRect = clampCropRectToImage(createDefaultCropRect(box), box);
      cancelImageCropMode({ silent: true });
      state.cropMode = {
        targetId: imgEl.dataset.id,
        imageBox: { x: box.x, y: box.y, width: box.width, height: box.height },
        boundaryEl: null,
        draftEl: null,
        maskEls: [],
        handleEls: {},
        moveOffset: null,
        resize: null,
        draftRect
      };
      renderCropOverlay();
      setStatus("Crop mode: drag handles to trim (PowerPoint style). Press Enter to confirm.");
    }

    function pasteRasterImageQuick(source, options = {}) {
      const mime = String(options.mime || "image/unknown");
      const types = Array.isArray(options.types) ? options.types : [];
      const route = String(options.route || "image-raster");
      const historyReason = String(options.historyReason || "paste-image");
      const statusPrefix = String(options.statusPrefix || "Pasted raster image");
      const noteTail = options.noteTail ? ` | ${String(options.noteTail)}` : "";
      const provisionalW = Math.max(64, Number(options.provisionalW || 640));
      const provisionalH = Math.max(64, Number(options.provisionalH || 480));
      const isBlob = typeof Blob !== "undefined" && source instanceof Blob;
      const displaySrc = isBlob ? URL.createObjectURL(source) : String(source || "");
      if (!displaySrc) return "";
      const nudge = getPasteNudgeOffset();
      const id = insertImageElement(displaySrc, provisionalW, provisionalH, 0, { select: false, offsetX: nudge.x, offsetY: nudge.y });
      if (id) setSelection([id]);
      pushHistory(historyReason);
      setLastPasteReport(route, types, `${mime}:pending${noteTail}`);
      setStatus(`${statusPrefix}. Resolving size...`);

      if (isBlob) {
        fileToDataUrl(source).then((dataUrl) => {
          if (!id || !dataUrl) return;
          const el = getById(id);
          if (el instanceof SVGElement && el.tagName === "image") {
            el.setAttributeNS(XLINK_NS, "href", dataUrl);
            el.setAttribute("href", dataUrl);
          }
          try { URL.revokeObjectURL(displaySrc); } catch (_) {}
        }).catch(() => {});
      }

      getImageSize(displaySrc).then((size) => {
        if (id) {
          const el = getById(id);
          if (el instanceof SVGElement && el.tagName === "image") {
            const x = Number(el.getAttribute("x") || 0);
            const y = Number(el.getAttribute("y") || 0);
            const w = Number(el.getAttribute("width") || provisionalW);
            const h = Number(el.getAttribute("height") || provisionalH);
            const cx = x + w / 2;
            const cy = y + h / 2;
            el.setAttribute("width", String(size.width));
            el.setAttribute("height", String(size.height));
            el.setAttribute("x", String(cx - size.width / 2));
            el.setAttribute("y", String(cy - size.height / 2));
            if (state.selectedIds.includes(id)) requestSelectionVisualRefresh();
          }
        }
        const hint = getPasteQualityHint(size.width, size.height);
        setLastPasteReport(route, types, `${mime}:${size.width}x${size.height}${hint ? ` | ${hint}` : ""}${noteTail}`);
        setStatus(`${statusPrefix} ${size.width}x${size.height}. ${hint || ""}`);
      }).catch(() => {
        setStatus(statusPrefix);
      });
      return id;
    }

    function extractSvgFromHtml(html) {
      if (!html) return [];
      const doc = new DOMParser().parseFromString(html, "text/html");
      return Array.from(doc.querySelectorAll("svg")).slice(0, 20).map((svg) => svg.outerHTML).filter(Boolean);
    }

    function extractSvgSnippet(text) {
      if (!text) return "";
      const m = String(text).match(/<svg[\s\S]*?<\/svg>/i);
      return m ? m[0] : "";
    }

    function extractImageSrcFromHtml(html) {
      if (!html) return [];
      const doc = new DOMParser().parseFromString(html, "text/html");
      return Array.from(doc.querySelectorAll("img[src]")).slice(0, 20).map((img) => img.getAttribute("src")).filter(Boolean);
    }

    function listClipboardTypes(clipboardData) {
      const fromTypes = Array.from(clipboardData?.types || []);
      const fromItems = Array.from(clipboardData?.items || [])
        .filter((it) => !!it)
        .map((it) => String(it.type || ""))
        .filter(Boolean);
      const fromFiles = Array.from(clipboardData?.files || [])
        .map((f) => String(f?.type || ""))
        .filter(Boolean);
      return [...new Set([...fromTypes, ...fromItems, ...fromFiles])];
    }

    function findRasterFileFromClipboard(ev, items) {
      const fileItem = (items || []).find((it) => {
        const t = String(it?.type || "").toLowerCase();
        return t === "image/png" || t === "image/jpeg";
      });
      if (fileItem) {
        const f = fileItem.getAsFile?.();
        if (f) return f;
      }
      const genericFileItem = (items || []).find((it) => String(it?.kind || "").toLowerCase() === "file");
      if (genericFileItem) {
        const f = genericFileItem.getAsFile?.();
        const t = String(f?.type || "").toLowerCase();
        if (f && (t === "image/png" || t === "image/jpeg")) return f;
        if (f && (!t || t === "application/octet-stream")) return f;
      }
      const files = Array.from(ev?.clipboardData?.files || []);
      const direct = files.find((f) => {
        const t = String(f?.type || "").toLowerCase();
        return t === "image/png" || t === "image/jpeg";
      });
      if (direct) return direct;
      const unknown = files.find((f) => !!f);
      if (unknown) return unknown;
      return direct || null;
    }

    function readClipboardItemAsText(item, timeoutMs = 1200) {
      return new Promise((resolve) => {
        let settled = false;
        const done = (v) => {
          if (settled) return;
          settled = true;
          resolve(String(v || ""));
        };
        const timer = setTimeout(() => done(""), Math.max(80, Number(timeoutMs || 1200)));
        try {
          if (item && typeof item.getAsString === "function") {
            item.getAsString((s) => {
              clearTimeout(timer);
              done(s);
            });
            return;
          }
          const file = item?.getAsFile?.();
          if (!file) {
            clearTimeout(timer);
            done("");
            return;
          }
          const reader = new FileReader();
          reader.onload = () => {
            clearTimeout(timer);
            done(reader.result || "");
          };
          reader.onerror = () => {
            clearTimeout(timer);
            done("");
          };
          reader.readAsText(file);
        } catch (_) {
          clearTimeout(timer);
          done("");
        }
      });
    }

    async function pasteImageFromClipboardApi(types = []) {
      const cb = navigator.clipboard;
      if (!cb || typeof cb.read !== "function") return false;
      try {
        const cItems = await cb.read();
        if (!Array.isArray(cItems) || !cItems.length) return false;
        for (const cItem of cItems) {
          const cTypes = Array.from(cItem.types || []);
          const imageType = cTypes.find((t) => /^image\/(png|jpeg)$/i.test(String(t || "")));
          if (!imageType) continue;
          const blob = await cItem.getType(imageType);
          const id = pasteRasterImageQuick(blob, {
            mime: imageType,
            types: [...new Set([...(types || []), ...cTypes])],
            route: "clipboard-api-image-fallback",
            historyReason: "paste-clipboard-api-image-fallback",
            statusPrefix: "Pasted image via clipboard API fallback"
          });
          if (!id) continue;
          return true;
        }
      } catch (_) {
        return false;
      }
      return false;
    }

    function shouldPreferRasterPath(primaryTypes, mergedTypes) {
      const pTypes = (primaryTypes || []).map((t) => String(t || "").toLowerCase());
      const mTypes = (mergedTypes || []).map((t) => String(t || "").toLowerCase());
      const hasRasterType = pTypes.some((t) => t === "files" || t === "image/png" || t === "image/jpeg") ||
        (!pTypes.length && mTypes.some((t) => t === "files" || t === "image/png" || t === "image/jpeg"));
      if (!hasRasterType) return false;
      const hasVectorType = pTypes.some((t) => t === "text/plain" || t === "text/html" || t === "image/svg+xml");
      if (hasVectorType) return false;
      return true;
    }

    function clearPasteLock() {
      state.isPasting = false;
      state.pasteLockAt = 0;
    }

    function tryRecoverPasteLock() {
      if (!state.isPasting) return false;
      const now = Date.now();
      if (!state.pasteLockAt || now - state.pasteLockAt > PASTE_LOCK_TIMEOUT_MS) {
        clearPasteLock();
        setStatus("Recovered from stale paste lock.");
        return true;
      }
      return false;
    }

    async function importSvgFromClipboardStringItems(items, types, options = {}) {
      const stringItems = items.filter((it) => typeof it?.getAsString === "function");
      if (!stringItems.length) return false;
      const timeoutMs = Math.max(100, Number(options.timeoutMs || 320));
      const maxItems = Math.max(1, Number(options.maxItems || 4));
      const priority = (it) => {
        const t = String(it?.type || "").toLowerCase();
        if (t === "image/svg+xml") return 0;
        if (t === "text/plain") return 1;
        if (t === "text/html") return 2;
        return 9;
      };
      const candidates = [...stringItems].sort((a, b) => priority(a) - priority(b)).slice(0, maxItems);
      const reads = await Promise.all(candidates.map(async (item) => ({ item, raw: await readClipboardItemAsText(item, timeoutMs) })));
      for (const { item, raw } of reads) {
        if (!raw) continue;
        if ((item?.type || "") === "text/html") {
          const htmlSvgs = extractSvgFromHtml(raw);
          if (htmlSvgs.length) {
            const nudge = getPasteNudgeOffset();
            let count = 0;
            const allIds = [];
            htmlSvgs.forEach((svgText, idx) => {
              const ids = importSvgText(svgText, {
                push: false,
                setMessage: false,
                select: false,
                offsetX: nudge.x + idx * 24,
                offsetY: nudge.y + idx * 24
              });
              if (ids.length) count += 1;
              allIds.push(...ids);
            });
            if (count > 0) {
              setSelection(allIds);
              pushHistory("paste-item-html-svg");
              setLastPasteReport("item-html-svg", types, `blocks=${count}`);
              setStatus(`Pasted ${count} SVG block(s) from clipboard item.`);
              return true;
            }
          }
        }
        const snippet = raw.trim().startsWith("<svg") ? raw : extractSvgSnippet(raw);
        if (!snippet) continue;
        const ok = importSvgTextWithPasteNudge(snippet).length > 0;
        setLastPasteReport("item-string-svg", types, ok ? `type=${item?.type || "unknown"}` : "item parse failed");
        if (ok) return true;
      }
      return false;
    }

    function setLastPasteReport(route, types, note = "") {
      state.lastPasteReport = {
        at: new Date().toISOString(),
        route,
        types: [...(types || [])],
        note
      };
      try {
        localStorage.setItem(PASTE_REPORT_KEY, JSON.stringify(state.lastPasteReport));
      } catch (_) {}
      state.pasteReportHistory.push(state.lastPasteReport);
      if (state.pasteReportHistory.length > 30) state.pasteReportHistory = state.pasteReportHistory.slice(-30);
      try {
        localStorage.setItem(PASTE_REPORT_HISTORY_KEY, JSON.stringify(state.pasteReportHistory));
      } catch (_) {}
    }

    function getPasteQualityHint(width, height) {
      const w = Number(width || 0);
      const h = Number(height || 0);
      if (w <= 0 || h <= 0) return "";
      if (w < 1000 || h < 700) {
        return "Source image looks low-res. In PowerPoint, try copy as SVG/EMF if available.";
      }
      return "Source image size looks high enough.";
    }

    function showPasteReport() {
      const r = state.lastPasteReport;
      if (!r) {
        setStatus("No paste report yet. Paste once, then open report.");
        return;
      }
      const lines = [
        `Time: ${r.at}`,
        `Route: ${r.route}`,
        `Types: ${(r.types || []).join(", ") || "(none)"}`,
        `Note: ${r.note || "-"}`,
        `Meaning: ${routeToPasteMeaning(r.route)}`,
      ];
      const text = lines.join("\n");
      setStatus(`Paste report shown: ${r.route}`);
      window.prompt("Paste diagnostics (copy if needed)", text);
    }

    function formatPasteReportText() {
      const r = state.lastPasteReport;
      if (!r) return "";
      return [
        `Time: ${r.at}`,
        `Route: ${r.route}`,
        `Types: ${(r.types || []).join(", ") || "(none)"}`,
        `Note: ${r.note || "-"}`,
        `Meaning: ${routeToPasteMeaning(r.route)}`,
        `UserAgent: ${navigator.userAgent}`
      ].join("\n");
    }

    function routeToPasteMeaning(route) {
      if (route === "html-svg" || route === "image-svg+xml" || route === "item-image-svg+xml" || route === "plain-svg" || route === "item-string-svg" || route === "item-html-svg") {
        return "Vector pasted (editable SVG elements).";
      }
      if (route === "image-raster" || route === "html-image") {
        return "Raster image pasted (not vector-editable).";
      }
      if (route === "unsupported") return "Clipboard did not include supported SVG/PNG/JPEG payload.";
      if (route === "error") return "Paste processing failed.";
      return "Paste route recorded.";
    }

    function formatPasteReportHistoryText(limit = 10) {
      const history = (state.pasteReportHistory || []).slice(-Math.max(1, limit));
      if (!history.length) return "";
      const blocks = history.map((r, idx) => [
        `#${idx + 1}`,
        `Time: ${r.at}`,
        `Route: ${r.route}`,
        `Types: ${(r.types || []).join(", ") || "(none)"}`,
        `Note: ${r.note || "-"}`
      ].join("\n"));
      return [
        `Entries: ${history.length}`,
        `UserAgent: ${navigator.userAgent}`,
        "",
        blocks.join("\n\n")
      ].join("\n");
    }

    async function copyPasteReport() {
      const text = formatPasteReportText();
      if (!text) {
        setStatus("No paste report yet. Paste once, then copy report.");
        return;
      }
      try {
        if (navigator.clipboard?.writeText) {
          await navigator.clipboard.writeText(text);
          setStatus("Paste report copied.");
          return;
        }
      } catch (_) {}
      window.prompt("Clipboard unavailable. Copy manually:", text);
      setStatus("Paste report shown for manual copy.");
    }

    function downloadPasteReport() {
      const latest = formatPasteReportText();
      const history = formatPasteReportHistoryText(20);
      const text = [latest, "", "----", "", history].filter(Boolean).join("\n");
      if (!text) {
        setStatus("No paste report yet. Paste once, then save report.");
        return;
      }
      const safeAt = (state.lastPasteReport?.at || new Date().toISOString()).replace(/[:.]/g, "-");
      const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `paste-report-${safeAt}.txt`;
      a.click();
      setTimeout(() => URL.revokeObjectURL(url), 1500);
      setStatus("Paste report file saved.");
    }

    function showPasteReportHistory() {
      const text = formatPasteReportHistoryText(10);
      if (!text) {
        setStatus("No paste report history yet.");
        return;
      }
      setStatus("Paste report history shown.");
      window.prompt("Paste report history", text);
    }

    async function copyPasteReportHistory() {
      const text = formatPasteReportHistoryText(20);
      if (!text) {
        setStatus("No paste report history yet.");
        return;
      }
      try {
        if (navigator.clipboard?.writeText) {
          await navigator.clipboard.writeText(text);
          setStatus("Paste report history copied.");
          return;
        }
      } catch (_) {}
      window.prompt("Clipboard unavailable. Copy history manually:", text);
      setStatus("Paste report history shown for manual copy.");
    }

    function clearPasteReportHistory() {
      if (!state.pasteReportHistory.length && !state.lastPasteReport) {
        setStatus("No paste report history to clear.");
        return;
      }
      if (!window.confirm("Clear paste report history?")) return;
      state.pasteReportHistory = [];
      state.lastPasteReport = null;
      try {
        localStorage.removeItem(PASTE_REPORT_KEY);
        localStorage.removeItem(PASTE_REPORT_HISTORY_KEY);
      } catch (_) {}
      setStatus("Paste report history cleared.");
    }

    function showShortcutHelp() {
      const lines = [
        "Figure Maker Shortcuts",
        "",
        "V : Black Arrow tool",
        "A : White Arrow tool",
        "H : Hand tool",
        "Space (hold) : Temporary hand/pan",
        "R : Add Rect",
        "L : Add Line",
        "Y : Add Triangle",
        "Q : Match selected line(s) to Arrow",
        "E : Add Ellipse",
        "T : Add Text",
        "Ctrl/Cmd+Z : Undo",
        "Ctrl/Cmd+Shift+Z : Redo",
        "Ctrl/Cmd+Y : Redo",
        "Delete/Backspace : Delete selection",
        "Arrow keys : Nudge (Shift=10px)",
        "Ctrl/Cmd+Wheel or Pinch : Zoom",
        "Drag just outside selected BBox : Rotate (Shift=15deg snap)",
        "Alt/Ctrl (during drag/resize) : Temporarily disable snapping",
        "Enter (in crop mode) : Apply crop",
        "Esc (in crop mode) : Cancel crop",
        "Ctrl/Cmd+D : Duplicate",
        "Ctrl/Cmd+C/X : Copy/Cut",
        "Ctrl/Cmd+V : Paste from OS clipboard (or internal fallback if OS paste not delivered)",
        "Ctrl/Cmd+Shift+V : Paste internal clipboard (force)",
        "Ctrl/Cmd+Shift+R : Restore latest autosave",
        "Ctrl/Cmd+Shift+I : Show paste report",
        "Ctrl/Cmd+Shift+J : Copy paste report",
        "Ctrl/Cmd+Shift+K : Save paste report file",
        "Ctrl/Cmd+Shift+H : Show paste report history",
        "Ctrl/Cmd+Shift+U : Copy paste report history",
        "Ctrl/Cmd+Shift+L : Clear paste report history",
        "Ctrl/Cmd+/ : Show this shortcuts help",
        "",
        "Text: Double click or Enter/F2 on selected text to edit inline."
      ];
      const text = lines.join("\n");
      if (shortcutHelpTextEl) shortcutHelpTextEl.textContent = text;
      if (shortcutModalEl) shortcutModalEl.classList.add("show");
      setStatus("Shortcut help shown.");
    }

    function closeShortcutHelp() {
      if (!shortcutModalEl || !shortcutModalEl.classList.contains("show")) return false;
      shortcutModalEl.classList.remove("show");
      return true;
    }

    function closeInlineTextEditor(commit) {
      if (!state.textEdit) return;
      const target = getById(state.textEdit.targetId);
      if (commit && target && target.tagName === "text") {
        const text = String(textEditorInput.value || "");
        const runs = normalizeScriptRuns(text.length, state.textEdit.runs);
        applyTextRunsToElement(target, text, runs);
        setSelection([target.dataset.id]);
        pushHistory("edit-text");
        setStatus("Text updated.");
      } else if (!commit && target && target.tagName === "text") {
        applyTextRunsToElement(target, state.textEdit.originalText || "", state.textEdit.originalRuns || []);
        requestSelectionVisualRefresh();
      }
      textEditorInput.style.display = "none";
      state.textEdit = null;
    }

    function openInlineTextEditor(textEl) {
      if (!(textEl instanceof SVGElement) || textEl.tagName !== "text" || !textEl.dataset.id) return;
      const box = textEl.getBoundingClientRect();
      const wrap = canvasWrapEl.getBoundingClientRect();
      const extracted = extractTextRunsForEditing(textEl);
      state.textEdit = {
        targetId: textEl.dataset.id,
        text: extracted.text,
        runs: normalizeScriptRuns(extracted.text.length, extracted.runs),
        originalText: extracted.text,
        originalRuns: normalizeScriptRuns(extracted.text.length, extracted.runs)
      };
      textEditorInput.value = extracted.text || "";
      textEditorInput.style.left = `${Math.max(0, box.left - wrap.left + canvasWrapEl.scrollLeft - 4)}px`;
      textEditorInput.style.top = `${Math.max(0, box.top - wrap.top + canvasWrapEl.scrollTop - 4)}px`;
      textEditorInput.style.width = `${Math.max(120, box.width + 24)}px`;
      textEditorInput.style.fontSize = textEl.getAttribute("font-size") ? `${Number(textEl.getAttribute("font-size"))}px` : "16px";
      textEditorInput.style.display = "block";
      textEditorInput.focus();
      textEditorInput.select();
      setStatus("Editing text...");
    }

    function importSvgText(svgText, options = {}) {
      const push = options.push !== false;
      const setMessage = options.setMessage !== false;
      const select = options.select !== false;
      const offsetX = Number(options.offsetX || 0);
      const offsetY = Number(options.offsetY || 0);
      const wrap = options.wrap !== false;
      const doc = new DOMParser().parseFromString(svgText, "image/svg+xml");
      if (doc.querySelector("parsererror")) return [];
      const root = doc.querySelector("svg");
      if (!root) return [];
      sanitizeSvgTree(root);
      const importedIds = [];
      let wrapper = null;
      if (wrap) {
        wrapper = document.createElementNS(SVG_NS, "g");
        ensureId(wrapper);
        applyPointerEventPolicy(wrapper);
        setTranslate(wrapper, 0, 0);
        canvas.appendChild(wrapper);
      }
      Array.from(root.children).forEach((child) => {
        const imported = document.importNode(child, true);
        if (!(imported instanceof SVGElement)) return;
        sanitizeSvgTree(imported);
        ensureId(imported);
        ensureTransformState(imported);
        if (!wrap && (offsetX || offsetY)) {
          const t = getTranslate(imported);
          setTranslate(imported, t.x + offsetX, t.y + offsetY);
        }
        if (wrapper) wrapper.appendChild(imported);
        else canvas.appendChild(imported);
        if (!wrap && imported.dataset.id) importedIds.push(imported.dataset.id);
      });
      if (wrapper) {
        if (offsetX || offsetY) {
          const t = getTranslate(wrapper);
          setTranslate(wrapper, t.x + offsetX, t.y + offsetY);
        }
        if (wrapper.dataset.id) importedIds.push(wrapper.dataset.id);
      }
      assignIds();
      if (select) setSelection(importedIds);
      if (push) pushHistory("paste-svg");
      if (setMessage) setStatus("Pasted SVG content.");
      return importedIds;
    }

    function importSvgTextWithPasteNudge(svgText, options = {}) {
      const nudge = getPasteNudgeOffset();
      return importSvgText(svgText, {
        ...options,
        offsetX: Number(options.offsetX || 0) + nudge.x,
        offsetY: Number(options.offsetY || 0) + nudge.y
      });
    }

    async function handlePaste(ev) {
      if (ev && typeof ev === "object") {
        if (processedPasteEvents.has(ev)) return;
        processedPasteEvents.add(ev);
      }
      if (state.isPasting && !tryRecoverPasteLock()) {
        setStatus("Paste is already running.");
        return;
      }
      const rawTypes = Array.from(ev.clipboardData?.types || []);
      const items = Array.from(ev.clipboardData?.items || []).filter((it) => !!it);
      const types = listClipboardTypes(ev.clipboardData);
      const hasPayload = items.length > 0 ||
        Array.from(ev.clipboardData?.files || []).length > 0 ||
        types.some((t) => /^(files|image\/png|image\/jpeg|image\/svg\+xml|text\/html|text\/plain)$/i.test(String(t || "")));
      if (!hasPayload) return;
      state.lastExternalPasteAt = Date.now();
      state.isPasting = true;
      state.pasteLockAt = Date.now();
      try {
        const getDataSafe = (kind) => {
          try {
            return ev.clipboardData?.getData(kind) || "";
          } catch (_) {
            return "";
          }
        };
        if (shouldPreferRasterPath(rawTypes, types)) {
          const rasterFileFirst = findRasterFileFromClipboard(ev, items);
          if (rasterFileFirst) {
            ev.preventDefault();
            const mime = String(rasterFileFirst.type || "image/unknown");
            pasteRasterImageQuick(rasterFileFirst, { mime, types, route: "image-raster", historyReason: "paste-image", statusPrefix: "Pasted raster image", noteTail: "fastpath" });
            return;
          }
          const apiFast = await pasteImageFromClipboardApi(types);
          if (apiFast) {
            ev.preventDefault();
            return;
          }
        }
        const svgXmlText = getDataSafe("image/svg+xml");
        const plain = getDataSafe("text/plain");
        if (svgXmlText.trim().startsWith("<svg")) {
          ev.preventDefault();
          const ok = importSvgTextWithPasteNudge(svgXmlText).length > 0;
          setLastPasteReport("image-svg+xml", types, ok ? "vector imported" : "parse failed");
          if (!ok) setStatus("Paste SVG(XML) parse failed.");
          return;
        }

        const svgItem = items.find((it) => it.type === "image/svg+xml");
        if (svgItem) {
          ev.preventDefault();
          const raw = await readClipboardItemAsText(svgItem);
          const snippet = extractSvgSnippet(raw);
          const ok = snippet ? importSvgTextWithPasteNudge(snippet).length > 0 : false;
          setLastPasteReport("item-image-svg+xml", types, ok ? "vector imported" : "item parse failed");
          if (ok) return;
        }

        const plainSvg = plain.trim().startsWith("<svg") ? plain : extractSvgSnippet(plain);
        if (plainSvg) {
          ev.preventDefault();
          const ok = importSvgTextWithPasteNudge(plainSvg).length > 0;
          setLastPasteReport("plain-svg", types, ok ? "vector imported" : "parse failed");
          if (!ok) setStatus("Paste SVG parse failed.");
          return;
        }

        const itemStringImported = await importSvgFromClipboardStringItems(items, types, { timeoutMs: 260, maxItems: 3 });
        if (itemStringImported) {
          ev.preventDefault();
          return;
        }

        const htmlText = getDataSafe("text/html");
        const htmlSvgs = extractSvgFromHtml(htmlText);
        if (htmlSvgs.length) {
          ev.preventDefault();
          const nudge = getPasteNudgeOffset();
          let count = 0;
          const allIds = [];
          htmlSvgs.forEach((svgText, idx) => {
            const ids = importSvgText(svgText, {
              push: false,
              setMessage: false,
              select: false,
              offsetX: nudge.x + idx * 24,
              offsetY: nudge.y + idx * 24
            });
            if (ids.length > 0) count += 1;
            allIds.push(...ids);
          });
          if (count > 0) {
            setSelection(allIds);
            pushHistory("paste-html-svg");
            setLastPasteReport("html-svg", types, `blocks=${count}`);
            setStatus(`Pasted ${count} SVG block(s) from HTML.`);
            return;
          }
        }

        const rasterFile = findRasterFileFromClipboard(ev, items);
        if (rasterFile) {
          ev.preventDefault();
          const mime = String(rasterFile.type || "image/unknown");
          pasteRasterImageQuick(rasterFile, { mime, types, route: "image-raster", historyReason: "paste-image", statusPrefix: "Pasted raster image" });
          return;
        }

        if (types.some((t) => /^(files|image\/png|image\/jpeg)$/i.test(String(t || "")))) {
          const apiOk = await pasteImageFromClipboardApi(types);
          if (apiOk) {
            ev.preventDefault();
            return;
          }
        }

        const htmlImgSrcs = extractImageSrcFromHtml(htmlText);
        if (htmlImgSrcs.length) {
          ev.preventDefault();
          const nudge = getPasteNudgeOffset();
          let inserted = 0;
          const allIds = [];
          for (const [idx, src] of htmlImgSrcs.slice(0, 20).entries()) {
            const size = await getImageSize(src);
            const id = insertImageElement(src, size.width, size.height, idx, {
              select: false,
              offsetX: nudge.x,
              offsetY: nudge.y
            });
            if (id) allIds.push(id);
            inserted += 1;
          }
          if (allIds.length) setSelection(allIds);
          pushHistory("paste-html-image");
          setLastPasteReport("html-image", types, `images=${inserted}`);
          setStatus(`Pasted ${inserted} HTML image(s).`);
          return;
        }

        setLastPasteReport("unsupported", types, "no supported payload found");
        const suffix = types.length ? ` Types: ${types.join(", ")}` : "";
        setStatus(`Paste unsupported: use SVG/HTML or PNG/JPEG.${suffix}`);
      } catch (err) {
        setLastPasteReport("error", types, String(err.message || err));
        setStatus("Paste failed. Please try another source format.");
        captureError("paste-failed", err, { userMessage: "Paste processing failed." });
      } finally {
        clearPasteLock();
      }
    }

    async function pasteFromClipboardApiFallback() {
      if (state.isPasting && !tryRecoverPasteLock()) return false;
      const cb = navigator.clipboard;
      if (!cb) return false;
      state.isPasting = true;
      state.pasteLockAt = Date.now();
      try {
        try {
          if (typeof cb.read === "function") {
            const cItems = await cb.read();
            if (Array.isArray(cItems) && cItems.length) {
              for (const cItem of cItems) {
                const cTypes = Array.from(cItem.types || []);
                if (cTypes.includes("image/svg+xml")) {
                  const blob = await cItem.getType("image/svg+xml");
                  const raw = await blob.text();
                  const snippet = extractSvgSnippet(raw);
                  if (snippet && importSvgTextWithPasteNudge(snippet).length > 0) {
                    setLastPasteReport("clipboard-api-svg", cTypes, "vector imported via clipboard.read");
                    return true;
                  }
                }
                if (cTypes.includes("text/html")) {
                  const blob = await cItem.getType("text/html");
                  const html = await blob.text();
                  const htmlSvgs = extractSvgFromHtml(html);
                  if (htmlSvgs.length) {
                    const nudge = getPasteNudgeOffset();
                    let count = 0;
                    const allIds = [];
                    htmlSvgs.forEach((svgText, idx) => {
                      const ids = importSvgText(svgText, {
                        push: false,
                        setMessage: false,
                        select: false,
                        offsetX: nudge.x + idx * 24,
                        offsetY: nudge.y + idx * 24
                      });
                      if (ids.length) count += 1;
                      allIds.push(...ids);
                    });
                    if (count > 0) {
                      setSelection(allIds);
                      pushHistory("paste-clipboard-api-html-svg");
                      setLastPasteReport("clipboard-api-html-svg", cTypes, `blocks=${count}`);
                      setStatus(`Pasted ${count} SVG block(s) via clipboard API.`);
                      return true;
                    }
                  }
                }
                if (cTypes.includes("text/plain")) {
                  const blob = await cItem.getType("text/plain");
                  const plain = await blob.text();
                  const snippet = plain.trim().startsWith("<svg") ? plain : extractSvgSnippet(plain);
                  if (snippet && importSvgTextWithPasteNudge(snippet).length > 0) {
                    setLastPasteReport("clipboard-api-plain-svg", cTypes, "vector imported via clipboard.read");
                    return true;
                  }
                }
                const imageType = cTypes.find((t) => t === "image/png" || t === "image/jpeg");
                if (imageType) {
                  const blob = await cItem.getType(imageType);
                  const dataUrl = await fileToDataUrl(blob);
                  const size = await getImageSize(dataUrl);
                  const nudge = getPasteNudgeOffset();
                  const id = insertImageElement(dataUrl, size.width, size.height, 0, {
                    select: false,
                    offsetX: nudge.x,
                    offsetY: nudge.y
                  });
                  if (id) {
                    setSelection([id]);
                    pushHistory("paste-clipboard-api-image");
                    const hint = getPasteQualityHint(size.width, size.height);
                    setLastPasteReport("clipboard-api-image", cTypes, `${imageType}:${size.width}x${size.height}${hint ? ` | ${hint}` : ""}`);
                    setStatus(`Pasted image via clipboard API ${size.width}x${size.height}. ${hint || ""}`);
                    return true;
                  }
                }
              }
            }
          }
        } catch (_) {}

        try {
          if (typeof cb.readText === "function") {
            const t = await cb.readText();
            const snippet = t && (t.trim().startsWith("<svg") ? t : extractSvgSnippet(t));
            if (snippet && importSvgTextWithPasteNudge(snippet).length > 0) {
              setLastPasteReport("clipboard-api-readText-svg", ["text/plain"], "vector imported via readText");
              return true;
            }
          }
        } catch (_) {}
        return false;
      } finally {
        clearPasteLock();
      }
    }

    async function pasteBestEffort() {
      const fromSystem = await pasteFromClipboardApiFallback();
      if (fromSystem) return true;
      return pasteInternalClipboard();
    }

    function beginMarquee(start, keepCurrent) {
      clearSmartGuides();
      const rect = document.createElementNS(SVG_NS, "rect");
      rect.setAttribute("class", "marquee");
      rect.setAttribute("x", String(start.x));
      rect.setAttribute("y", String(start.y));
      rect.setAttribute("width", "0");
      rect.setAttribute("height", "0");
      canvas.appendChild(rect);
      state.interaction = { type: "marquee", start, rect, keepCurrent, pointerId: null };
    }

    function beginPan(clientX, clientY) {
      clearSmartGuides();
      state.interaction = {
        type: "pan",
        startClientX: Number(clientX),
        startClientY: Number(clientY),
        startScrollLeft: canvasWrapEl.scrollLeft,
        startScrollTop: canvasWrapEl.scrollTop,
        pointerId: null
      };
      canvasWrapEl.classList.add("is-panning");
      updateToolCursor();
    }

    function updatePan(clientX, clientY) {
      const it = state.interaction;
      if (!it || it.type !== "pan") return;
      const dx = Number(clientX) - it.startClientX;
      const dy = Number(clientY) - it.startClientY;
      canvasWrapEl.scrollLeft = it.startScrollLeft - dx;
      canvasWrapEl.scrollTop = it.startScrollTop - dy;
    }

    function finishPan() {
      const it = state.interaction;
      if (!it || it.type !== "pan") return;
      state.interaction = null;
      canvasWrapEl.classList.remove("is-panning");
      updateToolCursor();
    }

    function updateMarquee(pt) {
      const it = state.interaction;
      if (!it || it.type !== "marquee") return;
      const x = Math.min(it.start.x, pt.x);
      const y = Math.min(it.start.y, pt.y);
      const w = Math.abs(it.start.x - pt.x);
      const h = Math.abs(it.start.y - pt.y);
      it.rect.setAttribute("x", String(x));
      it.rect.setAttribute("y", String(y));
      it.rect.setAttribute("width", String(w));
      it.rect.setAttribute("height", String(h));
    }

    function finishMarquee() {
      const it = state.interaction;
      if (!it || it.type !== "marquee") return;
      const x = Number(it.rect.getAttribute("x"));
      const y = Number(it.rect.getAttribute("y"));
      const width = Number(it.rect.getAttribute("width"));
      const height = Number(it.rect.getAttribute("height"));
      it.rect.remove();
      const hit = [];
      if (width > 2 && height > 2) {
        const area = { x, y, width, height };
        canvas.querySelectorAll("[data-id]").forEach((el) => {
          if (!(el instanceof SVGElement) || !isEditableElement(el)) return;
          if (isGroupLabel(el)) return;
          const b = safeBBox(el);
          if (b && intersects(area, b)) hit.push(el.dataset.id);
        });
      }
      if (it.keepCurrent) {
        setSelection([...state.selectedIds, ...hit]);
      } else {
        setSelection(hit);
      }
      state.interaction = null;
    }

    function combineBoxes(boxes) {
      const valid = (boxes || []).filter((b) => !!b && Number.isFinite(b.x) && Number.isFinite(b.y) && Number.isFinite(b.width) && Number.isFinite(b.height));
      if (!valid.length) return null;
      const minX = Math.min(...valid.map((b) => b.x));
      const minY = Math.min(...valid.map((b) => b.y));
      const maxX = Math.max(...valid.map((b) => b.x + b.width));
      const maxY = Math.max(...valid.map((b) => b.y + b.height));
      return { x: minX, y: minY, width: Math.max(1, maxX - minX), height: Math.max(1, maxY - minY) };
    }

    function buildDragSnapTargets(selectedElements) {
      const xTargets = [];
      const yTargets = [];
      const shouldSkip = (el) => selectedElements.some((s) => s === el || s.contains(el) || el.contains(s));
      canvas.querySelectorAll("[data-id]").forEach((el) => {
        if (!(el instanceof SVGElement) || !isEditableElement(el)) return;
        if (shouldSkip(el)) return;
        const b = safeBBox(el);
        if (!b || !Number.isFinite(b.width) || !Number.isFinite(b.height) || b.width <= 0 || b.height <= 0) return;
        const left = b.x;
        const cx = b.x + b.width / 2;
        const right = b.x + b.width;
        const top = b.y;
        const cy = b.y + b.height / 2;
        const bottom = b.y + b.height;
        xTargets.push({ value: left }, { value: cx }, { value: right });
        yTargets.push({ value: top }, { value: cy }, { value: bottom });
      });
      return { xTargets, yTargets };
    }

    function pickBestSnapDelta(rawDelta, movingValues, targets, threshold) {
      if (!targets.length || !movingValues.length) return null;
      let best = null;
      movingValues.forEach((mv) => {
        targets.forEach((target) => {
          const deltaAdjust = target.value - mv;
          const dist = Math.abs(deltaAdjust);
          if (dist > threshold) return;
          if (!best || dist < best.dist) {
            best = { dist, delta: rawDelta + deltaAdjust, guide: target.value };
          }
        });
      });
      return best;
    }

    function cloneElements(elements, options = {}) {
      const offsetX = Number(options.offsetX || 0);
      const offsetY = Number(options.offsetY || 0);
      const stripGroupLabels = options.stripGroupLabels !== false;
      const clones = [];
      (Array.isArray(elements) ? elements : []).forEach((el) => {
        if (!(el instanceof SVGElement) || !(el.parentNode instanceof SVGElement)) return;
        const clone = el.cloneNode(true);
        clone.querySelectorAll?.("[data-id]").forEach((n) => n.removeAttribute("data-id"));
        clone.removeAttribute("data-id");
        sanitizeSvgTree(clone);
        if (stripGroupLabels && clone instanceof SVGElement) {
          clone.querySelectorAll?.('[data-fm-group-label="1"]').forEach((n) => n.remove());
        }
        ensureId(clone);
        const t = getTranslate(el);
        setTranslate(clone, t.x + offsetX, t.y + offsetY);
        el.parentNode.appendChild(clone);
        assignIds(clone);
        if (clone.dataset.id) clones.push(clone.dataset.id);
      });
      return clones;
    }

    function beginDrag(start, options = {}) {
      const elements = Array.isArray(options.elements) && options.elements.length
        ? options.elements
        : getTopSelectedElements();
      if (!elements.length) return;
      const original = new Map();
      elements.forEach((el) => original.set(el.dataset.id, getTranslate(el)));
      const movingBoxes = elements.map((el) => safeBBox(el)).filter(Boolean);
      const movingBounds = combineBoxes(movingBoxes);
      const snapTargets = buildDragSnapTargets(elements);
      state.interaction = {
        type: "drag",
        start,
        original,
        moved: false,
        pointerId: null,
        movingBounds,
        snapTargets,
        fromRightCopy: !!options.fromRightCopy,
        sourceSelection: Array.isArray(options.sourceSelection) ? [...options.sourceSelection] : [],
        clonedIds: Array.isArray(options.clonedIds) ? [...options.clonedIds] : []
      };
      clearSmartGuides();
    }

    function isRotateHotzoneHit(pt, targetEl) {
      if (!(targetEl instanceof SVGElement) || !isResizableElement(targetEl)) return false;
      const b = safeBBox(targetEl);
      if (!b || b.width <= 0 || b.height <= 0) return false;
      const scale = Math.max(getCanvasDisplayScale(), 1e-6);
      const innerPad = 4 / scale;
      const outerPad = 26 / scale;
      const inner = { x: b.x - innerPad, y: b.y - innerPad, width: b.width + innerPad * 2, height: b.height + innerPad * 2 };
      const outer = { x: b.x - outerPad, y: b.y - outerPad, width: b.width + outerPad * 2, height: b.height + outerPad * 2 };
      return pointInRect(pt, outer) && !pointInRect(pt, inner);
    }

    function computeRotateHoverReady(clientX, clientY, hoverTarget = null) {
      if (state.interaction) return false;
      if (state.cropMode) return false;
      const effectiveTool = getEffectiveTool();
      if (effectiveTool === "hand") return false;
      if (state.selectedIds.length !== 1) return false;
      const selected = getById(state.selectedIds[0]);
      if (!(selected instanceof SVGElement)) return false;
      const pt = getSvgPoint(clientX, clientY);
      if (!isRotateHotzoneHit(pt, selected)) return false;
      const raw = hoverTarget ? closestEditableTarget(hoverTarget) : null;
      const stack = getEditableTargetsAtPoint(clientX, clientY);
      const hasCanvasHit = !!raw || stack.length > 0;
      return !hasCanvasHit;
    }

    function beginRotate(start, targetEl) {
      if (!(targetEl instanceof SVGElement) || !isResizableElement(targetEl)) return false;
      const b = safeBBox(targetEl);
      if (!b) return false;
      ensureTransformState(targetEl);
      const parent = targetEl.parentNode instanceof SVGElement ? targetEl.parentNode : canvas;
      const centerCanvas = { x: b.x + b.width / 2, y: b.y + b.height / 2 };
      const centerLocal = canvasPointToParentLocal(parent, centerCanvas.x, centerCanvas.y);
      const startLocal = canvasPointToParentLocal(parent, start.x, start.y);
      const dx = startLocal.x - centerLocal.x;
      const dy = startLocal.y - centerLocal.y;
      const startAngle = Math.atan2(dy, dx) * 180 / Math.PI;
      if (!Number.isFinite(startAngle)) return false;
      state.interaction = {
        type: "rotate",
        start,
        targetId: targetEl.dataset.id,
        centerLocal,
        startAngle,
        baseTransformRaw: String(targetEl.dataset.baseTransform || "").trim(),
        originalTranslate: getTranslate(targetEl),
        moved: false,
        pointerId: null
      };
      clearSmartGuides();
      return true;
    }

    function beginResize(start, targetEl, handle) {
      if (!targetEl || !isResizableElement(targetEl)) return;
      const b = safeBBox(targetEl);
      if (!b) return;
      const aspect = b.height > 0 ? b.width / b.height : 1;
      const snapTargets = buildDragSnapTargets([targetEl]);
      const groupLinearStart = targetEl.tagName === "g" ? getElementLinearMatrix(targetEl) : null;
      const groupLabelCompensations = targetEl.tagName === "g"
        ? Array.from(targetEl.querySelectorAll(':scope > [data-fm-group-label="1"]'))
          .filter((n) => n instanceof SVGElement && n.dataset?.id)
          .map((label) => {
            const attrSize = Number(label.getAttribute("font-size") || "");
            const computedSize = Number.parseFloat(window.getComputedStyle(label).fontSize || "");
            const baseSize = Number(label.dataset.markBaseSize || "");
            const fontSize = Number.isFinite(baseSize) && baseSize > 0
              ? baseSize
              : (Number.isFinite(attrSize) && attrSize > 0
                ? attrSize
                : (Number.isFinite(computedSize) && computedSize > 0 ? computedSize : 16));
            const prior = state.markLabelComp[label.dataset.id] || null;
            const baseRaw = prior && typeof prior.baseTransform === "string"
              ? prior.baseTransform
              : String(label.getAttribute("transform") || "");
            return {
              id: label.dataset.id,
              fontSize,
              baseTransform: String(baseRaw || "").trim()
            };
          })
        : [];
      // Regression note: pasted SVG often carries parent/child transforms.
      // Resizing by editing geometry attrs caused position drift, so resize stays transform-based.
      state.interaction = {
        type: "resize",
        start,
        targetId: targetEl.dataset.id,
        handle,
        originalBox: b,
        baseBox: b,
        baseTransformRaw: String(targetEl.getAttribute("transform") || "").trim(),
        transformResize: true,
        liveBox: b,
        snapTargets,
        groupLinearStart,
        groupLabelCompensations,
        aspect,
        moved: false,
        pointerId: null
      };
      clearSmartGuides();
    }

    function updateRotate(pt, options = {}) {
      const it = state.interaction;
      if (!it || it.type !== "rotate") return;
      const target = getById(it.targetId);
      if (!(target instanceof SVGElement)) return;
      const parent = target.parentNode instanceof SVGElement ? target.parentNode : canvas;
      const local = canvasPointToParentLocal(parent, pt.x, pt.y);
      const angle = Math.atan2(local.y - it.centerLocal.y, local.x - it.centerLocal.x) * 180 / Math.PI;
      if (!Number.isFinite(angle)) return;
      let delta = angle - it.startAngle;
      if (options.snapAngle) delta = Math.round(delta / 15) * 15;
      if (Math.abs(delta) > 0.2) it.moved = true;
      const rotation = `rotate(${Number(delta.toFixed(4))} ${Number(it.centerLocal.x.toFixed(4))} ${Number(it.centerLocal.y.toFixed(4))})`;
      target.dataset.baseTransform = `${rotation}${it.baseTransformRaw ? ` ${it.baseTransformRaw}` : ""}`.trim();
      setTranslate(target, it.originalTranslate.x, it.originalTranslate.y);
      requestSelectionVisualRefresh();
    }

    function finishRotate() {
      const it = state.interaction;
      if (!it || it.type !== "rotate") return;
      if (it.moved) {
        const target = getById(it.targetId);
        if (target instanceof SVGElement) bakeTransformsAfterInteraction([target]);
        pushHistory("rotate");
      }
      state.interaction = null;
    }

    function mapX(x, oldBox, newBox) {
      const denom = Math.max(oldBox.width, 1e-6);
      return newBox.x + ((x - oldBox.x) / denom) * newBox.width;
    }

    function mapY(y, oldBox, newBox) {
      const denom = Math.max(oldBox.height, 1e-6);
      return newBox.y + ((y - oldBox.y) / denom) * newBox.height;
    }

    function scalePathD(d, oldBox, newBox, offset) {
      const tokens = [];
      const re = /([a-zA-Z])|([-+]?\d*\.?\d+(?:e[-+]?\d+)?)/g;
      let m;
      while ((m = re.exec(d)) !== null) {
        if (m[1]) tokens.push({ type: "cmd", value: m[1] });
        else tokens.push({ type: "num", value: Number(m[2]) });
      }
      const out = [];
      let i = 0;
      let cmd = "";
      const sx = newBox.width / Math.max(oldBox.width, 1e-6);
      const sy = newBox.height / Math.max(oldBox.height, 1e-6);
      const mapAbsX = (x) => mapX(x + offset.x, oldBox, newBox) - offset.x;
      const mapAbsY = (y) => mapY(y + offset.y, oldBox, newBox) - offset.y;
      const mapRelX = (x) => x * sx;
      const mapRelY = (y) => y * sy;
      const readNum = () => {
        if (i >= tokens.length || tokens[i].type !== "num") return null;
        return tokens[i++].value;
      };
      const emit = (vals) => vals.forEach((v) => out.push(Number.isInteger(v) ? String(v) : String(Number(v.toFixed(4)))));
      while (i < tokens.length) {
        if (tokens[i].type === "cmd") {
          cmd = tokens[i].value;
          out.push(cmd);
          i += 1;
        }
        if (!cmd) break;
        const c = cmd.toLowerCase();
        const rel = cmd === c;
        const need = c === "m" || c === "l" || c === "t" ? 2
          : c === "h" || c === "v" ? 1
          : c === "c" ? 6
          : c === "s" || c === "q" ? 4
          : c === "a" ? 7
          : c === "z" ? 0 : -1;
        if (need === 0) {
          while (i < tokens.length && tokens[i].type !== "cmd") i += 1;
          continue;
        }
        if (need < 0) break;
        if (i < tokens.length && tokens[i].type === "cmd") continue;
        const vals = [];
        for (let k = 0; k < need; k += 1) {
          const v = readNum();
          if (v === null) break;
          vals.push(v);
        }
        if (vals.length < need) break;

        if (c === "h") emit([rel ? mapRelX(vals[0]) : mapAbsX(vals[0])]);
        else if (c === "v") emit([rel ? mapRelY(vals[0]) : mapAbsY(vals[0])]);
        else if (c === "m" || c === "l" || c === "t") {
          emit([rel ? mapRelX(vals[0]) : mapAbsX(vals[0]), rel ? mapRelY(vals[1]) : mapAbsY(vals[1])]);
        } else if (c === "s" || c === "q") {
          emit([
            rel ? mapRelX(vals[0]) : mapAbsX(vals[0]),
            rel ? mapRelY(vals[1]) : mapAbsY(vals[1]),
            rel ? mapRelX(vals[2]) : mapAbsX(vals[2]),
            rel ? mapRelY(vals[3]) : mapAbsY(vals[3])
          ]);
        } else if (c === "c") {
          emit([
            rel ? mapRelX(vals[0]) : mapAbsX(vals[0]),
            rel ? mapRelY(vals[1]) : mapAbsY(vals[1]),
            rel ? mapRelX(vals[2]) : mapAbsX(vals[2]),
            rel ? mapRelY(vals[3]) : mapAbsY(vals[3]),
            rel ? mapRelX(vals[4]) : mapAbsX(vals[4]),
            rel ? mapRelY(vals[5]) : mapAbsY(vals[5])
          ]);
        } else if (c === "a") {
          const rx = Math.max(0.5, Math.abs(vals[0] * sx));
          const ry = Math.max(0.5, Math.abs(vals[1] * sy));
          emit([
            rx,
            ry,
            vals[2],
            vals[3],
            vals[4],
            rel ? mapRelX(vals[5]) : mapAbsX(vals[5]),
            rel ? mapRelY(vals[6]) : mapAbsY(vals[6])
          ]);
        }
      }
      return out.join(" ");
    }

    function scaleSingleElement(el, oldBox, newBox, parentOffset = { x: 0, y: 0 }) {
      if (shouldUseTransformResize(el)) {
        if (applyResizeByTransform(el, oldBox, newBox)) return;
      }
      const t = getTranslate(el);
      if (el.tagName === "rect" || el.tagName === "image") {
        const x = Number(el.getAttribute("x") || 0) + t.x + parentOffset.x;
        const y = Number(el.getAttribute("y") || 0) + t.y + parentOffset.y;
        const x2 = x + Number(el.getAttribute("width") || 0);
        const y2 = y + Number(el.getAttribute("height") || 0);
        const nx = mapX(x, oldBox, newBox);
        const ny = mapY(y, oldBox, newBox);
        const nx2 = mapX(x2, oldBox, newBox);
        const ny2 = mapY(y2, oldBox, newBox);
        el.setAttribute("x", String(nx - t.x - parentOffset.x));
        el.setAttribute("y", String(ny - t.y - parentOffset.y));
        el.setAttribute("width", String(Math.max(1, nx2 - nx)));
        el.setAttribute("height", String(Math.max(1, ny2 - ny)));
        return;
      }
      if (el.tagName === "ellipse") {
        const cx = Number(el.getAttribute("cx") || 0) + t.x + parentOffset.x;
        const cy = Number(el.getAttribute("cy") || 0) + t.y + parentOffset.y;
        const rx = Number(el.getAttribute("rx") || 0);
        const ry = Number(el.getAttribute("ry") || 0);
        const x1 = cx - rx;
        const x2 = cx + rx;
        const y1 = cy - ry;
        const y2 = cy + ry;
        const nx1 = mapX(x1, oldBox, newBox);
        const nx2 = mapX(x2, oldBox, newBox);
        const ny1 = mapY(y1, oldBox, newBox);
        const ny2 = mapY(y2, oldBox, newBox);
        const ncx = (nx1 + nx2) / 2;
        const ncy = (ny1 + ny2) / 2;
        el.setAttribute("cx", String(ncx - t.x - parentOffset.x));
        el.setAttribute("cy", String(ncy - t.y - parentOffset.y));
        el.setAttribute("rx", String(Math.max(0.5, (nx2 - nx1) / 2)));
        el.setAttribute("ry", String(Math.max(0.5, (ny2 - ny1) / 2)));
        return;
      }
      if (el.tagName === "circle") {
        const cx = Number(el.getAttribute("cx") || 0) + t.x + parentOffset.x;
        const cy = Number(el.getAttribute("cy") || 0) + t.y + parentOffset.y;
        const r = Number(el.getAttribute("r") || 0);
        const x1 = cx - r;
        const x2 = cx + r;
        const y1 = cy - r;
        const y2 = cy + r;
        const nx1 = mapX(x1, oldBox, newBox);
        const nx2 = mapX(x2, oldBox, newBox);
        const ny1 = mapY(y1, oldBox, newBox);
        const ny2 = mapY(y2, oldBox, newBox);
        const ncx = (nx1 + nx2) / 2;
        const ncy = (ny1 + ny2) / 2;
        const nr = Math.max(0.5, ((nx2 - nx1) + (ny2 - ny1)) / 4);
        el.setAttribute("cx", String(ncx - t.x - parentOffset.x));
        el.setAttribute("cy", String(ncy - t.y - parentOffset.y));
        el.setAttribute("r", String(nr));
        return;
      }
      if (el.tagName === "line") {
        const x1 = Number(el.getAttribute("x1") || 0) + t.x + parentOffset.x;
        const y1 = Number(el.getAttribute("y1") || 0) + t.y + parentOffset.y;
        const x2 = Number(el.getAttribute("x2") || 0) + t.x + parentOffset.x;
        const y2 = Number(el.getAttribute("y2") || 0) + t.y + parentOffset.y;
        el.setAttribute("x1", String(mapX(x1, oldBox, newBox) - t.x - parentOffset.x));
        el.setAttribute("y1", String(mapY(y1, oldBox, newBox) - t.y - parentOffset.y));
        el.setAttribute("x2", String(mapX(x2, oldBox, newBox) - t.x - parentOffset.x));
        el.setAttribute("y2", String(mapY(y2, oldBox, newBox) - t.y - parentOffset.y));
        return;
      }
      if (el.tagName === "polygon" || el.tagName === "polyline") {
        const pts = String(el.getAttribute("points") || "").trim();
        if (!pts) return;
        const mapped = pts.split(/\s+/).map((pair) => {
          const [pxRaw, pyRaw] = pair.split(",");
          const px = Number(pxRaw);
          const py = Number(pyRaw);
          if (Number.isNaN(px) || Number.isNaN(py)) return pair;
          const wx = px + t.x + parentOffset.x;
          const wy = py + t.y + parentOffset.y;
          const nx = mapX(wx, oldBox, newBox) - t.x - parentOffset.x;
          const ny = mapY(wy, oldBox, newBox) - t.y - parentOffset.y;
          return `${nx},${ny}`;
        });
        el.setAttribute("points", mapped.join(" "));
        return;
      }
      if (el.tagName === "path") {
        const d = String(el.getAttribute("d") || "");
        if (!d) return;
        const mappedD = scalePathD(d, oldBox, newBox, { x: t.x + parentOffset.x, y: t.y + parentOffset.y });
        if (mappedD) el.setAttribute("d", mappedD);
        return;
      }
      if (el.tagName === "text") {
        const x = Number(el.getAttribute("x") || 0) + t.x + parentOffset.x;
        const y = Number(el.getAttribute("y") || 0) + t.y + parentOffset.y;
        const sx = Math.max(newBox.width / Math.max(oldBox.width, 1e-6), 0.05);
        const sy = Math.max(newBox.height / Math.max(oldBox.height, 1e-6), 0.05);
        const fs = Number(el.getAttribute("font-size") || 16);
        const scale = (sx + sy) / 2;
        el.setAttribute("x", String(mapX(x, oldBox, newBox) - t.x - parentOffset.x));
        el.setAttribute("y", String(mapY(y, oldBox, newBox) - t.y - parentOffset.y));
        el.setAttribute("font-size", String(Math.max(6, fs * scale)));
        return;
      }
      if (el.tagName === "g") {
        const nextOffset = { x: parentOffset.x + t.x, y: parentOffset.y + t.y };
        Array.from(el.children).forEach((child) => {
          if (!(child instanceof SVGElement)) return;
          scaleSingleElement(child, oldBox, newBox, nextOffset);
        });
      }
    }

    function updateResize(pt, keepAspect = false, options = {}) {
      const it = state.interaction;
      if (!it || it.type !== "resize") return;
      const el = getById(it.targetId);
      if (!el) return;
      if (it.handle === "line-start" || it.handle === "line-end") {
        if (el.tagName !== "line") return;
        const local = canvasPointToElementLocal(el, pt.x, pt.y);
        if (it.handle === "line-start") {
          el.setAttribute("x1", String(Number(local.x.toFixed(4))));
          el.setAttribute("y1", String(Number(local.y.toFixed(4))));
        } else {
          el.setAttribute("x2", String(Number(local.x.toFixed(4))));
          el.setAttribute("y2", String(Number(local.y.toFixed(4))));
        }
        it.liveBox = safeBBox(el) || it.baseBox;
        it.moved = true;
        requestSelectionVisualRefresh();
        return;
      }
      if (it.handle.startsWith("vertex-")) {
        if (el.tagName !== "polygon" && el.tagName !== "polyline") return;
        const idx = Number(it.handle.slice("vertex-".length));
        const points = parseSvgPoints(el.getAttribute("points"));
        if (!Number.isInteger(idx) || idx < 0 || idx >= points.length) return;
        const local = canvasPointToElementLocal(el, pt.x, pt.y);
        points[idx] = {
          x: Number(local.x.toFixed(4)),
          y: Number(local.y.toFixed(4))
        };
        el.setAttribute("points", formatSvgPoints(points));
        it.liveBox = safeBBox(el) || it.baseBox;
        it.moved = true;
        requestSelectionVisualRefresh();
        return;
      }
      const ob = it.baseBox;
      let left = ob.x;
      let right = ob.x + ob.width;
      let top = ob.y;
      let bottom = ob.y + ob.height;
      if (it.handle.includes("w")) left = Math.min(pt.x, right - MIN_RESIZE_SIZE);
      if (it.handle.includes("e")) right = Math.max(pt.x, left + MIN_RESIZE_SIZE);
      if (it.handle.includes("n")) top = Math.min(pt.y, bottom - MIN_RESIZE_SIZE);
      if (it.handle.includes("s")) bottom = Math.max(pt.y, top + MIN_RESIZE_SIZE);
      let width = Math.max(MIN_RESIZE_SIZE, right - left);
      let height = Math.max(MIN_RESIZE_SIZE, bottom - top);
      if (keepAspect) {
        const aspect = Math.max(0.01, Number(it.aspect || 1));
        if (width / Math.max(height, 1e-6) > aspect) {
          width = height * aspect;
        } else {
          height = width / aspect;
        }
        if (it.handle.includes("w")) left = right - width;
        else right = left + width;
        if (it.handle.includes("n")) top = bottom - height;
        else bottom = top + height;
      }
      const disableSnap = !!options.disableSnap;
      let guides = null;
      if (!disableSnap) {
        const displayScale = Math.max(getCanvasDisplayScale(), 1e-6);
        const snapThreshold = 7 / displayScale;
        const xTargets = it.snapTargets?.xTargets || [];
        const yTargets = it.snapTargets?.yTargets || [];
        if (xTargets.length && (it.handle.includes("w") || it.handle.includes("e"))) {
          const xValues = [];
          if (it.handle.includes("w")) xValues.push(left);
          if (it.handle.includes("e")) xValues.push(right);
          xValues.push((left + right) / 2);
          const bestX = pickBestSnapDelta(0, xValues, xTargets, snapThreshold);
          if (bestX) {
            const ddx = bestX.delta;
            if (it.handle.includes("w")) left += ddx;
            if (it.handle.includes("e")) right += ddx;
            guides = { ...(guides || {}), x: bestX.guide };
          }
        }
        if (yTargets.length && (it.handle.includes("n") || it.handle.includes("s"))) {
          const yValues = [];
          if (it.handle.includes("n")) yValues.push(top);
          if (it.handle.includes("s")) yValues.push(bottom);
          yValues.push((top + bottom) / 2);
          const bestY = pickBestSnapDelta(0, yValues, yTargets, snapThreshold);
          if (bestY) {
            const ddy = bestY.delta;
            if (it.handle.includes("n")) top += ddy;
            if (it.handle.includes("s")) bottom += ddy;
            guides = { ...(guides || {}), y: bestY.guide };
          }
        }
      }
      if (right - left < MIN_RESIZE_SIZE) {
        if (it.handle.includes("w")) left = right - MIN_RESIZE_SIZE;
        else right = left + MIN_RESIZE_SIZE;
      }
      if (bottom - top < MIN_RESIZE_SIZE) {
        if (it.handle.includes("n")) top = bottom - MIN_RESIZE_SIZE;
        else bottom = top + MIN_RESIZE_SIZE;
      }
      if (disableSnap) clearSmartGuides();
      else drawSmartGuides(guides);
      width = Math.max(MIN_RESIZE_SIZE, right - left);
      height = Math.max(MIN_RESIZE_SIZE, bottom - top);
      it.liveBox = { x: left, y: top, width, height };
      applyResizeByTransform(el, ob, it.liveBox, it.baseTransformRaw || "");
      if (el.tagName === "g" && Array.isArray(it.groupLabelCompensations) && it.groupLabelCompensations.length) {
        const startLinear = it.groupLinearStart || { a: 1, b: 0, c: 0, d: 1 };
        const currentLinear = getElementLinearMatrix(el);
        const invCurrent = invertLinearMatrix(currentLinear);
        const compLinear = invCurrent ? multiplyLinearMatrix(invCurrent, startLinear) : { a: 1, b: 0, c: 0, d: 1 };
        const cb = getGroupContentBBox(el);
        it.groupLabelCompensations.forEach((info) => {
          if (!info?.id) return;
          const label = getById(info.id);
          if (!(label instanceof SVGElement) || !isGroupLabel(label)) return;
          if (cb) {
            const local = canvasPointToElementLocal(el, cb.x, cb.y - 6);
            label.setAttribute("x", String(Number(local.x.toFixed(4))));
            label.setAttribute("y", String(Number(local.y.toFixed(4))));
          }
          state.markLabelComp[info.id] = {
            a: Number(compLinear.a.toFixed(8)),
            b: Number(compLinear.b.toFixed(8)),
            c: Number(compLinear.c.toFixed(8)),
            d: Number(compLinear.d.toFixed(8)),
            baseTransform: String(info.baseTransform || "")
          };
          applyMarkLabelCompensation(label);
          const locked = Math.max(6, Math.round(Number(info.fontSize || 16)));
          label.dataset.markBaseSize = String(locked);
          label.setAttribute("font-size", String(locked));
          label.style.setProperty("font-size", `${locked}px`);
        });
      }
      it.moved = true;
      requestSelectionVisualRefresh();
    }

    function finishResize() {
      const it = state.interaction;
      if (!it || it.type !== "resize") return;
      clearSmartGuides();
      if (it.moved) {
        const target = getById(it.targetId);
        if (target instanceof SVGElement) bakeTransformsAfterInteraction([target]);
        pushHistory("resize");
      }
      state.interaction = null;
    }

    function updateDrag(pt, options = {}) {
      const it = state.interaction;
      if (!it || it.type !== "drag") return;
      let dx = pt.x - it.start.x;
      let dy = pt.y - it.start.y;
      const disableSnap = !!options.disableSnap;
      const movingBounds = it.movingBounds;
      const xTargets = it.snapTargets?.xTargets || [];
      const yTargets = it.snapTargets?.yTargets || [];
      const displayScale = Math.max(getCanvasDisplayScale(), 1e-6);
      const snapThreshold = 7 / displayScale;
      let guides = null;
      if (!disableSnap && movingBounds && (xTargets.length || yTargets.length)) {
        const movedLeft = movingBounds.x + dx;
        const movedCx = movingBounds.x + movingBounds.width / 2 + dx;
        const movedRight = movingBounds.x + movingBounds.width + dx;
        const movedTop = movingBounds.y + dy;
        const movedCy = movingBounds.y + movingBounds.height / 2 + dy;
        const movedBottom = movingBounds.y + movingBounds.height + dy;
        const bestX = pickBestSnapDelta(dx, [movedLeft, movedCx, movedRight], xTargets, snapThreshold);
        const bestY = pickBestSnapDelta(dy, [movedTop, movedCy, movedBottom], yTargets, snapThreshold);
        if (bestX) dx = bestX.delta;
        if (bestY) dy = bestY.delta;
        guides = { x: bestX?.guide, y: bestY?.guide };
      }
      if (disableSnap) clearSmartGuides();
      if (Math.abs(dx) > 0.3 || Math.abs(dy) > 0.3) it.moved = true;
      getTopSelectedElements().forEach((el) => {
        const o = it.original.get(el.dataset.id);
        if (!o) return;
        setTranslate(el, o.x + dx, o.y + dy);
      });
      if (!disableSnap) drawSmartGuides(guides);
      requestSelectionVisualRefresh();
    }

    function finishDrag() {
      const it = state.interaction;
      if (!it || it.type !== "drag") return;
      clearSmartGuides();
      if (it.moved) {
        const movedTargets = getTopSelectedElements();
        bakeTransformsAfterInteraction(movedTargets);
      }
      if (it.fromRightCopy) {
        if (!it.moved) {
          (it.clonedIds || []).forEach((id) => {
            const el = getById(id);
            if (el instanceof SVGElement) el.remove();
          });
          if (Array.isArray(it.sourceSelection)) setSelection(it.sourceSelection);
        } else {
          pushHistory("copy-drag");
          state.suppressContextMenuOnce = true;
        }
      } else if (it.moved) {
        pushHistory("drag-move", { coalesce: true, withinMs: 400 });
      }
      state.interaction = null;
    }

    function setupEvents() {
      const menuBar = document.getElementById("menuBar");
      if (menuBar) {
        menuBar.addEventListener("click", (e) => {
          const clickTarget = e.target instanceof Element ? e.target : null;
          if (!clickTarget) return;
          const trigger = clickTarget.closest("[data-menu-trigger]");
          if (trigger) {
            e.preventDefault();
            toggleAppMenu(trigger.dataset.menuTrigger || "");
            return;
          }
          const actionBtn = clickTarget.closest("[data-menu-action]");
          if (actionBtn) {
            e.preventDefault();
            runMenuAction(actionBtn.dataset.menuAction || "");
            closeAppMenus();
          }
        });
      }
      window.addEventListener("pointerdown", (e) => {
        if (!menuBar) return;
        if (!(e.target instanceof Node) || !menuBar.contains(e.target)) closeAppMenus();
      });
      const bindClick = (id, handler) => {
        const el = document.getElementById(id);
        if (el) el.addEventListener("click", handler);
      };

      document.getElementById("toolSelect").addEventListener("click", () => setTool("select", { withStatus: true }));
      document.getElementById("toolDirect").addEventListener("click", () => setTool("direct", { withStatus: true }));
      document.getElementById("toolHand").addEventListener("click", () => setTool("hand", { withStatus: true }));
      document.getElementById("shortcutsBtn").addEventListener("click", showShortcutHelp);
      document.getElementById("shortcutCloseBtn").addEventListener("click", closeShortcutHelp);
      document.getElementById("markEditorUpBtn").addEventListener("click", () => {
        cycleMarkEditorLetter(1);
        if (markEditorInputEl) {
          markEditorInputEl.focus();
          markEditorInputEl.select();
        }
      });
      document.getElementById("markEditorDownBtn").addEventListener("click", () => {
        cycleMarkEditorLetter(-1);
        if (markEditorInputEl) {
          markEditorInputEl.focus();
          markEditorInputEl.select();
        }
      });
      document.getElementById("markEditorApplyBtn").addEventListener("click", applyMarkFromEditor);
      document.getElementById("markEditorCancelBtn").addEventListener("click", () => {
        closeMarkEditor();
      });
      document.getElementById("figureEditorApplyBtn").addEventListener("click", applyFigureFromEditor);
      document.getElementById("figureEditorCancelBtn").addEventListener("click", () => {
        closeFigureEditor();
      });
      if (figureEditorTypeEl instanceof HTMLSelectElement) {
        figureEditorTypeEl.addEventListener("change", () => {
          const prefixEl = figureEditorEl?.querySelector(".figure-editor-prefix");
          if (prefixEl) prefixEl.textContent = getFigurePrefixLabel(figureEditorTypeEl.value);
        });
      }
      if (markEditorInputEl) {
        markEditorInputEl.addEventListener("input", () => {
          markEditorInputEl.value = String(markEditorInputEl.value || "").replace(/[^a-z]/gi, "").slice(0, 1).toUpperCase();
        });
        markEditorInputEl.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            e.stopPropagation();
            applyMarkFromEditor();
          }
          if (e.key === "Escape") {
            e.preventDefault();
            e.stopPropagation();
            closeMarkEditor();
          }
          if (e.key === "ArrowUp") {
            e.preventDefault();
            e.stopPropagation();
            cycleMarkEditorLetter(1);
            markEditorInputEl.select();
          }
          if (e.key === "ArrowDown") {
            e.preventDefault();
            e.stopPropagation();
            cycleMarkEditorLetter(-1);
            markEditorInputEl.select();
          }
        });
      }
      if (figureEditorInputEl) {
        figureEditorInputEl.addEventListener("input", () => {
          const next = normalizeFigureNumber(Number(figureEditorInputEl.value || 1));
          figureEditorInputEl.value = String(next);
        });
        figureEditorInputEl.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            e.stopPropagation();
            applyFigureFromEditor();
          }
          if (e.key === "Escape") {
            e.preventDefault();
            e.stopPropagation();
            closeFigureEditor();
          }
          if (e.key === "ArrowUp") {
            e.preventDefault();
            e.stopPropagation();
            cycleFigureEditorNumber(1);
            figureEditorInputEl.select();
          }
          if (e.key === "ArrowDown") {
            e.preventDefault();
            e.stopPropagation();
            cycleFigureEditorNumber(-1);
            figureEditorInputEl.select();
          }
        });
      }
      if (shortcutModalEl) {
        shortcutModalEl.addEventListener("pointerdown", (e) => {
          if (e.target === shortcutModalEl) closeShortcutHelp();
        });
      }
      document.getElementById("downloadErrorLogBtn").addEventListener("click", downloadErrorLog);
      document.getElementById("dismissErrorNoticeBtn").addEventListener("click", dismissErrorNotice);

      bindClick("newCanvas", newCanvas);
      document.getElementById("addRect").addEventListener("click", addRect);
      document.getElementById("addLine").addEventListener("click", addLine);
      document.getElementById("addTriangle").addEventListener("click", addTriangle);
      document.getElementById("addEllipse").addEventListener("click", addEllipse);
      document.getElementById("addText").addEventListener("click", addText);
      bindClick("undoBtn", undo);
      bindClick("redoBtn", redo);
      bindClick("copyBtn", copySelected);
      bindClick("cutBtn", cutSelected);
      bindClick("pasteBtn", () => {
        // Avoid browser permission prompts on every click.
        pasteInternalClipboard();
      });
      bindClick("pasteReportBtn", showPasteReport);
      bindClick("copyPasteReportBtn", copyPasteReport);
      bindClick("downloadPasteReportBtn", downloadPasteReport);
      bindClick("pasteHistoryBtn", showPasteReportHistory);
      bindClick("copyPasteHistoryBtn", copyPasteReportHistory);
      bindClick("clearPasteHistoryBtn", clearPasteReportHistory);
      document.getElementById("groupBtn").addEventListener("click", groupSelected);
      document.getElementById("ungroupBtn").addEventListener("click", ungroupSelected);
      document.getElementById("duplicateBtn").addEventListener("click", duplicateSelected);
      bindClick("saveSvg", () => { void saveSvg(); });
      bindClick("exportPdf", exportPdf);

      document.querySelectorAll("[data-align]").forEach((btn) => {
        btn.addEventListener("click", () => alignSelected(btn.dataset.align));
      });
      document.querySelectorAll("[data-distribute]").forEach((btn) => {
        btn.addEventListener("click", () => distributeSelected(btn.dataset.distribute));
      });
      document.getElementById("alignBasisSelect").addEventListener("change", (e) => {
        const value = e.target.value === "first" ? "first" : "bbox";
        state.alignBasis = value;
        localStorage.setItem(ALIGN_BASIS_KEY, value);
        setStatus(`Align base: ${value === "first" ? "first selected" : "selection box"}`);
      });
      document.getElementById("matchArrowBtn").addEventListener("click", () => {
        matchSelectedLinesToArrow();
      });
      document.getElementById("lineStrokeWidthInput").addEventListener("change", () => {
        applyLineStrokeWidthToSelection({ push: true, withStatus: true });
      });
      document.getElementById("lineStrokeWidthInput").addEventListener("input", () => {
        applyLineStrokeWidthToSelection({ push: false, withStatus: false });
      });
      document.getElementById("markFontSizeInput").addEventListener("change", () => {
        applyGlobalMarkFontSize({ push: true, withStatus: true });
      });
      document.getElementById("markFontSizeInput").addEventListener("input", () => {
        applyGlobalMarkFontSize({ push: false, withStatus: false });
      });
      document.getElementById("textFontSizeInput").addEventListener("change", () => {
        applyTextFontSizeToSelection({ push: true, withStatus: true });
      });
      document.getElementById("textFontSizeInput").addEventListener("input", () => {
        applyTextFontSizeToSelection({ push: false, withStatus: false });
      });
      document.getElementById("textColorInput").addEventListener("change", () => {
        applyTextColorToSelection({ push: true, withStatus: true });
      });
      document.getElementById("textColorInput").addEventListener("input", () => {
        applyTextColorToSelection({ push: false, withStatus: false });
      });
      document.getElementById("textBoldBtn").addEventListener("click", toggleTextBold);
      document.getElementById("textItalicBtn").addEventListener("click", toggleTextItalic);
      ["textSuperBtn", "textSubBtn"].forEach((id) => {
        const btn = document.getElementById(id);
        if (btn) {
          btn.addEventListener("mousedown", (e) => {
            if (state.textEdit) e.preventDefault();
          });
        }
      });
      document.getElementById("textSuperBtn").addEventListener("click", () => toggleTextScript("super"));
      document.getElementById("textSubBtn").addEventListener("click", () => toggleTextScript("sub"));
      document.getElementById("objectFillColorInput").addEventListener("change", () => {
        applyObjectFillColor({ push: true, withStatus: true });
      });
      document.getElementById("objectFillColorInput").addEventListener("input", () => {
        applyObjectFillColor({ push: false, withStatus: false });
      });
      document.getElementById("objectStrokeColorInput").addEventListener("change", () => {
        applyObjectStrokeColor({ push: true, withStatus: true });
      });
      document.getElementById("objectStrokeColorInput").addEventListener("input", () => {
        applyObjectStrokeColor({ push: false, withStatus: false });
      });
      document.getElementById("objectStrokeToggle").addEventListener("change", () => {
        applyObjectStrokeToggle({ push: true, withStatus: true });
      });
      document.getElementById("cropImageBtn").addEventListener("click", () => {
        cropSelectedImage();
      });
      document.getElementById("cropApplyBtn").addEventListener("click", () => {
        applyCropFromMode();
      });
      document.getElementById("cropCancelBtn").addEventListener("click", () => {
        cancelImageCropMode();
      });
      document.getElementById("zoomOutBtn").addEventListener("click", () => {
        zoomByFactor(1 / 1.2);
      });
      document.getElementById("zoomInBtn").addEventListener("click", () => {
        zoomByFactor(1.2);
      });
      document.getElementById("zoomResetBtn").addEventListener("click", () => {
        setCanvasZoom(1);
      });
      document.getElementById("zoomSlider").addEventListener("input", (e) => {
        const pct = Number(e.target?.value || 100);
        setCanvasZoom(pct / 100, null, null, { silent: true });
      });
      document.getElementById("zoomPercentInput").addEventListener("change", (e) => {
        const raw = Number(e.target?.value || 100);
        const clamped = Math.max(Math.round(MIN_VIEW_SCALE * 100), Math.min(Math.round(MAX_VIEW_SCALE * 100), Math.round(raw)));
        e.target.value = String(clamped);
        setCanvasZoom(clamped / 100);
      });

      const fileInput = document.getElementById("openFileInput");
      const importInput = document.getElementById("importFileInput");
      bindClick("openSvg", () => { void openSvgFile(); });
      bindClick("importSvgBtn", () => {
        if (importInput) importInput.click();
      });
      if (fileInput) fileInput.addEventListener("change", async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        try {
          const text = await file.text();
          const loaded = loadSvgText(text, { fileHandle: null });
          if (!loaded) setStatus("Invalid SVG file.");
        } catch (err) {
          setStatus("File read failed. Please select a valid SVG file.");
          captureError("open-file-read", err, { userMessage: "File read failed." });
        }
        fileInput.value = "";
      });
      if (importInput) importInput.addEventListener("change", async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        try {
          const text = await file.text();
          const imported = importSvgTextFitted(text);
          if (!imported.length) setStatus("Import failed: invalid SVG.");
        } catch (err) {
          setStatus("Import failed. Please select a valid SVG file.");
          captureError("import-file-read", err, { userMessage: "SVG import failed." });
        }
        importInput.value = "";
      });

      const hasDroppedImage = (dt) => {
        if (!dt) return false;
        const files = Array.from(dt.files || []);
        if (files.some((f) => isImageFile(f))) return true;
        const items = Array.from(dt.items || []);
        return items.some((it) => String(it.type || "").toLowerCase().startsWith("image/"));
      };
      const clearDragOver = () => canvasWrapEl.classList.remove("drag-over");
      canvasWrapEl.addEventListener("dragenter", (e) => {
        if (!hasDroppedImage(e.dataTransfer)) return;
        e.preventDefault();
        canvasWrapEl.classList.add("drag-over");
      });
      canvasWrapEl.addEventListener("dragover", (e) => {
        if (!hasDroppedImage(e.dataTransfer)) return;
        e.preventDefault();
        if (e.dataTransfer) e.dataTransfer.dropEffect = "copy";
        canvasWrapEl.classList.add("drag-over");
      });
      canvasWrapEl.addEventListener("dragleave", (e) => {
        if (!(e.target instanceof Node) || !canvasWrapEl.contains(e.relatedTarget)) clearDragOver();
      });
      canvasWrapEl.addEventListener("drop", async (e) => {
        clearDragOver();
        const files = Array.from(e.dataTransfer?.files || []).filter((f) => isImageFile(f));
        if (!files.length) return;
        e.preventDefault();
        const ids = [];
        for (const file of files.slice(0, 20)) {
          try {
            const id = await importImageFile(file, { select: false });
            if (id) ids.push(id);
          } catch (err) {
            captureError("drop-image-import", err, { userMessage: "Dropped image import failed." });
          }
        }
        if (!ids.length) {
          setStatus("Drop import failed: no supported image files.");
          return;
        }
        setSelection(ids);
        pushHistory("drop-image-import");
        setStatus(`Imported ${ids.length} image file(s) by drag & drop.`);
      });

      document.getElementById("autosaveSelect").addEventListener("change", updateAutosaveTimer);
      document.getElementById("restoreLatest").addEventListener("click", () => { void restoreLatest(); });
      document.getElementById("toggleAdvanced").addEventListener("click", () => {
        if (!document.body.classList.contains("compact")) return;
        document.body.classList.toggle("show-advanced");
        setStatus(document.body.classList.contains("show-advanced") ? "Advanced restore options shown." : "Advanced restore options hidden.");
      });
      document.getElementById("restoreFromList").addEventListener("click", () => { void restoreFromList(); });
      canvasWrapEl.addEventListener("wheel", (e) => {
        if (!(e.ctrlKey || e.metaKey)) return;
        e.preventDefault();
        const factor = Math.exp((-e.deltaY || 0) * 0.002);
        zoomByFactor(factor, e.clientX, e.clientY, { silent: true });
      }, { passive: false });
      canvasWrapEl.addEventListener("touchstart", (e) => {
        if (e.touches.length < 2) return;
        const metrics = getTouchMetrics(e.touches);
        if (!metrics || metrics.distance < 4) return;
        state.pinch.active = true;
        state.pinch.startScale = state.viewScale || 1;
        state.pinch.startDistance = metrics.distance;
        if (state.interaction) state.interaction = null;
        requestSelectionVisualRefresh();
        e.preventDefault();
      }, { passive: false });
      canvasWrapEl.addEventListener("touchmove", (e) => {
        if (!state.pinch.active || e.touches.length < 2) return;
        const metrics = getTouchMetrics(e.touches);
        if (!metrics || metrics.distance < 4) return;
        const rawFactor = metrics.distance / Math.max(state.pinch.startDistance, 1);
        const factor = Math.pow(Math.max(0.05, rawFactor), 1.45);
        setCanvasZoom((state.pinch.startScale || 1) * factor, metrics.centerX, metrics.centerY, { silent: true });
        e.preventDefault();
      }, { passive: false });
      const finishPinch = () => {
        if (!state.pinch.active) return;
        state.pinch.active = false;
        state.pinch.startScale = state.viewScale || 1;
        state.pinch.startDistance = 0;
        setStatus(`Zoom ${Math.round((state.viewScale || 1) * 100)}%.`);
      };
      canvasWrapEl.addEventListener("touchend", (e) => {
        if (e.touches.length >= 2) return;
        finishPinch();
      }, { passive: true });
      canvasWrapEl.addEventListener("touchcancel", () => {
        finishPinch();
      }, { passive: true });

      canvas.addEventListener("contextmenu", (e) => {
        if (state.suppressContextMenuOnce) {
          state.suppressContextMenuOnce = false;
          e.preventDefault();
          return;
        }
        e.preventDefault();
        const raw = closestEditableTarget(e.target);
        let target = null;
        if (raw) {
          target = resolveTargetByTool(raw);
          if (target?.dataset?.id && !state.selectedIds.includes(target.dataset.id)) {
            setSelection([target.dataset.id]);
          }
        }
        let group = null;
        if (target) {
          group = target.tagName === "g" ? target : resolveOuterGroup(target);
        } else if (state.selectedIds.length === 1) {
          const selected = getById(state.selectedIds[0]);
          if (selected) group = selected.tagName === "g" ? selected : resolveOuterGroup(selected);
        }
        const groupId = group && group.tagName === "g" ? group.dataset.id || "" : "";
        openContextMenu(e.clientX, e.clientY, { groupId, targetId: target?.dataset?.id || "" });
      });

      ctxMenu.addEventListener("click", (e) => {
        const btn = e.target.closest("button[data-ctx-action]");
        if (!btn || btn.disabled) return;
        const action = btn.dataset.ctxAction || "";
        if (action === "copy") copySelected();
        if (action === "cut") cutSelected();
        if (action === "paste") pasteInternalClipboard();
        if (action === "rasterize-image") promptRasterizeSelectedImage();
        if (action === "mark") promptGroupMark();
        if (action === "mark-clear") clearGroupMark();
        if (action === "group") groupSelected();
        if (action === "ungroup") ungroupSelected();
        if (action === "duplicate") duplicateSelected();
        closeContextMenu();
      });

      window.addEventListener("pointerdown", (e) => {
        if (e.button !== 0) return;
        if (e.pointerType !== "touch") focusPasteSink();
        if (!(e.target instanceof Node)) {
          closeContextMenu();
          closeMarkEditor();
          closeFigureEditor();
          return;
        }
        if (!ctxMenu.contains(e.target)) closeContextMenu();
        if (markEditorEl && !markEditorEl.contains(e.target)) closeMarkEditor();
        if (figureEditorEl && !figureEditorEl.contains(e.target)) closeFigureEditor();
      });

      canvas.addEventListener("pointermove", (e) => {
        if (state.interaction) return;
        const ready = computeRotateHoverReady(e.clientX, e.clientY, e.target);
        if (state.hoverRotateReady !== ready) {
          state.hoverRotateReady = ready;
          updateToolCursor();
        }
      });

      canvas.addEventListener("pointerleave", () => {
        if (!state.hoverRotateReady) return;
        state.hoverRotateReady = false;
        updateToolCursor();
      });

      canvas.addEventListener("pointerdown", (e) => {
        state.hoverRotateReady = false;
        updateToolCursor();
        if (e.button === 2) {
          if (state.pinch.active || state.cropMode) return;
          closeContextMenu();
          closeFigureEditor();
          const pt = getSvgPoint(e.clientX, e.clientY);
          const raw = closestEditableTarget(e.target);
          const stack = getEditableTargetsAtPoint(e.clientX, e.clientY);
          if (!raw && !stack.length) return;
          const effectiveTool = getEffectiveTool();
          let target = null;
          if (effectiveTool === "direct") {
            const directRaw = pickDirectTargetFromStack(stack) || raw || stack[0] || null;
            target = resolveDirectTextLikeTarget(directRaw);
          } else {
            target = resolveTargetByTool(raw || stack[0] || null);
          }
          if (!(target instanceof SVGElement) || !target.dataset.id) return;
          if (!state.selectedIds.includes(target.dataset.id)) setSelection([target.dataset.id]);
          const sourceSelection = [...state.selectedIds];
          const selected = getTopSelectedElements();
          const clonedIds = cloneElements(selected, { offsetX: 0, offsetY: 0, stripGroupLabels: false });
          if (!clonedIds.length) return;
          const clonedEls = clonedIds.map((id) => getById(id)).filter((el) => el instanceof SVGElement);
          if (!clonedEls.length) return;
          setSelection(clonedIds);
          beginDrag(pt, { elements: clonedEls, fromRightCopy: true, sourceSelection, clonedIds });
          if (state.interaction) state.interaction.pointerId = e.pointerId;
          if (canvas.setPointerCapture) canvas.setPointerCapture(e.pointerId);
          return;
        }
        if (e.button !== 0) return;
        if (state.pinch.active) return;
        if (e.pointerType !== "touch") focusPasteSink();
        closeContextMenu();
        closeFigureEditor();
        if (state.cropMode) {
          const pt = getSvgPoint(e.clientX, e.clientY);
          const cm = state.cropMode;
          const cropHandle = e.target instanceof SVGElement ? e.target.closest(".crop-handle") : null;
          if (cropHandle instanceof SVGElement) {
            const handle = String(cropHandle.dataset.handle || "");
            if (!handle) return;
            startCropResize(handle);
            if (state.interaction) state.interaction.pointerId = e.pointerId;
            if (canvas.setPointerCapture) canvas.setPointerCapture(e.pointerId);
            e.preventDefault();
            return;
          }
          if (!pointInRect(pt, cm.imageBox)) {
            setStatus("Crop mode: drag crop handles or move crop box inside image.");
            return;
          }
          if (cm.draftRect && pointInRect(pt, cm.draftRect)) {
            startCropMove(pt);
            if (state.interaction) state.interaction.pointerId = e.pointerId;
            if (canvas.setPointerCapture) canvas.setPointerCapture(e.pointerId);
            e.preventDefault();
            return;
          }
          setStatus("Crop mode: drag one of the 8 handles to trim.");
          return;
        }
        const effectiveTool = getEffectiveTool();
        if (effectiveTool === "hand") {
          beginPan(e.clientX, e.clientY);
          if (state.interaction) state.interaction.pointerId = e.pointerId;
          if (canvas.setPointerCapture) canvas.setPointerCapture(e.pointerId);
          e.preventDefault();
          return;
        }
        const handleEl = e.target instanceof SVGElement ? e.target.closest(".selection-handle") : null;
        if (handleEl instanceof SVGElement) {
          const pt = getSvgPoint(e.clientX, e.clientY);
          const targetId = handleEl.dataset.targetId;
          const handle = handleEl.dataset.handle || "se";
          const target = targetId ? getById(targetId) : null;
          beginResize(pt, target, handle);
          if (state.interaction) state.interaction.pointerId = e.pointerId;
          if (canvas.setPointerCapture) canvas.setPointerCapture(e.pointerId);
          return;
        }
        const pt = getSvgPoint(e.clientX, e.clientY);
        const raw = closestEditableTarget(e.target);
        const stack = getEditableTargetsAtPoint(e.clientX, e.clientY);
        const hasCanvasHit = !!raw || stack.length > 0;
        if (!hasCanvasHit && !e.shiftKey && computeRotateHoverReady(e.clientX, e.clientY, e.target)) {
          const selected = getById(state.selectedIds[0]);
          if (selected instanceof SVGElement && beginRotate(pt, selected)) {
            if (state.interaction) state.interaction.pointerId = e.pointerId;
            if (canvas.setPointerCapture) canvas.setPointerCapture(e.pointerId);
            setStatus("Rotate: drag around selection (Shift to snap 15deg).");
            e.preventDefault();
            return;
          }
        }
        if (hasCanvasHit) {
          let target = null;
          if (effectiveTool === "direct") {
            // Direct Selection (White Arrow): Prioritize what's exactly under the cursor
            const directRaw = pickDirectTargetFromStack(stack) || raw || null;
            target = resolveDirectTextLikeTarget(directRaw);

            // Only if we didn't hit a specific shape/text, look for nearby small labels
            if (!target || target.tagName === "g") {
              const labelNear = findNearestLabelLikeTargetByPoint(pt, 20); // Reduced radius from 44 to 20
              if (labelNear) target = resolveDirectTextLikeTarget(labelNear.el);
            }
          } else {
            // Selection (Black Arrow): Select the outermost group
            target = resolveTargetByTool(raw || stack[0]);
          }

          if (!target || !target.dataset.id) return;
          const id = target.dataset.id;
          if (e.shiftKey) {
            toggleSelection(id);
            return;
          }
          if (state.selectedIds.length !== 1 || state.selectedIds[0] !== id) setSelection([id]);
          beginDrag(pt);
          if (state.interaction) state.interaction.pointerId = e.pointerId;
          if (canvas.setPointerCapture) canvas.setPointerCapture(e.pointerId);
          return;
        }
        beginMarquee(pt, e.shiftKey);
        if (state.interaction) state.interaction.pointerId = e.pointerId;
        if (canvas.setPointerCapture) canvas.setPointerCapture(e.pointerId);
        if (!e.shiftKey) clearSelection();
      });

      canvas.addEventListener("click", (e) => {
        if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) return;
        const raw = closestEditableTarget(e.target);
        if (!(raw instanceof SVGElement)) return;
        const target = resolveDirectTextLikeTarget(raw);
        if (!(target instanceof SVGElement) || !isFigureTitle(target)) return;
        openFigureEditorFor(target, e.clientX, e.clientY);
      });

      canvas.addEventListener("dblclick", (e) => {
        let textEl = null;
        if (e.target instanceof SVGElement) {
          const t = e.target.closest("text");
          if (t instanceof SVGElement) textEl = t;
        }
        if (!textEl) {
          const stack = getEditableTargetsAtPoint(e.clientX, e.clientY);
          const t = stack.find((node) => node instanceof SVGElement && node.tagName === "text" && !isGroupLabel(node));
          if (t instanceof SVGElement) textEl = t;
        }
        if (!textEl && state.selectedIds.length === 1) {
          const selected = getById(state.selectedIds[0]);
          if (selected instanceof SVGElement && selected.tagName === "text" && !isGroupLabel(selected)) {
            textEl = selected;
          }
        }
        if (textEl instanceof SVGElement && isFigureTitle(textEl)) {
          e.preventDefault();
          openFigureEditorFor(textEl, e.clientX, e.clientY);
          return;
        }
        if (!(textEl instanceof SVGElement) || !textEl.dataset.id || isGroupLabel(textEl)) return;
        e.preventDefault();
        openInlineTextEditor(textEl);
      });

      textEditorInput.addEventListener("input", () => {
        if (!state.textEdit) return;
        const nextText = String(textEditorInput.value || "");
        if (nextText === state.textEdit.text) return;
        state.textEdit.text = nextText;
        if (nextText.length !== Number(state.textEdit.runs?.reduce((max, run) => Math.max(max, Number(run?.end || 0)), 0) || 0)) {
          state.textEdit.runs = nextText.length ? [{ start: 0, end: nextText.length, mode: "normal" }] : [];
        } else {
          state.textEdit.runs = normalizeScriptRuns(nextText.length, state.textEdit.runs);
        }
      });

      textEditorInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          closeInlineTextEditor(true);
        }
        if (e.key === "Escape") {
          e.preventDefault();
          closeInlineTextEditor(false);
          setStatus("Text edit canceled.");
        }
      });
      textEditorInput.addEventListener("blur", () => {
        closeInlineTextEditor(true);
      });

      window.addEventListener("pointermove", (e) => {
        const it = state.interaction;
        if (!it) return;
        if (it.pointerId !== null && e.pointerId !== it.pointerId) return;
        const pt = getSvgPoint(e.clientX, e.clientY);
        const disableSnap = !!(e.altKey || e.ctrlKey);
        if (it.type === "pan") updatePan(e.clientX, e.clientY);
        if (it.type === "crop-move") updateCropMove(pt);
        if (it.type === "crop-resize") updateCropResize(pt);
        if (it.type === "drag") updateDrag(pt, { disableSnap });
        if (it.type === "resize") updateResize(pt, e.shiftKey, { disableSnap });
        if (it.type === "rotate") updateRotate(pt, { snapAngle: e.shiftKey });
        if (it.type === "marquee") updateMarquee(pt);
      });

      window.addEventListener("pointerup", (e) => {
        const it = state.interaction;
        if (!it) return;
        if (it.pointerId !== null && e.pointerId !== it.pointerId) return;
        const capturedId = it.pointerId;
        const type = it.type;
        if (type === "pan") finishPan();
        if (type === "crop-move") finishCropMove();
        if (type === "crop-resize") finishCropResize();
        if (type === "drag") finishDrag();
        if (type === "resize") finishResize();
        if (type === "rotate") finishRotate();
        if (type === "marquee") finishMarquee();
        if (capturedId !== null && canvas.releasePointerCapture) {
          try { canvas.releasePointerCapture(capturedId); } catch (_) {}
        }
        updateToolCursor();
      });

      window.addEventListener("pointercancel", (e) => {
        if (!state.interaction) return;
        if (state.interaction.pointerId !== null && e.pointerId !== state.interaction.pointerId) return;
        const capturedId = state.interaction.pointerId;
        if (state.interaction.type === "drag" && state.interaction.fromRightCopy) {
          (state.interaction.clonedIds || []).forEach((id) => {
            const el = getById(id);
            if (el instanceof SVGElement) el.remove();
          });
          if (Array.isArray(state.interaction.sourceSelection)) setSelection(state.interaction.sourceSelection);
        }
        if ((state.interaction.type === "crop-move" || state.interaction.type === "crop-resize") && state.cropMode) {
          state.cropMode.moveOffset = null;
          state.cropMode.resize = null;
          updateCropUi();
        }
        if (state.interaction.type === "pan") {
          canvasWrapEl.classList.remove("is-panning");
          updateToolCursor();
        }
        clearSmartGuides();
        state.interaction = null;
        if (capturedId !== null && canvas.releasePointerCapture) {
          try { canvas.releasePointerCapture(capturedId); } catch (_) {}
        }
        state.hoverRotateReady = false;
        updateToolCursor();
      });

      window.addEventListener("keydown", (e) => {
        if (state.textEdit) {
          return;
        }
        const activeEl = document.activeElement;
        if (isTypingContextElement(activeEl)) {
          if (e.key === "Escape" && closeShortcutHelp()) {
            e.preventDefault();
            return;
          }
          if (e.key === "Escape" && closeMarkEditor()) {
            e.preventDefault();
            return;
          }
          if (e.key === "Escape" && closeFigureEditor()) {
            e.preventDefault();
            return;
          }
          return;
        }
        if (e.key === "Escape" && closeShortcutHelp()) {
          e.preventDefault();
          return;
        }
        if (e.key === "Escape" && closeMarkEditor()) {
          e.preventDefault();
          return;
        }
        if (e.key === "Escape" && closeFigureEditor()) {
          e.preventDefault();
          return;
        }
        if (e.key === "Escape" && state.activeMenu) {
          e.preventDefault();
          closeAppMenus();
          return;
        }
        if (e.key === "Escape" && state.cropMode) {
          e.preventDefault();
          cancelImageCropMode();
          return;
        }
        if (e.key === "Enter" && state.cropMode) {
          e.preventDefault();
          applyCropFromMode();
          return;
        }
        if (e.key === "Escape") {
          closeInlineTextEditor(false);
          closeContextMenu();
          clearSelection();
          return;
        }
        if (e.key === "Delete" || e.key === "Backspace") {
          if (!state.selectedIds.length) return;
          e.preventDefault();
          getTopSelectedElements().forEach((el) => el.remove());
          clearSelection();
          pushHistory("delete");
          return;
        }
        if (e.code === "Space" && !e.ctrlKey && !e.metaKey && !e.altKey) {
          e.preventDefault();
          if (!state.spacePanActive) {
            state.spacePanActive = true;
            syncToolButtons();
            updateToolCursor();
            setStatus("Tool: Hand (Space hold)");
          }
          return;
        }
        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
          if (!state.selectedIds.length) return;
          e.preventDefault();
          const step = e.shiftKey ? 10 : 1;
          if (e.key === "ArrowUp") moveSelection(0, -step, { reason: "move-key", coalesce: true, withinMs: 300 });
          if (e.key === "ArrowDown") moveSelection(0, step, { reason: "move-key", coalesce: true, withinMs: 300 });
          if (e.key === "ArrowLeft") moveSelection(-step, 0, { reason: "move-key", coalesce: true, withinMs: 300 });
          if (e.key === "ArrowRight") moveSelection(step, 0, { reason: "move-key", coalesce: true, withinMs: 300 });
        }
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "z") {
          e.preventDefault();
          if (e.shiftKey) redo(); else undo();
        }
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "y") {
          e.preventDefault();
          redo();
        }
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "d") {
          e.preventDefault();
          duplicateSelected();
        }
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "c") {
          e.preventDefault();
          copySelected();
        }
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "x") {
          e.preventDefault();
          cutSelected();
        }
        if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey && e.key.toLowerCase() === "r") {
          e.preventDefault();
          addRect();
          setStatus("Added Rect.");
          return;
        }
        if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey && e.key.toLowerCase() === "l") {
          e.preventDefault();
          addLine();
          setStatus("Added Line.");
          return;
        }
        if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey && e.key.toLowerCase() === "y") {
          e.preventDefault();
          addTriangle();
          setStatus("Added Triangle.");
          return;
        }
        if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey && e.key.toLowerCase() === "q") {
          e.preventDefault();
          matchSelectedLinesToArrow();
          return;
        }
        if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey && e.key.toLowerCase() === "e") {
          e.preventDefault();
          addEllipse();
          setStatus("Added Ellipse.");
          return;
        }
        if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey && e.key.toLowerCase() === "t") {
          e.preventDefault();
          addText();
          setStatus("Added Text.");
          return;
        }
        if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey && e.key.toLowerCase() === "v") {
          e.preventDefault();
          setTool("select", { withStatus: true });
          return;
        }
        if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey && e.key.toLowerCase() === "a") {
          e.preventDefault();
          setTool("direct", { withStatus: true });
          return;
        }
        if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey && e.key.toLowerCase() === "h") {
          e.preventDefault();
          setTool("hand", { withStatus: true });
          return;
        }
        if ((e.key === "Enter" || e.key === "F2") && !e.ctrlKey && !e.metaKey && !e.altKey) {
          if (state.selectedIds.length !== 1) return;
          const selected = getById(state.selectedIds[0]);
          if (!(selected instanceof SVGElement) || selected.tagName !== "text" || isGroupLabel(selected)) return;
          e.preventDefault();
          openInlineTextEditor(selected);
          return;
        }
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === "v") {
          e.preventDefault();
          pasteInternalClipboard();
          return;
        }
        if ((e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey && e.key.toLowerCase() === "v") {
          // Prefer OS paste path; if no external payload arrives, fallback to internal clipboard.
          focusPasteSink();
          if (state.pendingInternalPasteTimer) clearTimeout(state.pendingInternalPasteTimer);
          const before = Date.now();
          state.pendingInternalPasteTimer = window.setTimeout(() => {
            state.pendingInternalPasteTimer = 0;
            if (state.lastExternalPasteAt > before) return;
            if (!state.clipboardItems.length) return;
            pasteInternalClipboard();
          }, 90);
        }
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === "r") {
          e.preventDefault();
          void restoreLatest();
        }
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === "i") {
          e.preventDefault();
          showPasteReport();
        }
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === "j") {
          e.preventDefault();
          copyPasteReport();
        }
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === "k") {
          e.preventDefault();
          downloadPasteReport();
        }
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === "h") {
          e.preventDefault();
          showPasteReportHistory();
        }
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === "u") {
          e.preventDefault();
          copyPasteReportHistory();
        }
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === "l") {
          e.preventDefault();
          clearPasteReportHistory();
        }
        if ((e.ctrlKey || e.metaKey) && e.key === "/") {
          e.preventDefault();
          showShortcutHelp();
        }
      });

      window.addEventListener("keyup", (e) => {
        if (e.code !== "Space") return;
        if (!state.spacePanActive) return;
        state.spacePanActive = false;
        syncToolButtons();
        updateToolCursor();
      });

      window.addEventListener("paste", handlePaste);
      document.addEventListener("paste", handlePaste);
      canvasWrapEl.addEventListener("paste", handlePaste);
      if (pasteSinkEl) pasteSinkEl.addEventListener("paste", handlePaste);
      // window.addEventListener("focus", focusPasteSink);
      window.addEventListener("resize", renderStatus);
      window.addEventListener("beforeunload", () => {
        void writeLiveAutosave("beforeunload");
        if (document.getElementById("autosaveSelect").value !== "off") void saveAutosave();
      });
    }

    async function initialize() {
      setupGlobalErrorHandlers();
      setupEventRingHooks();
      state.viewScale = 1;
      applyCanvasMeta({ viewBox: DEFAULT_VIEWBOX }, { centerScroll: true });
      applySnapshotMarkup("");
      assignIds();
      syncCanvasDisplaySizeFromViewBox();
      setupEvents();
      setupButtonTooltips();
      setupHoverTooltips();
      setupToolbarTabs();
      // focusPasteSink();
      syncToolButtons();
      updateToolCursor();
      syncZoomControls();
      updateCropUi();
      try {
        const lastErr = JSON.parse(localStorage.getItem(LAST_ERROR_KEY) || "null");
        if (lastErr && typeof lastErr === "object" && lastErr.id) {
          state.lastErrorRecord = lastErr;
          // Keep record for download, but don't auto-show stale notice on every startup.
          setStatus(`Previous error record loaded: ${lastErr.id}`);
          localStorage.removeItem(LAST_ERROR_KEY);
        }
      } catch (_) {}
      try {
        const parsed = JSON.parse(localStorage.getItem(PASTE_REPORT_KEY) || "null");
        if (parsed && typeof parsed === "object" && parsed.route) {
          state.lastPasteReport = parsed;
        }
      } catch (_) {}
      try {
        const history = JSON.parse(localStorage.getItem(PASTE_REPORT_HISTORY_KEY) || "[]");
        if (Array.isArray(history)) {
          state.pasteReportHistory = history.filter((r) => r && typeof r === "object" && r.route).slice(-30);
        }
      } catch (_) {}
      await migrateLegacyAutosaveStorage();
      const interval = localStorage.getItem(AUTOSAVE_INTERVAL_KEY) || "off";
      document.getElementById("autosaveSelect").value = ["off", "10", "30"].includes(interval) ? interval : "off";
      const alignBasis = localStorage.getItem(ALIGN_BASIS_KEY);
      state.alignBasis = alignBasis === "first" ? "first" : "bbox";
      document.getElementById("alignBasisSelect").value = state.alignBasis;
      await refreshRestoreList();
      updateAutosaveTimer();
      ensureFigureTitle();
      pushHistory("init");
      setStatus("Figure Maker ready.");
    }

    initialize().catch((err) => {
      captureError("initialize", err, { userMessage: "Initialization failed." });
      setStatus("Initialization failed. Reload and try again.");
    });
  </script>
</body>
</html>
