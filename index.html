<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Figure Maker</title>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/svg2pdf.js@2.5.0/dist/svg2pdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvg@4.0.2/lib/umd.min.js"></script>
  <style>
    :root {
      --bg: #f3f4f6;
      --panel: #ffffff;
      --ink: #111827;
      --line: #d1d5db;
      --accent: #2563eb;
      --muted: #6b7280;
    }
    * { box-sizing: border-box; font-family: Arial, sans-serif; }
    body { margin: 0; color: var(--ink); background: var(--bg); }
    .app { height: 100vh; display: grid; grid-template-rows: auto auto 1fr auto; }
    .menu-bar {
      display: flex;
      align-items: center;
      gap: 2px;
      padding: 4px 8px;
      border-bottom: 1px solid var(--line);
      background: #f9fafb;
      user-select: none;
      position: relative;
      z-index: 20;
    }
    .menu-root { position: relative; }
    .menu-trigger {
      border: none;
      background: transparent;
      border-radius: 4px;
      padding: 5px 10px;
      font-size: 13px;
    }
    .menu-root.open .menu-trigger,
    .menu-trigger:hover {
      background: #e5e7eb;
      color: #111827;
    }
    .menu-panel {
      display: none;
      position: absolute;
      top: calc(100% + 4px);
      left: 0;
      min-width: 220px;
      background: #fff;
      border: 1px solid var(--line);
      border-radius: 8px;
      box-shadow: 0 10px 26px rgba(0, 0, 0, 0.16);
      padding: 6px;
    }
    .menu-root.open .menu-panel { display: block; }
    .menu-action {
      display: block;
      width: 100%;
      text-align: left;
      border: none;
      background: transparent;
      border-radius: 5px;
      padding: 7px 9px;
      font-size: 12px;
    }
    .menu-action:hover { background: #eef2ff; }
    .menu-sep {
      height: 1px;
      background: #e5e7eb;
      margin: 6px 0;
    }
    .toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      padding: 8px;
      border-bottom: 1px solid var(--line);
      background: var(--panel);
      align-items: center;
    }
    .group { display: flex; gap: 6px; align-items: center; padding-right: 8px; border-right: 1px solid var(--line); }
    .group:last-child { border-right: none; }
    button, select {
      border: 1px solid var(--line);
      background: #fff;
      color: var(--ink);
      border-radius: 6px;
      padding: 5px 8px;
      font-size: 12px;
      cursor: pointer;
    }
    button.active { background: var(--accent); color: #fff; border-color: var(--accent); }
    .menu-bar .menu-trigger,
    .menu-bar .menu-action {
      border: none;
      background: transparent;
      color: #111827;
    }
    .tool-icon-btn {
      width: 34px;
      height: 30px;
      padding: 3px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .tool-icon-btn svg {
      width: 18px;
      height: 18px;
      display: block;
    }
    .shape-icon-btn {
      width: 34px;
      height: 30px;
      padding: 3px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .shape-icon-btn svg {
      width: 18px;
      height: 18px;
      display: block;
    }
    .align-icon-btn {
      width: 34px;
      height: 30px;
      padding: 3px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .align-icon-btn svg {
      width: 17px;
      height: 17px;
      display: block;
    }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    .canvas-wrap { padding: 10px; overflow: auto; position: relative; }
    #canvas {
      width: 1200px;
      height: 700px;
      background: #fff;
      border: 1px solid var(--line);
      user-select: none;
      touch-action: none;
    }
    .status {
      padding: 6px 10px;
      font-size: 12px;
      color: var(--muted);
      border-top: 1px solid var(--line);
      background: var(--panel);
      min-height: 30px;
    }
    .fm-selected {
      stroke: var(--accent) !important;
      stroke-width: 2 !important;
      stroke-dasharray: 4 2;
    }
    .fm-group-selected {
      stroke: var(--accent) !important;
      stroke-width: 2 !important;
      stroke-dasharray: 4 2;
    }
    .marquee {
      fill: rgba(37, 99, 235, 0.12);
      stroke: var(--accent);
      stroke-dasharray: 4 2;
      pointer-events: none;
    }
    .selection-outline {
      fill: none;
      stroke: var(--accent);
      stroke-width: 1.5;
      stroke-dasharray: 6 3;
      pointer-events: none;
      vector-effect: non-scaling-stroke;
    }
    .selection-handle {
      fill: #ffffff;
      stroke: var(--accent);
      stroke-width: 1.5;
      cursor: nwse-resize;
      vector-effect: non-scaling-stroke;
    }
    .context-menu {
      position: fixed;
      background: #fff;
      border: 1px solid var(--line);
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
      display: none;
      z-index: 10;
      padding: 4px;
      min-width: 110px;
    }
    .context-menu button {
      display: block;
      width: 100%;
      text-align: left;
      border: none;
      background: transparent;
      border-radius: 4px;
      padding: 6px 8px;
    }
    .context-menu button:hover { background: #eef2ff; }
    .context-menu button.disabled,
    .context-menu button:disabled {
      color: #9ca3af;
      background: transparent;
      cursor: default;
      pointer-events: none;
    }
    .fm-group-label {
      font-family: Arial, sans-serif;
      font-size: 16px;
      font-weight: bold;
      fill: #111827;
      pointer-events: none;
    }
    #toggleAdvanced { display: none; }
    body.compact .toolbar { gap: 6px; padding: 6px; }
    body.compact .group { gap: 4px; padding-right: 6px; }
    body.compact button, body.compact select { padding: 4px 6px; font-size: 11px; }
    body.compact .group label { display: none; }
    body.compact #toggleAdvanced { display: inline-block; }
    body.compact #restoreList,
    body.compact #restoreFromList { display: none; }
    body.compact.show-advanced #restoreList,
    body.compact.show-advanced #restoreFromList { display: inline-block; }
    body.compact #canvas { width: 100%; min-width: 900px; height: 68vh; }
    #textEditorInput {
      position: absolute;
      display: none;
      z-index: 30;
      min-width: 120px;
      padding: 4px 6px;
      border: 1px solid var(--accent);
      border-radius: 4px;
      font-size: 16px;
      background: #fff;
      color: var(--ink);
    }
    #pasteSink {
      position: fixed;
      left: -10000px;
      top: -10000px;
      width: 1px;
      height: 1px;
      opacity: 0;
      pointer-events: none;
    }
    #errorNotice {
      position: fixed;
      right: 12px;
      bottom: 12px;
      z-index: 60;
      width: min(540px, calc(100vw - 24px));
      background: #fff7ed;
      border: 1px solid #fdba74;
      border-radius: 10px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
      padding: 10px 12px;
      display: none;
      gap: 8px;
      align-items: flex-start;
    }
    #errorNotice.show { display: flex; }
    #errorNotice strong { color: #9a3412; font-size: 14px; }
    #errorNoticeMeta { font-size: 12px; color: #7c2d12; margin-top: 3px; }
    #errorNoticeActions { margin-left: auto; display: flex; gap: 6px; }
    #shortcutModal {
      position: fixed;
      inset: 0;
      z-index: 70;
      background: rgba(17, 24, 39, 0.35);
      display: none;
      align-items: center;
      justify-content: center;
      padding: 18px;
    }
    #shortcutModal.show { display: flex; }
    #shortcutCard {
      width: min(760px, 100%);
      max-height: min(82vh, 920px);
      background: #ffffff;
      border: 1px solid #d1d5db;
      border-radius: 12px;
      box-shadow: 0 16px 36px rgba(0, 0, 0, 0.2);
      display: grid;
      grid-template-rows: auto 1fr;
      overflow: hidden;
    }
    #shortcutHead {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 10px 12px;
      border-bottom: 1px solid #e5e7eb;
      background: #f9fafb;
    }
    #shortcutHead strong { font-size: 14px; }
    #shortcutHelpText {
      margin: 0;
      padding: 12px;
      white-space: pre-wrap;
      overflow: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      line-height: 1.5;
      background: #ffffff;
      color: #111827;
    }
  </style>
</head>
  <body>
  <div class="app">
    <div id="menuBar" class="menu-bar">
      <div class="menu-root" data-menu-root="file">
        <button class="menu-trigger" data-menu-trigger="file">File</button>
        <div class="menu-panel">
          <button class="menu-action" data-menu-action="file.new">New</button>
          <button class="menu-action" data-menu-action="file.open">Open SVG...</button>
          <button class="menu-action" data-menu-action="file.save">Save SVG</button>
          <button class="menu-action" data-menu-action="file.pdf">Export PDF</button>
        </div>
      </div>
      <div class="menu-root" data-menu-root="edit">
        <button class="menu-trigger" data-menu-trigger="edit">Edit</button>
        <div class="menu-panel">
          <button class="menu-action" data-menu-action="edit.undo">Undo</button>
          <button class="menu-action" data-menu-action="edit.redo">Redo</button>
          <div class="menu-sep"></div>
          <button class="menu-action" data-menu-action="edit.copy">Copy</button>
          <button class="menu-action" data-menu-action="edit.cut">Cut</button>
          <button class="menu-action" data-menu-action="edit.paste">Paste (Internal)</button>
          <div class="menu-sep"></div>
          <button class="menu-action" data-menu-action="edit.group">Group</button>
          <button class="menu-action" data-menu-action="edit.ungroup">Ungroup</button>
        </div>
      </div>
      <div class="menu-root" data-menu-root="view">
        <button class="menu-trigger" data-menu-trigger="view">View</button>
        <div class="menu-panel">
          <button class="menu-action" data-menu-action="view.canvas.a4.portrait">A4 Portrait (794 x 1123)</button>
          <button class="menu-action" data-menu-action="view.canvas.a4.landscape">A4 Landscape (1123 x 794)</button>
          <button class="menu-action" data-menu-action="view.canvas.custom">Canvas Size...</button>
        </div>
      </div>
      <div class="menu-root" data-menu-root="window">
        <button class="menu-trigger" data-menu-trigger="window">Window</button>
        <div class="menu-panel">
          <button class="menu-action" data-menu-action="window.shortcuts">Shortcuts</button>
          <button class="menu-action" data-menu-action="window.restore">Restore Latest Autosave</button>
          <div class="menu-sep"></div>
          <button class="menu-action" data-menu-action="window.pasteReport">Paste Report</button>
          <button class="menu-action" data-menu-action="window.pasteReport.copy">Copy Paste Report</button>
          <button class="menu-action" data-menu-action="window.pasteReport.save">Save Paste Report</button>
          <button class="menu-action" data-menu-action="window.pasteReport.history">Report History</button>
          <button class="menu-action" data-menu-action="window.pasteReport.history.copy">Copy Report History</button>
          <button class="menu-action" data-menu-action="window.pasteReport.history.clear">Clear Report History</button>
        </div>
      </div>
    </div>
    <div class="toolbar">
      <div class="group">
        <button id="toolSelect" class="active tool-icon-btn" title="Black Arrow (V)" aria-label="Black Arrow (V)">
          <svg viewBox="0 0 20 20" aria-hidden="true">
            <path d="M2 1 L2 18 L7 13 L10 19 L12 18 L9 12 L15 12 Z" fill="#111827" stroke="#ffffff" stroke-width="1"></path>
          </svg>
          <span class="sr-only">Black Arrow</span>
        </button>
        <button id="toolDirect" class="tool-icon-btn" title="White Arrow (A)" aria-label="White Arrow (A)">
          <svg viewBox="0 0 20 20" aria-hidden="true">
            <path d="M2 1 L2 18 L7 13 L10 19 L12 18 L9 12 L15 12 Z" fill="#ffffff" stroke="#111827" stroke-width="1.3"></path>
          </svg>
          <span class="sr-only">White Arrow</span>
        </button>
        <button id="undoBtn" class="tool-icon-btn" title="Undo (Ctrl/Cmd+Z)" aria-label="Undo (Ctrl/Cmd+Z)">
          <svg viewBox="0 0 20 20" aria-hidden="true">
            <path d="M7 5 L3 9 L7 13" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"></path>
            <path d="M4 9 H12 C15.2 9 17 10.8 17 14" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"></path>
          </svg>
          <span class="sr-only">Undo</span>
        </button>
        <button id="redoBtn" class="tool-icon-btn" title="Redo (Ctrl/Cmd+Shift+Z)" aria-label="Redo (Ctrl/Cmd+Shift+Z)">
          <svg viewBox="0 0 20 20" aria-hidden="true">
            <path d="M13 5 L17 9 L13 13" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"></path>
            <path d="M16 9 H8 C4.8 9 3 10.8 3 14" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"></path>
          </svg>
          <span class="sr-only">Redo</span>
        </button>
        <button id="shortcutsBtn">Shortcuts</button>
      </div>
      <div class="group">
        <button id="addRect" class="shape-icon-btn" title="Rect (R)" aria-label="Rect (R)">
          <svg viewBox="0 0 20 20" aria-hidden="true">
            <rect x="3" y="4" width="14" height="12" fill="none" stroke="currentColor" stroke-width="1.6"></rect>
          </svg>
          <span class="sr-only">Rect</span>
        </button>
        <button id="addEllipse" class="shape-icon-btn" title="Ellipse (E)" aria-label="Ellipse (E)">
          <svg viewBox="0 0 20 20" aria-hidden="true">
            <ellipse cx="10" cy="10" rx="7" ry="5.5" fill="none" stroke="currentColor" stroke-width="1.6"></ellipse>
          </svg>
          <span class="sr-only">Ellipse</span>
        </button>
        <button id="addLine" class="shape-icon-btn" title="Line (L)" aria-label="Line (L)">
          <svg viewBox="0 0 20 20" aria-hidden="true">
            <path d="M3 10 H17" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"></path>
          </svg>
          <span class="sr-only">Line</span>
        </button>
        <button id="addArrow" class="shape-icon-btn" title="Arrow (Q)" aria-label="Arrow (Q)">
          <svg viewBox="0 0 20 20" aria-hidden="true">
            <path d="M3 10 H13" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round"></path>
            <path d="M11 6 L17 10 L11 14 Z" fill="currentColor"></path>
          </svg>
          <span class="sr-only">Arrow</span>
        </button>
        <label for="arrowSizeInput">Arrow head</label>
        <input id="arrowSizeInput" type="number" min="4" max="40" step="1" value="10" style="width:64px" />
        <label for="arrowStrokeInput">Line/Arrow stroke</label>
        <input id="arrowStrokeInput" type="number" min="1" max="20" step="1" value="3" style="width:64px" />
        <button id="addText">Text</button>
      </div>
      <div class="group">
        <button id="groupBtn">Group</button>
        <button id="ungroupBtn">Ungroup</button>
        <button id="duplicateBtn">Duplicate</button>
      </div>
      <div class="group">
        <label for="alignBasisSelect">Align base</label>
        <select id="alignBasisSelect">
          <option value="bbox">Selection Box</option>
          <option value="first">First Selected</option>
        </select>
        <button class="align-icon-btn" data-align="left" title="Align Left" aria-label="Align Left">
          <svg viewBox="0 0 16 16" aria-hidden="true">
            <path d="M2 2V14M4 5H12M4 9H10" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/>
          </svg>
        </button>
        <button class="align-icon-btn" data-align="hcenter" title="Align Center" aria-label="Align Center">
          <svg viewBox="0 0 16 16" aria-hidden="true">
            <path d="M8 2V14M2 5H14M4 9H12" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/>
          </svg>
        </button>
        <button class="align-icon-btn" data-align="right" title="Align Right" aria-label="Align Right">
          <svg viewBox="0 0 16 16" aria-hidden="true">
            <path d="M14 2V14M4 5H12M6 9H12" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/>
          </svg>
        </button>
        <button class="align-icon-btn" data-align="top" title="Align Top" aria-label="Align Top">
          <svg viewBox="0 0 16 16" aria-hidden="true">
            <path d="M2 2H14M4 4V12M9 4V10" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/>
          </svg>
        </button>
        <button class="align-icon-btn" data-align="vcenter" title="Align Middle" aria-label="Align Middle">
          <svg viewBox="0 0 16 16" aria-hidden="true">
            <path d="M2 8H14M4 3V13M9 5V11" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/>
          </svg>
        </button>
        <button class="align-icon-btn" data-align="bottom" title="Align Bottom" aria-label="Align Bottom">
          <svg viewBox="0 0 16 16" aria-hidden="true">
            <path d="M2 14H14M4 4V12M9 6V12" fill="none" stroke="currentColor" stroke-width="1.3" stroke-linecap="round"/>
          </svg>
        </button>
        <button class="align-icon-btn" data-distribute="h" title="Distribute Horizontal" aria-label="Distribute Horizontal">
          <svg viewBox="0 0 16 16" aria-hidden="true">
            <path d="M2 2V14M14 2V14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round"/>
            <rect x="4.5" y="5" width="2" height="6" fill="none" stroke="currentColor" stroke-width="1.2"/>
            <rect x="9.5" y="5" width="2" height="6" fill="none" stroke="currentColor" stroke-width="1.2"/>
          </svg>
        </button>
        <button class="align-icon-btn" data-distribute="v" title="Distribute Vertical" aria-label="Distribute Vertical">
          <svg viewBox="0 0 16 16" aria-hidden="true">
            <path d="M2 2H14M2 14H14" fill="none" stroke="currentColor" stroke-width="1.2" stroke-linecap="round"/>
            <rect x="5" y="4.5" width="6" height="2" fill="none" stroke="currentColor" stroke-width="1.2"/>
            <rect x="5" y="9.5" width="6" height="2" fill="none" stroke="currentColor" stroke-width="1.2"/>
          </svg>
        </button>
      </div>
      <div class="group">
        <label for="autosaveSelect">Autosave</label>
        <select id="autosaveSelect">
          <option value="off">Off</option>
          <option value="10">10 min</option>
          <option value="30">30 min</option>
        </select>
        <button id="restoreLatest">Restore latest</button>
        <button id="toggleAdvanced">More</button>
        <select id="restoreList"></select>
        <button id="restoreFromList">Restore selected</button>
      </div>
    </div>
    <input id="openFileInput" type="file" accept=".svg,image/svg+xml" hidden />
    <div class="canvas-wrap" tabindex="0">
      <svg id="canvas" viewBox="0 0 794 1123" xmlns="http://www.w3.org/2000/svg"></svg>
      <input id="textEditorInput" type="text" />
    </div>
    <textarea id="pasteSink" aria-hidden="true"></textarea>
    <div id="status" class="status">Ready.</div>
  </div>

  <div id="ctxMenu" class="context-menu">
    <button data-ctx-action="copy">Copy</button>
    <button data-ctx-action="cut">Cut</button>
    <button data-ctx-action="paste">Paste</button>
    <div class="menu-sep"></div>
    <button data-ctx-action="mark">Mark (A-Z)...</button>
    <button data-ctx-action="mark-clear">Clear Mark</button>
    <div class="menu-sep"></div>
    <button data-ctx-action="group">Group</button>
    <button data-ctx-action="ungroup">Ungroup</button>
    <button data-ctx-action="duplicate">Duplicate</button>
  </div>

  <div id="errorNotice" role="alert" aria-live="assertive">
    <div>
      <strong id="errorNoticeTitle">Error ID: -</strong>
      <div id="errorNoticeMeta">An unexpected error occurred.</div>
    </div>
    <div id="errorNoticeActions">
      <button id="downloadErrorLogBtn">Download log</button>
      <button id="dismissErrorNoticeBtn">Close</button>
    </div>
  </div>
  <div id="shortcutModal" role="dialog" aria-modal="true" aria-labelledby="shortcutModalTitle">
    <div id="shortcutCard">
      <div id="shortcutHead">
        <strong id="shortcutModalTitle">Keyboard Shortcuts</strong>
        <button id="shortcutCloseBtn" type="button">Close</button>
      </div>
      <pre id="shortcutHelpText"></pre>
    </div>
  </div>

  <script>
    const SVG_NS = "http://www.w3.org/2000/svg";
    const XLINK_NS = "http://www.w3.org/1999/xlink";
    const AUTOSAVE_KEY = "figureMaker_autosave_records";
    const AUTOSAVE_INTERVAL_KEY = "figureMaker_autosave_interval";
    const ALIGN_BASIS_KEY = "figureMaker_align_basis";
    const PASTE_REPORT_KEY = "figureMaker_last_paste_report";
    const PASTE_REPORT_HISTORY_KEY = "figureMaker_paste_report_history";
    const LAST_ERROR_KEY = "figureMaker_last_error";
    const DEFAULT_VIEWBOX = "0 0 794 1123";
    const MIN_RESIZE_SIZE = 6;
    const MIN_VIEW_SCALE = 0.25;
    const MAX_VIEW_SCALE = 8;
    const PASTE_LOCK_TIMEOUT_MS = 900;
    const DEBUG_MODE = new URLSearchParams(window.location.search).get("debug") === "1";
    const CURSOR_BLACK = "url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 20 20'%3E%3Cpath d='M2 1 L2 18 L7 13 L10 19 L12 18 L9 12 L15 12 Z' fill='%23111827' stroke='%23ffffff' stroke-width='1'/%3E%3C/svg%3E\") 2 2, default";
    const CURSOR_WHITE = "url(\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 20 20'%3E%3Cpath d='M2 1 L2 18 L7 13 L10 19 L12 18 L9 12 L15 12 Z' fill='%23ffffff' stroke='%23111827' stroke-width='1.3'/%3E%3C/svg%3E\") 2 2, default";

    const canvas = document.getElementById("canvas");
    const canvasWrapEl = document.querySelector(".canvas-wrap");
    const statusEl = document.getElementById("status");
    const restoreListEl = document.getElementById("restoreList");
    const ctxMenu = document.getElementById("ctxMenu");
    const textEditorInput = document.getElementById("textEditorInput");
    const pasteSinkEl = document.getElementById("pasteSink");
    const errorNoticeEl = document.getElementById("errorNotice");
    const errorNoticeTitleEl = document.getElementById("errorNoticeTitle");
    const errorNoticeMetaEl = document.getElementById("errorNoticeMeta");
    const shortcutModalEl = document.getElementById("shortcutModal");
    const shortcutHelpTextEl = document.getElementById("shortcutHelpText");
    const processedPasteEvents = new WeakSet();

    const state = {
      tool: "select",
      selectedIds: [],
      idCounter: 1,
      history: [],
      future: [],
      maxHistory: 100,
      interaction: null,
      autosaveTimer: null,
      contextGroupId: null,
      contextTargetId: null,
      alignBasis: "bbox",
      isExportingPdf: false,
      isPasting: false,
      pasteLockAt: 0,
      clipboardItems: [],
      lastPasteReport: null,
      pasteReportHistory: [],
      eventRing: [],
      eventRingMax: 100,
      lastErrorRecord: null,
      autosaveParseWarned: false,
      textEdit: null,
      selectionRefreshRaf: 0,
      pendingInternalPasteTimer: 0,
      lastExternalPasteAt: 0,
      activeMenu: "",
      viewScale: 1,
      pinch: { active: false, startScale: 1, startDistance: 0 },
      statusMessage: "Ready."
    };

    function makeErrorId() {
      const d = new Date();
      const pad = (n) => String(n).padStart(2, "0");
      const ts = `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}-${pad(d.getHours())}${pad(d.getMinutes())}`;
      const rand = Math.floor(Math.random() * 0x10000).toString(16).padStart(4, "0");
      return `${ts}-${rand}`;
    }

    function pushEventRing(type, detail = {}) {
      const base = { at: new Date().toISOString(), type };
      const payload = DEBUG_MODE ? { ...base, detail } : base;
      state.eventRing.push(payload);
      if (state.eventRing.length > state.eventRingMax) state.eventRing.shift();
    }

    function formatErrorMessage(errLike) {
      if (errLike instanceof Error) return errLike.message || "Unknown error";
      if (typeof errLike === "string") return errLike;
      if (errLike && typeof errLike === "object" && "message" in errLike) return String(errLike.message || "Unknown error");
      return String(errLike || "Unknown error");
    }

    function captureError(kind, errLike, extra = {}) {
      const errorId = makeErrorId();
      const message = formatErrorMessage(errLike);
      const stack = errLike instanceof Error ? String(errLike.stack || "") : "";
      const record = {
        id: errorId,
        kind,
        message,
        stack,
        at: new Date().toISOString(),
        debug: DEBUG_MODE ? 1 : 0,
        url: window.location.href,
        userAgent: navigator.userAgent,
        extra: DEBUG_MODE ? extra : { userMessage: extra.userMessage || "" },
        eventHistory: [...state.eventRing]
      };
      state.lastErrorRecord = record;
      try {
        localStorage.setItem(LAST_ERROR_KEY, JSON.stringify(record));
      } catch (_) {}
      const consolePayload = DEBUG_MODE ? record : {
        id: record.id,
        kind: record.kind,
        message: record.message,
        at: record.at,
        userMessage: record.extra?.userMessage || ""
      };
      console.error("[FigureMakerError]", consolePayload);
      showErrorNotice(record);
      return record;
    }

    function showErrorNotice(record) {
      if (!record || !errorNoticeEl) return;
      errorNoticeTitleEl.textContent = `Error ID: ${record.id}`;
      const userMsg = record.extra?.userMessage || "Unexpected error occurred.";
      errorNoticeMetaEl.textContent = `${userMsg}`;
      errorNoticeEl.classList.add("show");
    }

    function dismissErrorNotice() {
      errorNoticeEl.classList.remove("show");
    }

    function downloadErrorLog() {
      const rec = state.lastErrorRecord;
      if (!rec) {
        setStatus("No error log available.");
        return;
      }
      const text = JSON.stringify(rec, null, 2);
      const blob = new Blob([text], { type: "application/json;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `error-${rec.id}.json`;
      a.click();
      setTimeout(() => URL.revokeObjectURL(url), 1500);
      setStatus(`Error log downloaded: ${rec.id}`);
    }

    function setupGlobalErrorHandlers() {
      window.onerror = (message, source, lineno, colno, error) => {
        captureError("window.onerror", error || String(message || "error"), {
          source: source || "",
          line: lineno || 0,
          col: colno || 0,
          userMessage: "Runtime error detected."
        });
      };
      window.onunhandledrejection = (ev) => {
        const reason = ev?.reason instanceof Error ? ev.reason : new Error(formatErrorMessage(ev?.reason));
        captureError("window.onunhandledrejection", reason, {
          userMessage: "Unhandled promise rejection detected."
        });
      };
    }

    function setupEventRingHooks() {
      document.addEventListener("click", (e) => {
        const t = e.target instanceof Element ? e.target.tagName : "";
        pushEventRing("click", { target: t });
      }, true);
      window.addEventListener("keydown", (e) => {
        pushEventRing("key", {
          key: e.key,
          ctrl: !!e.ctrlKey,
          shift: !!e.shiftKey,
          alt: !!e.altKey,
          meta: !!e.metaKey
        });
      }, true);
      window.addEventListener("hashchange", () => pushEventRing("route", { mode: "hashchange", href: location.href }));
      window.addEventListener("popstate", () => pushEventRing("route", { mode: "popstate", href: location.href }));
      const p = history.pushState.bind(history);
      history.pushState = (...args) => {
        const out = p(...args);
        pushEventRing("route", { mode: "pushState", href: location.href });
        return out;
      };
      const r = history.replaceState.bind(history);
      history.replaceState = (...args) => {
        const out = r(...args);
        pushEventRing("route", { mode: "replaceState", href: location.href });
        return out;
      };
    }

    function renderStatus() {
      const compact = window.innerWidth < 980;
      document.body.classList.toggle("compact", compact);
      const advancedBtn = document.getElementById("toggleAdvanced");
      if (!compact) {
        document.body.classList.remove("show-advanced");
      }
      if (advancedBtn) {
        const expanded = compact && document.body.classList.contains("show-advanced");
        advancedBtn.textContent = expanded ? "Less" : "More";
        advancedBtn.setAttribute("aria-expanded", expanded ? "true" : "false");
      }
      const toolName = state.tool === "direct" ? "White Arrow" : "Black Arrow";
      const selectedCount = state.selectedIds.length;
      const histPos = Math.max(1, state.history.length - state.future.length);
      const histTotal = Math.max(1, state.history.length);
      const autosaveSel = document.getElementById("autosaveSelect");
      const autosave = autosaveSel ? autosaveSel.value : "off";
      const alignBase = state.alignBasis === "first" ? "first" : "bbox";
      const zoomPct = Math.round(state.viewScale * 100);
      if (compact) {
        statusEl.textContent = `${state.statusMessage} | ${toolName} | sel:${selectedCount} | z:${zoomPct}% | h:${histPos}/${histTotal}`;
      } else {
        statusEl.textContent = `${state.statusMessage} | tool:${toolName} | sel:${selectedCount} | zoom:${zoomPct}% | hist:${histPos}/${histTotal} | autosave:${autosave} | align:${alignBase}`;
      }
    }

    function setStatus(msg) {
      state.statusMessage = msg;
      renderStatus();
    }

    function createId() {
      const id = `obj-${state.idCounter++}`;
      return id;
    }

    function isHelperElement(el) {
      return !!el && (
        el.classList.contains("selection-outline") ||
        el.classList.contains("selection-handle") ||
        el.classList.contains("marquee")
      );
    }

    function isGroupLabel(el) {
      return !!el && el instanceof SVGElement && el.getAttribute("data-fm-group-label") === "1";
    }

    function ensureId(el) {
      if (!el || !(el instanceof SVGElement)) return;
      if (el === canvas) return;
      if (isHelperElement(el)) return;
      const cur = String(el.dataset.id || "");
      if (!cur) {
        el.dataset.id = createId();
        return;
      }
      try {
        const first = canvas.querySelector(`[data-id="${CSS.escape(cur)}"]`);
        if (first && first !== el) {
          el.dataset.id = createId();
        }
      } catch (_) {
        const first = canvas.querySelector(`[data-id="${cur.replace(/\"/g, "\\\"")}"]`);
        if (first && first !== el) {
          el.dataset.id = createId();
        }
      }
    }

    function applyPointerEventPolicy(el) {
      if (!(el instanceof SVGElement) || el === canvas) return;
      try {
        el.removeAttribute("pointer-events");
        el.style.removeProperty("pointer-events");
      } catch (_) {}
      if (el.tagName === "line" || el.tagName === "polyline") {
        el.setAttribute("pointer-events", "stroke");
        el.style.setProperty("pointer-events", "stroke", "important");
        el.setAttribute("vector-effect", "non-scaling-stroke");
        el.style.setProperty("vector-effect", "non-scaling-stroke", "important");
        return;
      }
      if (el.tagName === "path" || el.tagName === "text" || el.tagName === "tspan" || el.tagName === "rect" || el.tagName === "ellipse" || el.tagName === "circle" || el.tagName === "polygon") {
        el.setAttribute("pointer-events", "visiblePainted");
        el.style.setProperty("pointer-events", "visiblePainted", "important");
        return;
      }
      if (el.tagName === "g") {
        el.setAttribute("pointer-events", "visiblePainted");
        el.style.setProperty("pointer-events", "visiblePainted", "important");
        return;
      }
      if (el.tagName !== "g") {
        el.setAttribute("pointer-events", "visiblePainted");
        el.style.setProperty("pointer-events", "visiblePainted", "important");
      }
    }

    function sanitizeSvgAttributes(el) {
      if (!(el instanceof SVGElement)) return;
      for (const attr of Array.from(el.attributes)) {
        const name = attr.name.toLowerCase();
        const value = String(attr.value || "");
        if (name === "data-id" || name === "data-tx" || name === "data-ty" || name === "data-base-transform") {
          el.removeAttribute(attr.name);
          continue;
        }
        if (name.startsWith("on")) el.removeAttribute(attr.name);
        if ((name === "href" || name.endsWith(":href")) && value.trim().toLowerCase().startsWith("javascript:")) {
          el.removeAttribute(attr.name);
        }
      }
    }

    function sanitizeSvgTree(root) {
      if (!(root instanceof SVGElement)) return;
      root.querySelectorAll("script,foreignObject,iframe,object,embed").forEach((el) => el.remove());
      sanitizeSvgAttributes(root);
      const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
      while (walker.nextNode()) {
        const el = walker.currentNode;
        if (!(el instanceof SVGElement)) continue;
        sanitizeSvgAttributes(el);
        applyPointerEventPolicy(el);
      }
      applyPointerEventPolicy(root);
    }

    function assignIds(root = canvas) {
      const used = new Set();
      const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
      let maxNum = state.idCounter;
      while (walker.nextNode()) {
        const el = walker.currentNode;
        if (!(el instanceof SVGElement)) continue;
        if (isHelperElement(el)) continue;
        const existingId = String(el.dataset.id || "");
        if (existingId && used.has(existingId)) {
          el.dataset.id = "";
        }
        ensureId(el);
        if (el.dataset.id) used.add(el.dataset.id);
        applyPointerEventPolicy(el);
        ensureTransformState(el);
        if (el.dataset.id && /^obj-(\d+)$/.test(el.dataset.id)) {
          const n = Number(el.dataset.id.replace("obj-", ""));
          if (n >= maxNum) maxNum = n + 1;
        }
      }
      state.idCounter = maxNum;
    }

    function isEditableElement(el) {
      if (!(el instanceof SVGElement)) return false;
      if (el === canvas) return false;
      if (isHelperElement(el)) return false;
      if (isGroupLabel(el)) return false;
      if (el.closest("defs,clipPath,mask,marker,symbol,pattern,metadata")) return false;
      const display = String(el.getAttribute("display") || "").trim().toLowerCase();
      const visibility = String(el.getAttribute("visibility") || "").trim().toLowerCase();
      if (display === "none" || visibility === "hidden") return false;
      const supported = ["rect", "line", "ellipse", "circle", "text", "path", "polygon", "polyline", "image", "g", "use", "foreignObject"];
      if (!supported.includes(el.tagName)) return false;
      if (el.tagName === "g") return true;
      if (el.tagName === "image" || el.tagName === "text" || el.tagName === "use" || el.tagName === "foreignObject") return true;
      const cs = window.getComputedStyle ? window.getComputedStyle(el) : null;
      const fillRaw = String(el.getAttribute("fill") || cs?.fill || "").trim().toLowerCase();
      const strokeRaw = String(el.getAttribute("stroke") || cs?.stroke || "").trim().toLowerCase();
      const transparentLike = (v) => v === "none" || v === "transparent" || /rgba\([^)]*,\s*0(?:\.0+)?\s*\)/.test(v);
      const hasFill = fillRaw ? !transparentLike(fillRaw) : true;
      const hasStroke = strokeRaw ? !transparentLike(strokeRaw) : false;
      if (el.tagName === "line" || el.tagName === "polyline") return hasStroke;
      return hasFill || hasStroke;
    }

    function getById(id) {
      return canvas.querySelector(`[data-id="${CSS.escape(id)}"]`);
    }

    function ensureTransformState(el) {
      if (!(el instanceof SVGElement) || el === canvas) return;
      const hasState = el.dataset.tx !== undefined && el.dataset.ty !== undefined && el.dataset.baseTransform !== undefined;
      if (hasState) return;
      const raw = String(el.getAttribute("transform") || "").trim();
      const m = raw.match(/^translate\(\s*([-+]?\d*\.?\d+(?:e[-+]?\d+)?)(?:[\s,]+([-+]?\d*\.?\d+(?:e[-+]?\d+)?))?\s*\)$/i);
      if (m) {
        const parent = el.parentNode instanceof SVGElement ? el.parentNode : canvas;
        const fromLocal = fromParentLocalDelta(parent, Number(m[1] || 0), Number(m[2] || 0));
        el.dataset.baseTransform = "";
        el.dataset.tx = String(Number(fromLocal.dx || 0));
        el.dataset.ty = String(Number(fromLocal.dy || 0));
      } else {
        el.dataset.baseTransform = raw;
        el.dataset.tx = String(Number(el.dataset.tx || 0));
        el.dataset.ty = String(Number(el.dataset.ty || 0));
      }
      setTranslate(el, Number(el.dataset.tx || 0), Number(el.dataset.ty || 0));
    }

    function getTranslate(el) {
      ensureTransformState(el);
      const x = Number(el.dataset.tx || 0);
      const y = Number(el.dataset.ty || 0);
      return { x, y };
    }

    function setTranslate(el, x, y) {
      if (!(el instanceof SVGElement) || el === canvas) return;
      const nx = Number.isFinite(x) ? x : 0;
      const ny = Number.isFinite(y) ? y : 0;
      const base = el.dataset.baseTransform !== undefined ? el.dataset.baseTransform : String(el.getAttribute("transform") || "").trim();
      const parent = el.parentNode instanceof SVGElement ? el.parentNode : canvas;
      const local = toParentLocalDelta(parent, nx, ny);
      const lx = Number(local.dx || 0);
      const ly = Number(local.dy || 0);
      el.dataset.baseTransform = base;
      el.dataset.tx = String(nx);
      el.dataset.ty = String(ny);
      if (base) {
        if (Math.abs(lx) < 1e-9 && Math.abs(ly) < 1e-9) el.setAttribute("transform", base);
        else el.setAttribute("transform", `translate(${lx},${ly}) ${base}`);
      } else {
        if (Math.abs(lx) < 1e-9 && Math.abs(ly) < 1e-9) el.removeAttribute("transform");
        else el.setAttribute("transform", `translate(${lx},${ly})`);
      }
    }

    function applySelectionStyles() {
      canvas.querySelectorAll(".fm-selected").forEach((el) => el.classList.remove("fm-selected"));
      canvas.querySelectorAll(".fm-group-selected").forEach((el) => el.classList.remove("fm-group-selected"));
      for (const id of state.selectedIds) {
        const el = getById(id);
        if (!el) continue;
        if (el.tagName === "g") continue;
        el.classList.add("fm-selected");
      }
      renderSelectionOutlines();
    }

    function requestSelectionVisualRefresh() {
      if (state.interaction && (state.interaction.type === "drag" || state.interaction.type === "resize")) {
        renderSelectionOutlines();
        return;
      }
      if (state.selectionRefreshRaf) return;
      state.selectionRefreshRaf = requestAnimationFrame(() => {
        state.selectionRefreshRaf = 0;
        renderSelectionOutlines();
      });
    }

    function renderSelectionOutlines() {
      canvas.querySelectorAll(".selection-outline,.selection-handle").forEach((el) => el.remove());
      const elements = getTopSelectedElements();
      const displayScale = getCanvasDisplayScale();
      const outlineStroke = Math.max(0.7, 1.5 / Math.max(displayScale, 1e-6));
      elements.forEach((el) => {
        const b = getSelectionRenderBox(el) || safeBBox(el);
        if (!b || b.width <= 0 || b.height <= 0) return;
        const rect = document.createElementNS(SVG_NS, "rect");
        rect.setAttribute("class", "selection-outline");
        rect.setAttribute("stroke-width", String(outlineStroke));
        rect.setAttribute("x", String(b.x));
        rect.setAttribute("y", String(b.y));
        rect.setAttribute("width", String(b.width));
        rect.setAttribute("height", String(b.height));
        canvas.appendChild(rect);
      });
      renderResizeHandles(elements, displayScale);
    }

    function getSelectionRenderBox(el) {
      const it = state.interaction;
      if (!it || it.type !== "resize" || !it.liveBox) return null;
      if (!el || !el.dataset || el.dataset.id !== it.targetId) return null;
      return it.liveBox;
    }

    function isResizableElement(el) {
      return !!el && ["rect", "ellipse", "circle", "image", "line", "text", "polygon", "polyline", "path", "g"].includes(el.tagName);
    }

    function renderResizeHandles(elements, precomputedScale = null) {
      if (elements.length !== 1) return;
      const target = elements[0];
      if (!isResizableElement(target)) return;
      const b = getSelectionRenderBox(target) || safeBBox(target);
      if (!b) return;
      const displayScale = precomputedScale || getCanvasDisplayScale();
      const size = 10 / Math.max(displayScale, 1e-6);
      const stroke = Math.max(0.7, 1.5 / Math.max(displayScale, 1e-6));
      const corners = [
        { name: "nw", x: b.x, y: b.y },
        { name: "ne", x: b.x + b.width, y: b.y },
        { name: "sw", x: b.x, y: b.y + b.height },
        { name: "se", x: b.x + b.width, y: b.y + b.height }
      ];
      corners.forEach((c) => {
        const h = document.createElementNS(SVG_NS, "rect");
        h.setAttribute("class", "selection-handle");
        h.setAttribute("x", String(c.x - size / 2));
        h.setAttribute("y", String(c.y - size / 2));
        h.setAttribute("width", String(size));
        h.setAttribute("height", String(size));
        h.setAttribute("stroke-width", String(stroke));
        h.dataset.handle = c.name;
        h.dataset.targetId = target.dataset.id;
        canvas.appendChild(h);
      });
    }

    function setSelection(ids) {
      state.selectedIds = [...new Set(ids)].filter((id) => {
        const el = getById(id);
        return !!el && isEditableElement(el);
      });
      applySelectionStyles();
      syncArrowControlsFromSelection();
      setStatus(state.selectedIds.length ? `Selected: ${state.selectedIds.length}` : "Ready.");
    }

    function toggleSelection(id) {
      if (!id) return;
      if (state.selectedIds.includes(id)) {
        setSelection(state.selectedIds.filter((s) => s !== id));
      } else {
        setSelection([...state.selectedIds, id]);
      }
    }

    function clearSelection() {
      setSelection([]);
    }

    function focusPasteSink() {
      if (state.textEdit) return;
      if (!(pasteSinkEl instanceof HTMLTextAreaElement)) return;
      try {
        pasteSinkEl.focus({ preventScroll: true });
      } catch (_) {}
    }

    function closestEditableTarget(node) {
      let cur = node;
      while (cur && cur !== canvas) {
        if (isEditableElement(cur) && cur.dataset.id) return cur;
        cur = cur.parentNode;
      }
      return null;
    }

    function resolveOuterGroup(el) {
      let cur = el;
      let outer = null;
      while (cur && cur !== canvas) {
        if (cur.tagName === "g") outer = cur;
        cur = cur.parentNode;
      }
      return outer || el;
    }

    function resolveDirectTextLikeTarget(el) {
      if (!(el instanceof SVGElement)) return el;
      if (el.tagName === "text") return el;
      if (el.tagName === "tspan") {
        const t = el.closest("text");
        if (t instanceof SVGElement) return t;
      }
      let cur = el;
      while (cur && cur !== canvas) {
        if (!(cur instanceof SVGElement)) break;
        if (cur.tagName === "text") return cur;
        if (cur.tagName === "tspan") {
          const t = cur.closest("text");
          if (t instanceof SVGElement) return t;
        }
        cur = cur.parentNode;
      }
      return el;
    }

    function resolveTargetByTool(raw) {
      if (!raw) return null;
      return state.tool === "select" ? resolveOuterGroup(raw) : resolveDirectTextLikeTarget(raw);
    }

    function isTextLikeElement(el) {
      if (!(el instanceof SVGElement)) return false;
      return el.tagName === "text" || el.tagName === "tspan" || el.tagName === "use" || el.tagName === "foreignObject";
    }

    function hasLabelHint(el, depth = 4) {
      let cur = el;
      let n = 0;
      while (cur && cur !== canvas && n <= depth) {
        if (cur instanceof SVGElement) {
          const id = String(cur.getAttribute("id") || "");
          const cls = String(cur.getAttribute("class") || "");
          if (/(text|label|tick|axis|title|xlabel|ylabel|legend)/i.test(`${id} ${cls}`)) return true;
        }
        cur = cur.parentNode;
        n += 1;
      }
      return false;
    }

    function isLabelLikePath(el) {
      if (!(el instanceof SVGElement) || el.tagName !== "path") return false;
      if (hasLabelHint(el, 5)) return true;
      const fill = String(el.getAttribute("fill") || "").toLowerCase();
      const stroke = String(el.getAttribute("stroke") || "").toLowerCase();
      const hasFill = !!fill && fill !== "none";
      const noStroke = !stroke || stroke === "none";
      const b = safeBBox(el);
      if (!b) return false;
      return hasFill && noStroke && b.width <= 220 && b.height <= 90 && (b.width * b.height) <= 12000;
    }

    function isLabelLikeSelectable(el) {
      if (!(el instanceof SVGElement)) return false;
      if (isTextLikeElement(el)) return true;
      return isLabelLikePath(el);
    }

    function findNearestLabelLikeTargetByPoint(pt, maxDist = 44) {
      const all = Array.from(canvas.querySelectorAll("[data-id]"))
        .filter((n) => n instanceof SVGElement)
        .filter((n) => isEditableElement(n))
        .filter((n) => isLabelLikeSelectable(n));
      const cand = [];
      all.forEach((el) => {
        const b = safeBBox(el);
        if (!b) return;
        const dist = rectDistanceToPoint(pt, b);
        if (!Number.isFinite(dist) || dist > maxDist) return;
        cand.push({ el, dist, area: Math.max(1, b.width * b.height) });
      });
      if (!cand.length) return null;
      cand.sort((a, b) => {
        if (a.dist !== b.dist) return a.dist - b.dist;
        return a.area - b.area;
      });
      return cand[0];
    }

    function findEditableTargetByBBoxPoint(pt, preferTextLike = false) {
      const all = Array.from(canvas.querySelectorAll("[data-id]"))
        .filter((n) => n instanceof SVGElement)
        .filter((n) => isEditableElement(n));
      const hit = [];
      all.forEach((el) => {
        const b = safeBBox(el);
        if (!b) return;
        const pad = isTextLikeElement(el) ? 5 : 2;
        const inside = pt.x >= b.x - pad && pt.x <= b.x + b.width + pad && pt.y >= b.y - pad && pt.y <= b.y + b.height + pad;
        if (!inside) return;
        const area = Math.max(1, b.width * b.height);
        hit.push({ el, area, textLike: isTextLikeElement(el) ? 0 : 1 });
      });
      if (!hit.length) return null;
      hit.sort((a, b) => {
        if (preferTextLike && a.textLike !== b.textLike) return a.textLike - b.textLike;
        return a.area - b.area;
      });
      return hit[0].el || null;
    }

    function rectDistanceToPoint(pt, b) {
      const dx = Math.max(b.x - pt.x, 0, pt.x - (b.x + b.width));
      const dy = Math.max(b.y - pt.y, 0, pt.y - (b.y + b.height));
      return Math.hypot(dx, dy);
    }

    function findNearestEditableTargetByPoint(pt, preferTextLike = false, maxDist = 24, textOnly = false) {
      const all = Array.from(canvas.querySelectorAll("[data-id]"))
        .filter((n) => n instanceof SVGElement)
        .filter((n) => isEditableElement(n));
      const cand = [];
      all.forEach((el) => {
        if (textOnly && !isTextLikeElement(el)) return;
        const b = safeBBox(el);
        if (!b) return;
        const dist = rectDistanceToPoint(pt, b);
        if (!Number.isFinite(dist) || dist > maxDist) return;
        cand.push({
          el,
          dist,
          textLike: isTextLikeElement(el) ? 0 : 1,
          area: Math.max(1, b.width * b.height)
        });
      });
      if (!cand.length) return null;
      cand.sort((a, b) => {
        if (preferTextLike && a.textLike !== b.textLike) return a.textLike - b.textLike;
        if (a.dist !== b.dist) return a.dist - b.dist;
        return a.area - b.area;
      });
      return cand[0].el || null;
    }

    function getEditableTargetsAtPoint(clientX, clientY) {
      const stack = [];
      const seen = new Set();
      const els = document.elementsFromPoint(clientX, clientY);
      els.forEach((node) => {
        if (!(node instanceof SVGElement)) return;
        const target = closestEditableTarget(node);
        if (!target || !target.dataset.id) return;
        if (!canvas.contains(target)) return;
        if (seen.has(target.dataset.id)) return;
        seen.add(target.dataset.id);
        stack.push(target);
      });
      return stack;
    }

    function pickDirectTargetFromStack(stack) {
      if (!stack.length) return null;
      const normalized = [];
      const seen = new Set();
      stack.forEach((el) => {
        const n = resolveDirectTextLikeTarget(el);
        if (!n || !n.dataset?.id) return;
        if (seen.has(n.dataset.id)) return;
        seen.add(n.dataset.id);
        normalized.push(n);
      });
      if (!normalized.length) return null;
      const textFirst = normalized.find((el) => el.tagName === "text");
      if (textFirst) return textFirst;
      const nonGroup = normalized.find((el) => el.tagName !== "g");
      return nonGroup || normalized[0];
    }

    function getSvgPoint(clientX, clientY) {
      const pt = canvas.createSVGPoint();
      pt.x = clientX;
      pt.y = clientY;
      const matrix = canvas.getScreenCTM();
      return matrix ? pt.matrixTransform(matrix.inverse()) : { x: 0, y: 0 };
    }

    function intersects(a, b) {
      return a.x <= b.x + b.width && a.x + a.width >= b.x && a.y <= b.y + b.height && a.y + a.height >= b.y;
    }

    function safeBBox(el) {
      try {
        if (el.tagName === "g") {
          const childBoxes = getGroupContentBoxes(el);
          if (childBoxes.length) {
            const minX = Math.min(...childBoxes.map((b) => b.x));
            const minY = Math.min(...childBoxes.map((b) => b.y));
            const maxX = Math.max(...childBoxes.map((b) => b.x + b.width));
            const maxY = Math.max(...childBoxes.map((b) => b.y + b.height));
            return { x: minX, y: minY, width: Math.max(1, maxX - minX), height: Math.max(1, maxY - minY) };
          }
        }
        const local = el.getBBox();
        const elScreen = el.getScreenCTM ? el.getScreenCTM() : null;
        const canvasScreen = canvas.getScreenCTM ? canvas.getScreenCTM() : null;
        let invCanvas = null;
        if (canvasScreen) {
          try {
            invCanvas = canvasScreen.inverse();
          } catch (_) {
            invCanvas = null;
          }
        }
        if (elScreen && invCanvas) {
          const corners = [
            { x: local.x, y: local.y },
            { x: local.x + local.width, y: local.y },
            { x: local.x, y: local.y + local.height },
            { x: local.x + local.width, y: local.y + local.height }
          ];
          const mapped = corners.map((c) => {
            const p = canvas.createSVGPoint();
            p.x = c.x;
            p.y = c.y;
            return p.matrixTransform(elScreen).matrixTransform(invCanvas);
          });
          const minX = Math.min(...mapped.map((p) => p.x));
          const minY = Math.min(...mapped.map((p) => p.y));
          const maxX = Math.max(...mapped.map((p) => p.x));
          const maxY = Math.max(...mapped.map((p) => p.y));
          return {
            x: minX,
            y: minY,
            width: Math.max(1, maxX - minX),
            height: Math.max(1, maxY - minY)
          };
        }
        if (el.isConnected && typeof el.getBoundingClientRect === "function") {
          const er = el.getBoundingClientRect();
          const cr = canvas.getBoundingClientRect();
          if (cr.width > 0 && cr.height > 0) {
            const vb = (canvas.getAttribute("viewBox") || DEFAULT_VIEWBOX).split(/\s+/).map(Number);
            const minX = Number.isFinite(vb[0]) ? vb[0] : 0;
            const minY = Number.isFinite(vb[1]) ? vb[1] : 0;
            const vw = vb[2] || 1200;
            const vh = vb[3] || 700;
            const sx = vw / cr.width;
            const sy = vh / cr.height;
            return {
              x: minX + (er.left - cr.left) * sx,
              y: minY + (er.top - cr.top) * sy,
              width: er.width * sx,
              height: er.height * sy
            };
          }
        }
        const b = el.getBBox();
        const t = getTranslate(el);
        return { x: b.x + t.x, y: b.y + t.y, width: b.width, height: b.height };
      } catch (_) {
        return null;
      }
    }

    function getGroupContentBoxes(groupEl) {
      if (!(groupEl instanceof SVGElement) || groupEl.tagName !== "g") return [];
      return Array.from(groupEl.children)
        .filter((child) => child instanceof SVGElement && !isGroupLabel(child) && !isHelperElement(child))
        .map((child) => safeBBox(child))
        .filter(Boolean);
    }

    function getGroupContentBBox(groupEl) {
      const boxes = getGroupContentBoxes(groupEl);
      if (!boxes.length) return null;
      const minX = Math.min(...boxes.map((b) => b.x));
      const minY = Math.min(...boxes.map((b) => b.y));
      const maxX = Math.max(...boxes.map((b) => b.x + b.width));
      const maxY = Math.max(...boxes.map((b) => b.y + b.height));
      return { x: minX, y: minY, width: Math.max(1, maxX - minX), height: Math.max(1, maxY - minY) };
    }

    function refreshGroupLabelPosition(groupEl) {
      if (!(groupEl instanceof SVGElement) || groupEl.tagName !== "g") return;
      const label = groupEl.querySelector(':scope > [data-fm-group-label="1"]');
      if (!(label instanceof SVGElement)) return;
      const b = getGroupContentBBox(groupEl);
      if (!b) return;
      const gt = getTranslate(groupEl);
      label.setAttribute("x", String(b.x - gt.x));
      label.setAttribute("y", String(b.y - gt.y - 6));
    }

    function refreshAllGroupLabels() {
      canvas.querySelectorAll("g").forEach((g) => refreshGroupLabelPosition(g));
    }

    function getTopSelectedElements() {
      const selected = state.selectedIds.map(getById).filter((el) => !!el && isEditableElement(el));
      return selected.filter((el) => !selected.some((other) => other !== el && other.contains(el)));
    }

    function createShape(tag, attrs, text) {
      const el = document.createElementNS(SVG_NS, tag);
      Object.entries(attrs || {}).forEach(([k, v]) => el.setAttribute(k, String(v)));
      if (text) el.textContent = text;
      ensureId(el);
      applyPointerEventPolicy(el);
      setTranslate(el, 0, 0);
      canvas.appendChild(el);
      return el;
    }

    function addRect() {
      const el = createShape("rect", { x: 120, y: 120, width: 180, height: 110, fill: "#fef3c7", stroke: "#374151", "stroke-width": 2 });
      setSelection([el.dataset.id]);
      pushHistory("add-rect");
    }

    function applyLineStyle(lineEl, stroke) {
      if (!(lineEl instanceof SVGElement) || lineEl.tagName !== "line") return;
      const nextStroke = Math.max(1, Math.min(20, Number(stroke || 3) || 3));
      lineEl.setAttribute("stroke-width", String(nextStroke));
      lineEl.setAttribute("stroke-linecap", "butt");
      lineEl.setAttribute("vector-effect", "non-scaling-stroke");
      lineEl.style.setProperty("vector-effect", "non-scaling-stroke", "important");
    }

    function addLine() {
      const { stroke } = getArrowControlValues();
      const el = createShape("line", { x1: 150, y1: 300, x2: 340, y2: 300, stroke: "#0f172a", "stroke-width": stroke });
      applyLineStyle(el, stroke);
      setSelection([el.dataset.id]);
      pushHistory("add-line");
    }

    function getArrowControlValues() {
      const sizeEl = document.getElementById("arrowSizeInput");
      const strokeEl = document.getElementById("arrowStrokeInput");
      const size = Math.max(4, Math.min(40, Number(sizeEl?.value || 10) || 10));
      const stroke = Math.max(1, Math.min(20, Number(strokeEl?.value || 3) || 3));
      return { size, stroke };
    }

    function ensureCanvasDefs() {
      let defs = canvas.querySelector(":scope > defs");
      if (!defs) {
        defs = document.createElementNS(SVG_NS, "defs");
        canvas.insertBefore(defs, canvas.firstChild);
      }
      return defs;
    }

    function applyArrowStyle(lineEl, size, stroke) {
      if (!(lineEl instanceof SVGElement) || lineEl.tagName !== "line") return;
      ensureId(lineEl);
      const defs = ensureCanvasDefs();
      const markerId = lineEl.dataset.arrowMarkerId || `arrow-m-${lineEl.dataset.id || createId()}`;
      lineEl.dataset.arrowMarkerId = markerId;
      lineEl.dataset.arrow = "1";
      lineEl.dataset.arrowSize = String(size);
      let marker = defs.querySelector(`#${CSS.escape(markerId)}`);
      if (!(marker instanceof SVGElement)) {
        marker = document.createElementNS(SVG_NS, "marker");
        marker.setAttribute("id", markerId);
        marker.setAttribute("orient", "auto");
        marker.setAttribute("markerUnits", "userSpaceOnUse");
        defs.appendChild(marker);
      }
      const tip = size + 2;
      const lead = Math.max(2, Math.min(8, Math.round(Number(stroke || 1) * 1.2)));
      marker.setAttribute("markerWidth", String(tip + lead));
      marker.setAttribute("markerHeight", String(size));
      marker.setAttribute("refX", String(tip - lead));
      marker.setAttribute("refY", String(size / 2));
      marker.setAttribute("viewBox", `0 0 ${tip + lead} ${size}`);
      marker.setAttribute("overflow", "visible");
      marker.innerHTML = "";
      const p = document.createElementNS(SVG_NS, "path");
      p.setAttribute("d", `M 0 0 L ${tip} ${size / 2} L 0 ${size} z`);
      p.setAttribute("fill", String(lineEl.getAttribute("stroke") || "#0f172a"));
      marker.appendChild(p);
      lineEl.setAttribute("marker-end", `url(#${markerId})`);
      applyLineStyle(lineEl, stroke);
    }

    function addArrow() {
      const { size, stroke } = getArrowControlValues();
      const el = createShape("line", { x1: 170, y1: 320, x2: 360, y2: 320, stroke: "#0f172a", "stroke-width": stroke });
      applyArrowStyle(el, size, stroke);
      setSelection([el.dataset.id]);
      pushHistory("add-arrow");
    }

    function syncArrowControlsFromSelection() {
      const sizeEl = document.getElementById("arrowSizeInput");
      const strokeEl = document.getElementById("arrowStrokeInput");
      if (state.selectedIds.length !== 1) return;
      const selected = getById(state.selectedIds[0]);
      if (!(selected instanceof SVGElement) || selected.tagName !== "line") return;
      if (strokeEl) strokeEl.value = String(Number(selected.getAttribute("stroke-width") || 3) || 3);
      if (selected.dataset.arrow !== "1") return;
      if (sizeEl && selected.dataset.arrowSize) sizeEl.value = selected.dataset.arrowSize;
    }

    function applyStrokeControlToSelectedLines(options = {}) {
      const push = options.push !== false;
      const withStatus = options.withStatus !== false;
      const selectedLines = getTopSelectedElements().filter((el) => el instanceof SVGElement && el.tagName === "line");
      if (!selectedLines.length) return false;
      const { size, stroke } = getArrowControlValues();
      let lineCount = 0;
      let arrowCount = 0;
      selectedLines.forEach((line) => {
        if (line.dataset.arrow === "1") {
          applyArrowStyle(line, size, stroke);
          arrowCount += 1;
        } else {
          applyLineStyle(line, stroke);
          lineCount += 1;
        }
      });
      if (push) {
        if (arrowCount && lineCount) pushHistory("line-arrow-style");
        else if (arrowCount) pushHistory("arrow-style");
        else pushHistory("line-style");
      }
      if (withStatus) {
        if (arrowCount && lineCount) setStatus("Line/Arrow style updated.");
        else if (arrowCount) setStatus("Arrow style updated.");
        else setStatus("Line style updated.");
      }
      return true;
    }

    function addEllipse() {
      const el = createShape("ellipse", { cx: 520, cy: 190, rx: 95, ry: 60, fill: "#dbeafe", stroke: "#1e3a8a", "stroke-width": 2 });
      setSelection([el.dataset.id]);
      pushHistory("add-ellipse");
    }

    function addText() {
      const el = createShape("text", { x: 520, y: 330, fill: "#111827", "font-size": 28, "font-family": "Arial" }, "Text");
      setSelection([el.dataset.id]);
      pushHistory("add-text");
    }

    function getCleanCanvasMarkup() {
      const clone = canvas.cloneNode(true);
      clone.querySelectorAll(".selection-outline,.selection-handle,.marquee").forEach((el) => el.remove());
      clone.querySelectorAll(".fm-selected,.fm-group-selected").forEach((el) => {
        el.classList.remove("fm-selected");
        el.classList.remove("fm-group-selected");
        if (el.classList.length === 0) el.removeAttribute("class");
      });
      clone.querySelectorAll("[data-id],[data-tx],[data-ty],[data-base-transform]").forEach((el) => {
        el.removeAttribute("data-id");
        el.removeAttribute("data-tx");
        el.removeAttribute("data-ty");
        el.removeAttribute("data-base-transform");
      });
      return clone.innerHTML;
    }

    function getCanvasMeta() {
      const vb = canvas.getAttribute("viewBox") || DEFAULT_VIEWBOX;
      return { viewBox: vb };
    }

    function applyCanvasMeta(meta) {
      const vb = meta?.viewBox || DEFAULT_VIEWBOX;
      canvas.setAttribute("viewBox", vb);
      syncCanvasDisplaySizeFromViewBox();
    }

    function getCanvasDimensions() {
      const parts = (canvas.getAttribute("viewBox") || DEFAULT_VIEWBOX).split(/\s+/).map(Number);
      const minX = Number.isFinite(parts[0]) ? parts[0] : 0;
      const minY = Number.isFinite(parts[1]) ? parts[1] : 0;
      const width = Number.isFinite(parts[2]) && parts[2] > 0 ? parts[2] : 1200;
      const height = Number.isFinite(parts[3]) && parts[3] > 0 ? parts[3] : 700;
      return { minX, minY, width, height };
    }

    function getCanvasDisplayScale() {
      const rect = canvas.getBoundingClientRect();
      const { width, height } = getCanvasDimensions();
      const sx = rect.width / Math.max(width, 1e-6);
      const sy = rect.height / Math.max(height, 1e-6);
      const s = Math.min(sx, sy);
      return Number.isFinite(s) && s > 0 ? s : 1;
    }

    function getCanvasDisplaySize() {
      const { width, height } = getCanvasDimensions();
      const z = Math.max(MIN_VIEW_SCALE, Math.min(MAX_VIEW_SCALE, Number(state.viewScale) || 1));
      return { width: width * z, height: height * z };
    }

    function syncCanvasDisplaySizeFromViewBox() {
      const display = getCanvasDisplaySize();
      canvas.style.width = `${Math.round(display.width)}px`;
      canvas.style.height = `${Math.round(display.height)}px`;
    }

    function clampViewScale(scale) {
      const n = Number(scale);
      if (!Number.isFinite(n)) return state.viewScale || 1;
      return Math.max(MIN_VIEW_SCALE, Math.min(MAX_VIEW_SCALE, n));
    }

    function setCanvasZoom(scale, anchorClientX = null, anchorClientY = null, options = {}) {
      const next = clampViewScale(scale);
      const prev = clampViewScale(state.viewScale || 1);
      if (Math.abs(next - prev) < 1e-6) return;
      const wrapRect = canvasWrapEl.getBoundingClientRect();
      const oldSize = getCanvasDisplaySize();
      const viewportX = Number.isFinite(anchorClientX) ? anchorClientX - wrapRect.left : canvasWrapEl.clientWidth / 2;
      const viewportY = Number.isFinite(anchorClientY) ? anchorClientY - wrapRect.top : canvasWrapEl.clientHeight / 2;
      const anchorContentX = canvasWrapEl.scrollLeft + viewportX;
      const anchorContentY = canvasWrapEl.scrollTop + viewportY;
      const rx = oldSize.width > 0 ? anchorContentX / oldSize.width : 0.5;
      const ry = oldSize.height > 0 ? anchorContentY / oldSize.height : 0.5;

      state.viewScale = next;
      syncCanvasDisplaySizeFromViewBox();
      requestSelectionVisualRefresh();
      renderStatus();

      const newSize = getCanvasDisplaySize();
      const maxScrollX = Math.max(0, newSize.width - canvasWrapEl.clientWidth);
      const maxScrollY = Math.max(0, newSize.height - canvasWrapEl.clientHeight);
      const targetLeft = Math.max(0, Math.min(maxScrollX, rx * newSize.width - viewportX));
      const targetTop = Math.max(0, Math.min(maxScrollY, ry * newSize.height - viewportY));
      canvasWrapEl.scrollLeft = targetLeft;
      canvasWrapEl.scrollTop = targetTop;

      if (!options.silent) {
        setStatus(`Zoom ${Math.round(next * 100)}%.`);
      }
    }

    function zoomByFactor(factor, anchorClientX = null, anchorClientY = null, options = {}) {
      const f = Number.isFinite(factor) && factor > 0 ? factor : 1;
      setCanvasZoom((state.viewScale || 1) * f, anchorClientX, anchorClientY, options);
    }

    function getTouchMetrics(touches) {
      if (!touches || touches.length < 2) return null;
      const t0 = touches[0];
      const t1 = touches[1];
      const dx = t0.clientX - t1.clientX;
      const dy = t0.clientY - t1.clientY;
      const distance = Math.hypot(dx, dy);
      return {
        distance,
        centerX: (t0.clientX + t1.clientX) / 2,
        centerY: (t0.clientY + t1.clientY) / 2
      };
    }

    function getCleanSvgDocument() {
      const { minX, minY, width, height } = getCanvasDimensions();
      return `<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="${minX} ${minY} ${width} ${height}" width="${width}" height="${height}">${getCleanCanvasMarkup()}</svg>`;
    }

    function updateToolCursor() {
      canvas.style.cursor = state.tool === "direct" ? CURSOR_WHITE : CURSOR_BLACK;
    }

    function setCanvasSize(width, height, options = {}) {
      const w = Math.round(Number(width || 0));
      const h = Math.round(Number(height || 0));
      if (!Number.isFinite(w) || !Number.isFinite(h) || w < 200 || h < 150 || w > 8000 || h > 8000) {
        setStatus("Canvas size must be between 200x150 and 8000x8000.");
        return;
      }
      const { minX, minY } = getCanvasDimensions();
      applyCanvasMeta({ viewBox: `${minX} ${minY} ${w} ${h}` });
      requestSelectionVisualRefresh();
      if (options.push !== false) pushHistory("canvas-size");
      setStatus(`Canvas size set to ${w} x ${h}.`);
    }

    function promptCanvasSize() {
      const cur = getCanvasDimensions();
      const input = window.prompt("Canvas size (width,height)", `${Math.round(cur.width)},${Math.round(cur.height)}`);
      if (!input) return;
      const parts = input.split(/[x, ]+/).map((v) => Number(v.trim())).filter((v) => Number.isFinite(v));
      if (parts.length < 2) {
        setStatus("Invalid canvas size input.");
        return;
      }
      setCanvasSize(parts[0], parts[1], { push: true });
    }

    function closeAppMenus() {
      state.activeMenu = "";
      document.querySelectorAll(".menu-root.open").forEach((el) => el.classList.remove("open"));
    }

    function openAppMenu(name) {
      closeAppMenus();
      const root = document.querySelector(`.menu-root[data-menu-root="${CSS.escape(name)}"]`);
      if (!root) return;
      root.classList.add("open");
      state.activeMenu = name;
    }

    function toggleAppMenu(name) {
      if (!name) return;
      if (state.activeMenu === name) closeAppMenus();
      else openAppMenu(name);
    }

    function runMenuAction(action) {
      if (!action) return;
      if (action === "file.new") return newCanvas();
      if (action === "file.open") {
        const fileInput = document.getElementById("openFileInput");
        if (fileInput) fileInput.click();
        return;
      }
      if (action === "file.save") return saveSvg();
      if (action === "file.pdf") return exportPdf();
      if (action === "edit.undo") return undo();
      if (action === "edit.redo") return redo();
      if (action === "edit.copy") return copySelected();
      if (action === "edit.cut") return cutSelected();
      if (action === "edit.paste") return pasteInternalClipboard();
      if (action === "edit.group") return groupSelected();
      if (action === "edit.ungroup") return ungroupSelected();
      if (action === "view.canvas.a4.portrait") return setCanvasSize(794, 1123);
      if (action === "view.canvas.a4.landscape") return setCanvasSize(1123, 794);
      if (action === "view.canvas.custom") return promptCanvasSize();
      if (action === "window.shortcuts") return showShortcutHelp();
      if (action === "window.restore") return restoreLatest();
      if (action === "window.pasteReport") return showPasteReport();
      if (action === "window.pasteReport.copy") return copyPasteReport();
      if (action === "window.pasteReport.save") return downloadPasteReport();
      if (action === "window.pasteReport.history") return showPasteReportHistory();
      if (action === "window.pasteReport.history.copy") return copyPasteReportHistory();
      if (action === "window.pasteReport.history.clear") return clearPasteReportHistory();
    }

    function getSnapshot(reason = "") {
      refreshAllGroupLabels();
      return { markup: getCleanCanvasMarkup(), selectedIds: [...state.selectedIds], canvasMeta: getCanvasMeta(), at: Date.now(), reason };
    }

    function updateHistoryButtons() {
      const undoBtn = document.getElementById("undoBtn");
      const redoBtn = document.getElementById("redoBtn");
      if (undoBtn) undoBtn.disabled = state.history.length <= 1;
      if (redoBtn) redoBtn.disabled = state.future.length === 0;
    }

    function pushHistory(reason, options = {}) {
      const snap = getSnapshot(reason);
      const last = state.history[state.history.length - 1];
      if (last && last.markup === snap.markup && JSON.stringify(last.selectedIds) === JSON.stringify(snap.selectedIds)) return;
      const sameSelection = last && JSON.stringify(last.selectedIds || []) === JSON.stringify(snap.selectedIds || []);
      if (options.coalesce && last && last.reason === reason && sameSelection) {
        const withinMs = Number(options.withinMs || 0);
        if (withinMs > 0 && Math.abs((snap.at || 0) - (last.at || 0)) > withinMs) {
          // outside the merge window: keep as a new history point
        } else {
          state.history[state.history.length - 1] = snap;
          state.future = [];
          updateHistoryButtons();
          setStatus(`Saved state (${reason}).`);
          return;
        }
      }
      state.history.push(snap);
      if (state.history.length > state.maxHistory) state.history.shift();
      state.future = [];
      updateHistoryButtons();
      setStatus(`Saved state (${reason}).`);
    }

    function resetHistory(reason) {
      const snap = getSnapshot(reason);
      state.history = [snap];
      state.future = [];
      updateHistoryButtons();
    }

    function restoreSnapshot(snap) {
      if (!snap) return;
      applyCanvasMeta(snap.canvasMeta);
      canvas.innerHTML = snap.markup;
      assignIds();
      setSelection(snap.selectedIds || []);
    }

    function undo() {
      if (state.history.length <= 1) {
        setStatus("Undo unavailable.");
        return;
      }
      const current = state.history.pop();
      state.future.push(current);
      restoreSnapshot(state.history[state.history.length - 1]);
      updateHistoryButtons();
      setStatus("Undo.");
    }

    function redo() {
      if (!state.future.length) {
        setStatus("Redo unavailable.");
        return;
      }
      const next = state.future.pop();
      state.history.push(next);
      restoreSnapshot(next);
      updateHistoryButtons();
      setStatus("Redo.");
    }

    function moveSelection(dx, dy, options = {}) {
      if (!state.selectedIds.length) return;
      for (const el of getTopSelectedElements()) {
        const t = getTranslate(el);
        setTranslate(el, t.x + dx, t.y + dy);
      }
      requestSelectionVisualRefresh();
      pushHistory(options.reason || "move", { coalesce: !!options.coalesce });
    }

    function alignSelected(mode) {
      const elements = getTopSelectedElements();
      if (elements.length < 2) {
        setStatus("Align needs 2+ selected objects.");
        return;
      }
      const bounds = elements.map(safeBBox).filter(Boolean);
      if (!bounds.length) return;
      let baseMinX = Math.min(...bounds.map((b) => b.x));
      let baseMaxX = Math.max(...bounds.map((b) => b.x + b.width));
      let baseMinY = Math.min(...bounds.map((b) => b.y));
      let baseMaxY = Math.max(...bounds.map((b) => b.y + b.height));
      let anchorEl = null;
      if (state.alignBasis === "first") {
        const firstId = state.selectedIds.find((id) => elements.some((el) => el.dataset.id === id));
        anchorEl = firstId ? getById(firstId) : elements[0];
        const anchorBox = anchorEl ? safeBBox(anchorEl) : null;
        if (anchorBox) {
          baseMinX = anchorBox.x;
          baseMaxX = anchorBox.x + anchorBox.width;
          baseMinY = anchorBox.y;
          baseMaxY = anchorBox.y + anchorBox.height;
        }
      }
      const centerX = (baseMinX + baseMaxX) / 2;
      const centerY = (baseMinY + baseMaxY) / 2;

      elements.forEach((el) => {
        if (state.alignBasis === "first" && anchorEl && el === anchorEl) return;
        const cur = safeBBox(el);
        if (!cur) return;
        const t = getTranslate(el);
        let dx = 0;
        let dy = 0;
        if (mode === "left") dx = baseMinX - cur.x;
        if (mode === "hcenter") dx = centerX - (cur.x + cur.width / 2);
        if (mode === "right") dx = baseMaxX - (cur.x + cur.width);
        if (mode === "top") dy = baseMinY - cur.y;
        if (mode === "vcenter") dy = centerY - (cur.y + cur.height / 2);
        if (mode === "bottom") dy = baseMaxY - (cur.y + cur.height);
        setTranslate(el, t.x + dx, t.y + dy);
      });
      applySelectionStyles();
      pushHistory(`align-${mode}-${state.alignBasis}`);
    }

    function distributeSelected(axis) {
      const elements = getTopSelectedElements();
      if (elements.length < 3) {
        setStatus("Distribute needs 3+ selected objects.");
        return;
      }
      const items = elements.map((el) => {
        const b = safeBBox(el);
        return b ? { el, b } : null;
      }).filter(Boolean);
      if (items.length < 3) {
        setStatus("Distribute needs 3+ measurable objects.");
        return;
      }

      if (axis === "h") {
        items.sort((a, b) => a.b.x - b.b.x);
        const start = items[0].b.x;
        const end = items[items.length - 1].b.x + items[items.length - 1].b.width;
        const totalSize = items.reduce((sum, item) => sum + item.b.width, 0);
        const gap = (end - start - totalSize) / (items.length - 1);
        let cursor = start;
        items.forEach((item) => {
          const t = getTranslate(item.el);
          const dx = cursor - item.b.x;
          setTranslate(item.el, t.x + dx, t.y);
          cursor += item.b.width + gap;
        });
      } else {
        items.sort((a, b) => a.b.y - b.b.y);
        const start = items[0].b.y;
        const end = items[items.length - 1].b.y + items[items.length - 1].b.height;
        const totalSize = items.reduce((sum, item) => sum + item.b.height, 0);
        const gap = (end - start - totalSize) / (items.length - 1);
        let cursor = start;
        items.forEach((item) => {
          const t = getTranslate(item.el);
          const dy = cursor - item.b.y;
          setTranslate(item.el, t.x, t.y + dy);
          cursor += item.b.height + gap;
        });
      }

      applySelectionStyles();
      pushHistory(`distribute-${axis}`);
    }

    function groupSelected() {
      const elements = getTopSelectedElements();
      if (elements.length < 2) {
        setStatus("Group needs 2+ selected objects.");
        return;
      }
      const parent = elements[0].parentNode;
      if (!elements.every((el) => el.parentNode === parent)) {
        setStatus("Group requires same parent level.");
        return;
      }
      const g = document.createElementNS(SVG_NS, "g");
      ensureId(g);
      setTranslate(g, 0, 0);
      parent.insertBefore(g, elements[0]);
      elements.forEach((el) => g.appendChild(el));
      setSelection([g.dataset.id]);
      pushHistory("group");
    }

    function ungroupSelected() {
      const groups = getTopSelectedElements().filter((el) => el.tagName === "g");
      if (!groups.length) {
        setStatus("Ungroup needs selected group.");
        return;
      }
      const selected = [];
      groups.forEach((g) => {
        const parent = g.parentNode;
        const children = Array.from(g.childNodes);
        children.forEach((child) => {
          if (child instanceof SVGElement && isGroupLabel(child)) {
            child.remove();
            return;
          }
          parent.insertBefore(child, g);
          if (child instanceof SVGElement && child.dataset.id) selected.push(child.dataset.id);
        });
        g.remove();
      });
      setSelection(selected);
      pushHistory("ungroup");
    }

    function duplicateSelected() {
      const elements = getTopSelectedElements();
      if (!elements.length) {
        setStatus("Duplicate needs selected object.");
        return;
      }
      const clones = [];
      elements.forEach((el) => {
        const clone = el.cloneNode(true);
        clone.querySelectorAll?.("[data-id]").forEach((n) => n.removeAttribute("data-id"));
        clone.removeAttribute("data-id");
        sanitizeSvgTree(clone);
        ensureId(clone);
        const t = getTranslate(el);
        setTranslate(clone, t.x + 20, t.y + 20);
        el.parentNode.appendChild(clone);
        assignIds(clone);
        if (clone.dataset.id) clones.push(clone.dataset.id);
      });
      setSelection(clones);
      pushHistory("duplicate");
      setStatus(`Duplicated ${clones.length} object(s).`);
    }

    function collectSelectedClipboardItems() {
      const elements = getTopSelectedElements();
      if (!elements.length) return [];
      return elements.map((el) => ({
        markup: serializeElementForClipboard(el),
        parentId: el.parentElement instanceof SVGElement ? el.parentElement.dataset.id || "" : ""
      }));
    }

    function serializeElementForClipboard(el) {
      const clone = el.cloneNode(true);
      if (clone instanceof SVGElement) {
        clone.classList.remove("fm-selected");
        clone.classList.remove("fm-group-selected");
        clone.querySelectorAll(".fm-selected,.fm-group-selected,.selection-outline,.selection-handle,.marquee").forEach((n) => {
          if (n instanceof SVGElement) {
            n.classList.remove("fm-selected");
            n.classList.remove("fm-group-selected");
            if (isHelperElement(n)) n.remove();
          }
        });
      }
      return clone.outerHTML;
    }

    function buildSelectedSvgClipboardText(items) {
      if (!items || !items.length) return "";
      const { minX, minY, width, height } = getCanvasDimensions();
      const body = items.map((it) => String(it.markup || "")).join("");
      return `<svg xmlns="${SVG_NS}" xmlns:xlink="${XLINK_NS}" viewBox="${minX} ${minY} ${width} ${height}" width="${width}" height="${height}">${body}</svg>`;
    }

    async function copySelectedToSystemClipboard(items) {
      if (!navigator.clipboard?.writeText) return false;
      const text = buildSelectedSvgClipboardText(items);
      if (!text) return false;
      try {
        await navigator.clipboard.writeText(text);
        return true;
      } catch (_) {
        return false;
      }
    }

    function copySelected() {
      const items = collectSelectedClipboardItems();
      if (!items.length) {
        setStatus("Copy needs selected object.");
        return;
      }
      state.clipboardItems = items;
      copySelectedToSystemClipboard(items).then((ok) => {
        if (ok) {
          setStatus(`Copied ${items.length} object(s) to internal + system clipboard.`);
        } else {
          setStatus(`Copied ${items.length} object(s).`);
        }
      });
    }

    function cutSelected() {
      const elements = getTopSelectedElements();
      if (!elements.length) {
        setStatus("Cut needs selected object.");
        return;
      }
      copySelected();
      elements.forEach((el) => el.remove());
      clearSelection();
      pushHistory("cut");
    }

    function resolvePasteParent(parentId) {
      if (!parentId) return canvas;
      const parent = getById(parentId);
      if (parent instanceof SVGElement && (parent === canvas || parent.tagName === "g")) return parent;
      return canvas;
    }

    function toParentLocalDelta(parentEl, dx, dy) {
      if (!(parentEl instanceof SVGElement) || parentEl === canvas) return { dx, dy };
      const parentCTM = parentEl.getScreenCTM ? parentEl.getScreenCTM() : null;
      const canvasCTM = canvas.getScreenCTM ? canvas.getScreenCTM() : null;
      if (!parentCTM || !canvasCTM) return { dx, dy };
      try {
        const p0 = canvas.createSVGPoint();
        const p1 = canvas.createSVGPoint();
        p0.x = 0;
        p0.y = 0;
        p1.x = dx;
        p1.y = dy;
        const s0 = p0.matrixTransform(canvasCTM);
        const s1 = p1.matrixTransform(canvasCTM);
        const invParent = parentCTM.inverse();
        const l0 = s0.matrixTransform(invParent);
        const l1 = s1.matrixTransform(invParent);
        return { dx: l1.x - l0.x, dy: l1.y - l0.y };
      } catch (_) {
        return { dx, dy };
      }
    }

    function fromParentLocalDelta(parentEl, dx, dy) {
      if (!(parentEl instanceof SVGElement) || parentEl === canvas) return { dx, dy };
      const parentCTM = parentEl.getScreenCTM ? parentEl.getScreenCTM() : null;
      const canvasCTM = canvas.getScreenCTM ? canvas.getScreenCTM() : null;
      if (!parentCTM || !canvasCTM) return { dx, dy };
      try {
        const p0 = canvas.createSVGPoint();
        const p1 = canvas.createSVGPoint();
        p0.x = 0;
        p0.y = 0;
        p1.x = dx;
        p1.y = dy;
        const s0 = p0.matrixTransform(parentCTM);
        const s1 = p1.matrixTransform(parentCTM);
        const invCanvas = canvasCTM.inverse();
        const c0 = s0.matrixTransform(invCanvas);
        const c1 = s1.matrixTransform(invCanvas);
        return { dx: c1.x - c0.x, dy: c1.y - c0.y };
      } catch (_) {
        return { dx, dy };
      }
    }

    function canvasPointToParentLocal(parentEl, x, y) {
      if (!(parentEl instanceof SVGElement) || parentEl === canvas) return { x, y };
      const parentCTM = parentEl.getScreenCTM ? parentEl.getScreenCTM() : null;
      const canvasCTM = canvas.getScreenCTM ? canvas.getScreenCTM() : null;
      if (!parentCTM || !canvasCTM) return { x, y };
      try {
        const p = canvas.createSVGPoint();
        p.x = x;
        p.y = y;
        const screen = p.matrixTransform(canvasCTM);
        const local = screen.matrixTransform(parentCTM.inverse());
        return { x: local.x, y: local.y };
      } catch (_) {
        return { x, y };
      }
    }

    function shouldUseTransformResize(el) {
      if (!(el instanceof SVGElement) || el === canvas) return false;
      if (el.tagName === "g") return true;
      const base = String(el.dataset.baseTransform || "").trim();
      if (base) return true;
      const raw = String(el.getAttribute("transform") || "").trim();
      return !!raw && !/^translate\(\s*[-+]?\d*\.?\d+(?:e[-+]?\d+)?(?:[\s,]+[-+]?\d*\.?\d+(?:e[-+]?\d+)?)?\s*\)$/i.test(raw);
    }

    function applyResizeByTransform(el, oldBox, newBox, baseTransformOverride = null) {
      if (!(el instanceof SVGElement)) return false;
      const sx = newBox.width / Math.max(oldBox.width, 1e-6);
      const sy = newBox.height / Math.max(oldBox.height, 1e-6);
      if (!Number.isFinite(sx) || !Number.isFinite(sy) || sx <= 0 || sy <= 0) return false;
      const parent = el.parentNode instanceof SVGElement ? el.parentNode : canvas;
      const oldOrigin = canvasPointToParentLocal(parent, oldBox.x, oldBox.y);
      const newOrigin = canvasPointToParentLocal(parent, newBox.x, newBox.y);
      const current = baseTransformOverride === null ? String(el.getAttribute("transform") || "").trim() : String(baseTransformOverride || "").trim();
      const prefix = `translate(${newOrigin.x},${newOrigin.y}) scale(${sx},${sy}) translate(${-oldOrigin.x},${-oldOrigin.y})`;
      el.dataset.baseTransform = `${prefix}${current ? ` ${current}` : ""}`.trim();
      el.dataset.tx = "0";
      el.dataset.ty = "0";
      setTranslate(el, 0, 0);
      return true;
    }

    function importMarkupFragment(markup, offsetX = 0, offsetY = 0, parentId = "") {
      const parserDoc = new DOMParser().parseFromString(`<svg xmlns="${SVG_NS}">${markup}</svg>`, "image/svg+xml");
      if (parserDoc.querySelector("parsererror")) return "";
      const tempRoot = parserDoc.querySelector("svg");
      const node = tempRoot?.firstElementChild;
      if (!(node instanceof SVGElement)) return "";
      const imported = document.importNode(node, true);
      sanitizeSvgTree(imported);
      imported.removeAttribute("data-id");
      imported.querySelectorAll("[data-id]").forEach((n) => n.removeAttribute("data-id"));
      ensureId(imported);
      ensureTransformState(imported);
      const pasteParent = resolvePasteParent(parentId);
      const delta = toParentLocalDelta(pasteParent, offsetX, offsetY);
      const t = getTranslate(imported);
      setTranslate(imported, t.x + delta.dx, t.y + delta.dy);
      pasteParent.appendChild(imported);
      assignIds(imported);
      return imported.dataset.id || "";
    }

    function pasteInternalClipboard() {
      const items = state.clipboardItems || [];
      if (!items.length) {
        setStatus("Clipboard is empty.");
        return false;
      }
      const inserted = [];
      items.forEach((item, idx) => {
        const id = importMarkupFragment(item.markup, 24 * (idx + 1), 24 * (idx + 1), item.parentId || "");
        if (id) inserted.push(id);
      });
      if (!inserted.length) {
        setStatus("Clipboard paste failed.");
        return false;
      }
      setSelection(inserted);
      pushHistory("paste-internal");
      setStatus(`Pasted ${inserted.length} object(s).`);
      return true;
    }

    function addOrReplaceGroupLabel(groupEl, letter) {
      if (!groupEl || groupEl.tagName !== "g") return;
      const existing = groupEl.querySelector(':scope > [data-fm-group-label="1"]');
      if (existing) existing.remove();
      const b = getGroupContentBBox(groupEl) || safeBBox(groupEl);
      if (!b) return;
      const gt = getTranslate(groupEl);
      const label = document.createElementNS(SVG_NS, "text");
      label.setAttribute("class", "fm-group-label");
      label.setAttribute("data-fm-group-label", "1");
      label.setAttribute("x", String(b.x - gt.x));
      label.setAttribute("y", String(b.y - gt.y - 6));
      label.textContent = letter;
      ensureId(label);
      groupEl.appendChild(label);
      pushHistory(`label-${letter}`);
    }

    function resolveContextGroupTarget() {
      const byContext = getById(state.contextGroupId || "");
      if (byContext && byContext.tagName === "g") return byContext;
      const byTarget = getById(state.contextTargetId || "");
      if (byTarget) {
        if (byTarget.tagName === "g") return byTarget;
        const outer = resolveOuterGroup(byTarget);
        if (outer && outer.tagName === "g") return outer;
      }
      if (state.selectedIds.length === 1) {
        const selected = getById(state.selectedIds[0]);
        if (selected) {
          if (selected.tagName === "g") return selected;
          const outer = resolveOuterGroup(selected);
          if (outer && outer.tagName === "g") return outer;
        }
      }
      return null;
    }

    function promptGroupMark() {
      const group = resolveContextGroupTarget();
      if (!group) {
        setStatus("Mark needs a group target.");
        return;
      }
      const raw = window.prompt("Mark letter (A-Z)", "A");
      if (!raw) return;
      const letter = String(raw).trim().toUpperCase();
      if (!/^[A-Z]$/.test(letter)) {
        setStatus("Mark must be A-Z.");
        return;
      }
      addOrReplaceGroupLabel(group, letter);
      setStatus(`Label ${letter} set.`);
    }

    function clearGroupMark() {
      const group = resolveContextGroupTarget();
      if (!group) {
        setStatus("Clear Mark needs a group target.");
        return;
      }
      const existing = group.querySelector(':scope > [data-fm-group-label="1"]');
      if (!(existing instanceof SVGElement)) {
        setStatus("No mark to clear.");
        return;
      }
      existing.remove();
      pushHistory("label-clear");
      setStatus("Mark cleared.");
    }

    function openContextMenu(clientX, clientY, options = {}) {
      state.contextGroupId = options.groupId || "";
      state.contextTargetId = options.targetId || "";
      const hasSelection = state.selectedIds.length > 0;
      const hasGroupSelection = getTopSelectedElements().some((el) => el && el.tagName === "g");
      const markGroup = resolveContextGroupTarget();
      const canMark = !!markGroup;
      const canMarkClear = !!markGroup?.querySelector(':scope > [data-fm-group-label="1"]');
      const canPaste = Array.isArray(state.clipboardItems) && state.clipboardItems.length > 0;
      ctxMenu.querySelectorAll("button[data-ctx-action]").forEach((btn) => {
        const action = btn.dataset.ctxAction || "";
        let disabled = false;
        if (action === "copy" || action === "cut" || action === "duplicate") disabled = !hasSelection;
        if (action === "paste") disabled = !canPaste;
        if (action === "group") disabled = state.selectedIds.length < 2;
        if (action === "ungroup") disabled = !hasGroupSelection;
        if (action === "mark") disabled = !canMark;
        if (action === "mark-clear") disabled = !canMarkClear;
        btn.disabled = disabled;
        btn.classList.toggle("disabled", disabled);
      });
      ctxMenu.style.left = `${clientX}px`;
      ctxMenu.style.top = `${clientY}px`;
      ctxMenu.style.display = "block";
      const menuRect = ctxMenu.getBoundingClientRect();
      const nextX = Math.max(4, Math.min(clientX, window.innerWidth - menuRect.width - 4));
      const nextY = Math.max(4, Math.min(clientY, window.innerHeight - menuRect.height - 4));
      ctxMenu.style.left = `${nextX}px`;
      ctxMenu.style.top = `${nextY}px`;
    }

    function closeContextMenu() {
      ctxMenu.style.display = "none";
      state.contextGroupId = null;
      state.contextTargetId = null;
    }

    function saveSvg() {
      const markup = getCleanSvgDocument();
      const blob = new Blob([markup], { type: "image/svg+xml;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "figure.svg";
      a.click();
      setTimeout(() => URL.revokeObjectURL(url), 1500);
      setStatus("SVG saved.");
    }

    async function exportPdf() {
      if (state.isExportingPdf) {
        setStatus("PDF export is already running.");
        return;
      }
      state.isExportingPdf = true;
      const exportBtn = document.getElementById("exportPdf");
      if (exportBtn) exportBtn.disabled = true;
      try {
        if (!window.jspdf || !window.jspdf.jsPDF) {
          setStatus("jsPDF unavailable.");
          return;
        }
        const { width: w, height: h } = getCanvasDimensions();
        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({ unit: "pt", format: [w, h], orientation: w >= h ? "landscape" : "portrait" });
        try {
          const cleanSvg = new DOMParser().parseFromString(getCleanSvgDocument(), "image/svg+xml").documentElement;
          await pdf.svg(cleanSvg, { x: 0, y: 0, width: w, height: h });
        } catch (_) {
          if (!window.canvg || !window.canvg.Canvg) throw new Error("svg2pdf failed and canvg unavailable");
          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = Math.max(1, Math.round(w));
          tempCanvas.height = Math.max(1, Math.round(h));
          const ctx = tempCanvas.getContext("2d");
          if (!ctx) throw new Error("Canvas context unavailable");
          const v = await window.canvg.Canvg.fromString(ctx, getCleanSvgDocument());
          await v.render();
          const pngData = tempCanvas.toDataURL("image/png");
          pdf.addImage(pngData, "PNG", 0, 0, w, h);
        }
        pdf.save("figure.pdf");
        setStatus("PDF exported.");
      } catch (err) {
        setStatus(`PDF export failed: ${err.message}`);
      } finally {
        state.isExportingPdf = false;
        if (exportBtn) exportBtn.disabled = false;
      }
    }

    function loadSvgText(text) {
      const doc = new DOMParser().parseFromString(text, "image/svg+xml");
      if (doc.querySelector("parsererror")) {
        setStatus("Invalid SVG file.");
        return;
      }
      const root = doc.querySelector("svg");
      if (!root) {
        setStatus("Invalid SVG file.");
        return;
      }
      sanitizeSvgTree(root);
      applyCanvasMeta({ viewBox: root.getAttribute("viewBox") || DEFAULT_VIEWBOX });
      canvas.innerHTML = root.innerHTML;
      assignIds();
      clearSelection();
      resetHistory("open-svg");
      setStatus("SVG opened.");
    }

    function newCanvas() {
      applyCanvasMeta({ viewBox: DEFAULT_VIEWBOX });
      canvas.innerHTML = "";
      clearSelection();
      resetHistory("new-canvas");
      setStatus("New canvas created.");
    }

    function getAutosaveRecords() {
      try {
        return JSON.parse(localStorage.getItem(AUTOSAVE_KEY) || "[]");
      } catch (err) {
        if (!state.autosaveParseWarned) {
          state.autosaveParseWarned = true;
          setStatus("Autosave data is invalid and was reset.");
          captureError("autosave-parse", err, { userMessage: "Autosave data could not be read." });
        }
        return [];
      }
    }

    function setAutosaveRecords(records) {
      localStorage.setItem(AUTOSAVE_KEY, JSON.stringify(records.slice(-20)));
    }

    function saveAutosave() {
      const records = getAutosaveRecords();
      records.push({
        id: `as-${Date.now()}`,
        at: Date.now(),
        markup: getCleanCanvasMarkup(),
        selectedIds: [...state.selectedIds],
        canvasMeta: getCanvasMeta()
      });
      setAutosaveRecords(records);
      refreshRestoreList();
      setStatus("Autosave snapshot written.");
    }

    function refreshRestoreList() {
      const records = getAutosaveRecords();
      restoreListEl.innerHTML = "";
      records.slice().reverse().forEach((r) => {
        const option = document.createElement("option");
        option.value = r.id;
        option.textContent = new Date(r.at).toLocaleString();
        restoreListEl.appendChild(option);
      });
    }

    function restoreLatest() {
      const records = getAutosaveRecords();
      const r = records[records.length - 1];
      if (!r) {
        setStatus("No autosave records.");
        return;
      }
      applyCanvasMeta(r.canvasMeta);
      canvas.innerHTML = r.markup;
      assignIds();
      setSelection(r.selectedIds || []);
      resetHistory("restore-latest");
      setStatus("Latest autosave restored.");
    }

    function restoreFromList() {
      const records = getAutosaveRecords();
      const id = restoreListEl.value;
      const r = records.find((x) => x.id === id);
      if (!r) {
        setStatus("Selected autosave not found.");
        return;
      }
      applyCanvasMeta(r.canvasMeta);
      canvas.innerHTML = r.markup;
      assignIds();
      setSelection(r.selectedIds || []);
      resetHistory("restore-from-list");
      setStatus("Autosave restored.");
    }

    function updateAutosaveTimer() {
      if (state.autosaveTimer) {
        clearInterval(state.autosaveTimer);
        state.autosaveTimer = null;
      }
      const val = document.getElementById("autosaveSelect").value;
      localStorage.setItem(AUTOSAVE_INTERVAL_KEY, val);
      if (val !== "off") {
        state.autosaveTimer = setInterval(saveAutosave, Number(val) * 60 * 1000);
      }
      setStatus(`Autosave set: ${val}`);
    }

    function insertImageElement(src, width, height, offsetIndex = 0, options = {}) {
      const step = 24;
      const x = 600 - width / 2 + offsetIndex * step;
      const y = 350 - height / 2 + offsetIndex * step;
      const el = document.createElementNS(SVG_NS, "image");
      el.setAttribute("x", String(x));
      el.setAttribute("y", String(y));
      el.setAttribute("width", String(width));
      el.setAttribute("height", String(height));
      el.setAttribute("href", src);
      el.setAttributeNS(XLINK_NS, "href", src);
      ensureId(el);
      setTranslate(el, 0, 0);
      canvas.appendChild(el);
      if (options.select !== false) setSelection([el.dataset.id]);
      return el.dataset.id || "";
    }

    function fileToDataUrl(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(String(reader.result || ""));
        reader.onerror = () => reject(new Error("File read failed"));
        reader.readAsDataURL(file);
      });
    }

    function getImageSize(src) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => resolve({ width: Math.max(1, img.width || 320), height: Math.max(1, img.height || 240) });
        img.onerror = () => resolve({ width: 320, height: 240 });
        img.src = src;
      });
    }

    function pasteRasterImageQuick(source, options = {}) {
      const mime = String(options.mime || "image/unknown");
      const types = Array.isArray(options.types) ? options.types : [];
      const route = String(options.route || "image-raster");
      const historyReason = String(options.historyReason || "paste-image");
      const statusPrefix = String(options.statusPrefix || "Pasted raster image");
      const noteTail = options.noteTail ? ` | ${String(options.noteTail)}` : "";
      const provisionalW = Math.max(64, Number(options.provisionalW || 640));
      const provisionalH = Math.max(64, Number(options.provisionalH || 480));
      const isBlob = typeof Blob !== "undefined" && source instanceof Blob;
      const displaySrc = isBlob ? URL.createObjectURL(source) : String(source || "");
      if (!displaySrc) return "";
      const id = insertImageElement(displaySrc, provisionalW, provisionalH, 0, { select: false });
      if (id) setSelection([id]);
      pushHistory(historyReason);
      setLastPasteReport(route, types, `${mime}:pending${noteTail}`);
      setStatus(`${statusPrefix}. Resolving size...`);

      if (isBlob) {
        fileToDataUrl(source).then((dataUrl) => {
          if (!id || !dataUrl) return;
          const el = getById(id);
          if (el instanceof SVGElement && el.tagName === "image") {
            el.setAttributeNS(XLINK_NS, "href", dataUrl);
            el.setAttribute("href", dataUrl);
          }
          try { URL.revokeObjectURL(displaySrc); } catch (_) {}
        }).catch(() => {});
      }

      getImageSize(displaySrc).then((size) => {
        if (id) {
          const el = getById(id);
          if (el instanceof SVGElement && el.tagName === "image") {
            const x = Number(el.getAttribute("x") || 0);
            const y = Number(el.getAttribute("y") || 0);
            const w = Number(el.getAttribute("width") || provisionalW);
            const h = Number(el.getAttribute("height") || provisionalH);
            const cx = x + w / 2;
            const cy = y + h / 2;
            el.setAttribute("width", String(size.width));
            el.setAttribute("height", String(size.height));
            el.setAttribute("x", String(cx - size.width / 2));
            el.setAttribute("y", String(cy - size.height / 2));
            if (state.selectedIds.includes(id)) requestSelectionVisualRefresh();
          }
        }
        const hint = getPasteQualityHint(size.width, size.height);
        setLastPasteReport(route, types, `${mime}:${size.width}x${size.height}${hint ? ` | ${hint}` : ""}${noteTail}`);
        setStatus(`${statusPrefix} ${size.width}x${size.height}. ${hint || ""}`);
      }).catch(() => {
        setStatus(statusPrefix);
      });
      return id;
    }

    function extractSvgFromHtml(html) {
      if (!html) return [];
      const doc = new DOMParser().parseFromString(html, "text/html");
      return Array.from(doc.querySelectorAll("svg")).slice(0, 20).map((svg) => svg.outerHTML).filter(Boolean);
    }

    function extractSvgSnippet(text) {
      if (!text) return "";
      const m = String(text).match(/<svg[\s\S]*?<\/svg>/i);
      return m ? m[0] : "";
    }

    function extractImageSrcFromHtml(html) {
      if (!html) return [];
      const doc = new DOMParser().parseFromString(html, "text/html");
      return Array.from(doc.querySelectorAll("img[src]")).slice(0, 20).map((img) => img.getAttribute("src")).filter(Boolean);
    }

    function listClipboardTypes(clipboardData) {
      const fromTypes = Array.from(clipboardData?.types || []);
      const fromItems = Array.from(clipboardData?.items || [])
        .filter((it) => !!it)
        .map((it) => String(it.type || ""))
        .filter(Boolean);
      const fromFiles = Array.from(clipboardData?.files || [])
        .map((f) => String(f?.type || ""))
        .filter(Boolean);
      return [...new Set([...fromTypes, ...fromItems, ...fromFiles])];
    }

    function findRasterFileFromClipboard(ev, items) {
      const fileItem = (items || []).find((it) => {
        const t = String(it?.type || "").toLowerCase();
        return t === "image/png" || t === "image/jpeg";
      });
      if (fileItem) {
        const f = fileItem.getAsFile?.();
        if (f) return f;
      }
      const genericFileItem = (items || []).find((it) => String(it?.kind || "").toLowerCase() === "file");
      if (genericFileItem) {
        const f = genericFileItem.getAsFile?.();
        const t = String(f?.type || "").toLowerCase();
        if (f && (t === "image/png" || t === "image/jpeg")) return f;
        if (f && (!t || t === "application/octet-stream")) return f;
      }
      const files = Array.from(ev?.clipboardData?.files || []);
      const direct = files.find((f) => {
        const t = String(f?.type || "").toLowerCase();
        return t === "image/png" || t === "image/jpeg";
      });
      if (direct) return direct;
      const unknown = files.find((f) => !!f);
      if (unknown) return unknown;
      return direct || null;
    }

    function readClipboardItemAsText(item, timeoutMs = 1200) {
      return new Promise((resolve) => {
        let settled = false;
        const done = (v) => {
          if (settled) return;
          settled = true;
          resolve(String(v || ""));
        };
        const timer = setTimeout(() => done(""), Math.max(80, Number(timeoutMs || 1200)));
        try {
          if (item && typeof item.getAsString === "function") {
            item.getAsString((s) => {
              clearTimeout(timer);
              done(s);
            });
            return;
          }
          const file = item?.getAsFile?.();
          if (!file) {
            clearTimeout(timer);
            done("");
            return;
          }
          const reader = new FileReader();
          reader.onload = () => {
            clearTimeout(timer);
            done(reader.result || "");
          };
          reader.onerror = () => {
            clearTimeout(timer);
            done("");
          };
          reader.readAsText(file);
        } catch (_) {
          clearTimeout(timer);
          done("");
        }
      });
    }

    async function pasteImageFromClipboardApi(types = []) {
      const cb = navigator.clipboard;
      if (!cb || typeof cb.read !== "function") return false;
      try {
        const cItems = await cb.read();
        if (!Array.isArray(cItems) || !cItems.length) return false;
        for (const cItem of cItems) {
          const cTypes = Array.from(cItem.types || []);
          const imageType = cTypes.find((t) => /^image\/(png|jpeg)$/i.test(String(t || "")));
          if (!imageType) continue;
          const blob = await cItem.getType(imageType);
          const id = pasteRasterImageQuick(blob, {
            mime: imageType,
            types: [...new Set([...(types || []), ...cTypes])],
            route: "clipboard-api-image-fallback",
            historyReason: "paste-clipboard-api-image-fallback",
            statusPrefix: "Pasted image via clipboard API fallback"
          });
          if (!id) continue;
          return true;
        }
      } catch (_) {
        return false;
      }
      return false;
    }

    function shouldPreferRasterPath(primaryTypes, mergedTypes) {
      const pTypes = (primaryTypes || []).map((t) => String(t || "").toLowerCase());
      const mTypes = (mergedTypes || []).map((t) => String(t || "").toLowerCase());
      const hasRasterType = pTypes.some((t) => t === "files" || t === "image/png" || t === "image/jpeg") ||
        (!pTypes.length && mTypes.some((t) => t === "files" || t === "image/png" || t === "image/jpeg"));
      if (!hasRasterType) return false;
      const hasVectorType = pTypes.some((t) => t === "text/plain" || t === "text/html" || t === "image/svg+xml");
      if (hasVectorType) return false;
      return true;
    }

    function clearPasteLock() {
      state.isPasting = false;
      state.pasteLockAt = 0;
    }

    function tryRecoverPasteLock() {
      if (!state.isPasting) return false;
      const now = Date.now();
      if (!state.pasteLockAt || now - state.pasteLockAt > PASTE_LOCK_TIMEOUT_MS) {
        clearPasteLock();
        setStatus("Recovered from stale paste lock.");
        return true;
      }
      return false;
    }

    async function importSvgFromClipboardStringItems(items, types, options = {}) {
      const stringItems = items.filter((it) => typeof it?.getAsString === "function");
      if (!stringItems.length) return false;
      const timeoutMs = Math.max(100, Number(options.timeoutMs || 320));
      const maxItems = Math.max(1, Number(options.maxItems || 4));
      const priority = (it) => {
        const t = String(it?.type || "").toLowerCase();
        if (t === "image/svg+xml") return 0;
        if (t === "text/plain") return 1;
        if (t === "text/html") return 2;
        return 9;
      };
      const candidates = [...stringItems].sort((a, b) => priority(a) - priority(b)).slice(0, maxItems);
      const reads = await Promise.all(candidates.map(async (item) => ({ item, raw: await readClipboardItemAsText(item, timeoutMs) })));
      for (const { item, raw } of reads) {
        if (!raw) continue;
        if ((item?.type || "") === "text/html") {
          const htmlSvgs = extractSvgFromHtml(raw);
          if (htmlSvgs.length) {
            let count = 0;
            const allIds = [];
            htmlSvgs.forEach((svgText, idx) => {
              const ids = importSvgText(svgText, { push: false, setMessage: false, select: false, offsetX: idx * 24, offsetY: idx * 24 });
              if (ids.length) count += 1;
              allIds.push(...ids);
            });
            if (count > 0) {
              setSelection(allIds);
              pushHistory("paste-item-html-svg");
              setLastPasteReport("item-html-svg", types, `blocks=${count}`);
              setStatus(`Pasted ${count} SVG block(s) from clipboard item.`);
              return true;
            }
          }
        }
        const snippet = raw.trim().startsWith("<svg") ? raw : extractSvgSnippet(raw);
        if (!snippet) continue;
        const ok = importSvgText(snippet).length > 0;
        setLastPasteReport("item-string-svg", types, ok ? `type=${item?.type || "unknown"}` : "item parse failed");
        if (ok) return true;
      }
      return false;
    }

    function setLastPasteReport(route, types, note = "") {
      state.lastPasteReport = {
        at: new Date().toISOString(),
        route,
        types: [...(types || [])],
        note
      };
      try {
        localStorage.setItem(PASTE_REPORT_KEY, JSON.stringify(state.lastPasteReport));
      } catch (_) {}
      state.pasteReportHistory.push(state.lastPasteReport);
      if (state.pasteReportHistory.length > 30) state.pasteReportHistory = state.pasteReportHistory.slice(-30);
      try {
        localStorage.setItem(PASTE_REPORT_HISTORY_KEY, JSON.stringify(state.pasteReportHistory));
      } catch (_) {}
    }

    function getPasteQualityHint(width, height) {
      const w = Number(width || 0);
      const h = Number(height || 0);
      if (w <= 0 || h <= 0) return "";
      if (w < 1000 || h < 700) {
        return "Source image looks low-res. In PowerPoint, try copy as SVG/EMF if available.";
      }
      return "Source image size looks high enough.";
    }

    function showPasteReport() {
      const r = state.lastPasteReport;
      if (!r) {
        setStatus("No paste report yet. Paste once, then open report.");
        return;
      }
      const lines = [
        `Time: ${r.at}`,
        `Route: ${r.route}`,
        `Types: ${(r.types || []).join(", ") || "(none)"}`,
        `Note: ${r.note || "-"}`,
        `Meaning: ${routeToPasteMeaning(r.route)}`,
      ];
      const text = lines.join("\n");
      setStatus(`Paste report shown: ${r.route}`);
      window.prompt("Paste diagnostics (copy if needed)", text);
    }

    function formatPasteReportText() {
      const r = state.lastPasteReport;
      if (!r) return "";
      return [
        `Time: ${r.at}`,
        `Route: ${r.route}`,
        `Types: ${(r.types || []).join(", ") || "(none)"}`,
        `Note: ${r.note || "-"}`,
        `Meaning: ${routeToPasteMeaning(r.route)}`,
        `UserAgent: ${navigator.userAgent}`
      ].join("\n");
    }

    function routeToPasteMeaning(route) {
      if (route === "html-svg" || route === "image-svg+xml" || route === "item-image-svg+xml" || route === "plain-svg" || route === "item-string-svg" || route === "item-html-svg") {
        return "Vector pasted (editable SVG elements).";
      }
      if (route === "image-raster" || route === "html-image") {
        return "Raster image pasted (not vector-editable).";
      }
      if (route === "unsupported") return "Clipboard did not include supported SVG/PNG/JPEG payload.";
      if (route === "error") return "Paste processing failed.";
      return "Paste route recorded.";
    }

    function formatPasteReportHistoryText(limit = 10) {
      const history = (state.pasteReportHistory || []).slice(-Math.max(1, limit));
      if (!history.length) return "";
      const blocks = history.map((r, idx) => [
        `#${idx + 1}`,
        `Time: ${r.at}`,
        `Route: ${r.route}`,
        `Types: ${(r.types || []).join(", ") || "(none)"}`,
        `Note: ${r.note || "-"}`
      ].join("\n"));
      return [
        `Entries: ${history.length}`,
        `UserAgent: ${navigator.userAgent}`,
        "",
        blocks.join("\n\n")
      ].join("\n");
    }

    async function copyPasteReport() {
      const text = formatPasteReportText();
      if (!text) {
        setStatus("No paste report yet. Paste once, then copy report.");
        return;
      }
      try {
        if (navigator.clipboard?.writeText) {
          await navigator.clipboard.writeText(text);
          setStatus("Paste report copied.");
          return;
        }
      } catch (_) {}
      window.prompt("Clipboard unavailable. Copy manually:", text);
      setStatus("Paste report shown for manual copy.");
    }

    function downloadPasteReport() {
      const latest = formatPasteReportText();
      const history = formatPasteReportHistoryText(20);
      const text = [latest, "", "----", "", history].filter(Boolean).join("\n");
      if (!text) {
        setStatus("No paste report yet. Paste once, then save report.");
        return;
      }
      const safeAt = (state.lastPasteReport?.at || new Date().toISOString()).replace(/[:.]/g, "-");
      const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `paste-report-${safeAt}.txt`;
      a.click();
      setTimeout(() => URL.revokeObjectURL(url), 1500);
      setStatus("Paste report file saved.");
    }

    function showPasteReportHistory() {
      const text = formatPasteReportHistoryText(10);
      if (!text) {
        setStatus("No paste report history yet.");
        return;
      }
      setStatus("Paste report history shown.");
      window.prompt("Paste report history", text);
    }

    async function copyPasteReportHistory() {
      const text = formatPasteReportHistoryText(20);
      if (!text) {
        setStatus("No paste report history yet.");
        return;
      }
      try {
        if (navigator.clipboard?.writeText) {
          await navigator.clipboard.writeText(text);
          setStatus("Paste report history copied.");
          return;
        }
      } catch (_) {}
      window.prompt("Clipboard unavailable. Copy history manually:", text);
      setStatus("Paste report history shown for manual copy.");
    }

    function clearPasteReportHistory() {
      if (!state.pasteReportHistory.length && !state.lastPasteReport) {
        setStatus("No paste report history to clear.");
        return;
      }
      if (!window.confirm("Clear paste report history?")) return;
      state.pasteReportHistory = [];
      state.lastPasteReport = null;
      try {
        localStorage.removeItem(PASTE_REPORT_KEY);
        localStorage.removeItem(PASTE_REPORT_HISTORY_KEY);
      } catch (_) {}
      setStatus("Paste report history cleared.");
    }

    function showShortcutHelp() {
      const lines = [
        "Figure Maker Shortcuts",
        "",
        "V : Black Arrow tool",
        "A : White Arrow tool",
        "R : Add Rect",
        "L : Add Line",
        "Q : Add Arrow",
        "E : Add Ellipse",
        "T : Add Text",
        "Ctrl/Cmd+Z : Undo",
        "Ctrl/Cmd+Shift+Z : Redo",
        "Ctrl/Cmd+Y : Redo",
        "Delete/Backspace : Delete selection",
        "Arrow keys : Nudge (Shift=10px)",
        "Ctrl/Cmd+D : Duplicate",
        "Ctrl/Cmd+C/X : Copy/Cut",
        "Ctrl/Cmd+V : Paste from OS clipboard (or internal fallback if OS paste not delivered)",
        "Ctrl/Cmd+Shift+V : Paste internal clipboard (force)",
        "Ctrl/Cmd+Shift+R : Restore latest autosave",
        "Ctrl/Cmd+Shift+I : Show paste report",
        "Ctrl/Cmd+Shift+J : Copy paste report",
        "Ctrl/Cmd+Shift+K : Save paste report file",
        "Ctrl/Cmd+Shift+H : Show paste report history",
        "Ctrl/Cmd+Shift+U : Copy paste report history",
        "Ctrl/Cmd+Shift+L : Clear paste report history",
        "Ctrl/Cmd+/ : Show this shortcuts help",
        "",
        "Text: Double click or Enter/F2 on selected text to edit inline."
      ];
      const text = lines.join("\n");
      if (shortcutHelpTextEl) shortcutHelpTextEl.textContent = text;
      if (shortcutModalEl) shortcutModalEl.classList.add("show");
      setStatus("Shortcut help shown.");
    }

    function closeShortcutHelp() {
      if (!shortcutModalEl || !shortcutModalEl.classList.contains("show")) return false;
      shortcutModalEl.classList.remove("show");
      return true;
    }

    function closeInlineTextEditor(commit) {
      if (!state.textEdit) return;
      const target = getById(state.textEdit.targetId);
      if (commit && target && target.tagName === "text") {
        target.textContent = textEditorInput.value;
        setSelection([target.dataset.id]);
        pushHistory("edit-text");
        setStatus("Text updated.");
      }
      textEditorInput.style.display = "none";
      state.textEdit = null;
    }

    function openInlineTextEditor(textEl) {
      if (!(textEl instanceof SVGElement) || textEl.tagName !== "text" || !textEl.dataset.id) return;
      const box = textEl.getBoundingClientRect();
      const wrap = canvasWrapEl.getBoundingClientRect();
      state.textEdit = { targetId: textEl.dataset.id };
      textEditorInput.value = textEl.textContent || "";
      textEditorInput.style.left = `${Math.max(0, box.left - wrap.left + canvasWrapEl.scrollLeft - 4)}px`;
      textEditorInput.style.top = `${Math.max(0, box.top - wrap.top + canvasWrapEl.scrollTop - 4)}px`;
      textEditorInput.style.width = `${Math.max(120, box.width + 24)}px`;
      textEditorInput.style.fontSize = textEl.getAttribute("font-size") ? `${Number(textEl.getAttribute("font-size"))}px` : "16px";
      textEditorInput.style.display = "block";
      textEditorInput.focus();
      textEditorInput.select();
      setStatus("Editing text...");
    }

    function importSvgText(svgText, options = {}) {
      const push = options.push !== false;
      const setMessage = options.setMessage !== false;
      const select = options.select !== false;
      const offsetX = Number(options.offsetX || 0);
      const offsetY = Number(options.offsetY || 0);
      const wrap = options.wrap !== false;
      const doc = new DOMParser().parseFromString(svgText, "image/svg+xml");
      if (doc.querySelector("parsererror")) return [];
      const root = doc.querySelector("svg");
      if (!root) return [];
      sanitizeSvgTree(root);
      const importedIds = [];
      let wrapper = null;
      if (wrap) {
        wrapper = document.createElementNS(SVG_NS, "g");
        ensureId(wrapper);
        applyPointerEventPolicy(wrapper);
        setTranslate(wrapper, 0, 0);
        canvas.appendChild(wrapper);
      }
      Array.from(root.children).forEach((child) => {
        const imported = document.importNode(child, true);
        if (!(imported instanceof SVGElement)) return;
        sanitizeSvgTree(imported);
        ensureId(imported);
        ensureTransformState(imported);
        if (!wrap && (offsetX || offsetY)) {
          const t = getTranslate(imported);
          setTranslate(imported, t.x + offsetX, t.y + offsetY);
        }
        if (wrapper) wrapper.appendChild(imported);
        else canvas.appendChild(imported);
        if (!wrap && imported.dataset.id) importedIds.push(imported.dataset.id);
      });
      if (wrapper) {
        if (offsetX || offsetY) {
          const t = getTranslate(wrapper);
          setTranslate(wrapper, t.x + offsetX, t.y + offsetY);
        }
        if (wrapper.dataset.id) importedIds.push(wrapper.dataset.id);
      }
      assignIds();
      if (select) setSelection(importedIds);
      if (push) pushHistory("paste-svg");
      if (setMessage) setStatus("Pasted SVG content.");
      return importedIds;
    }

    async function handlePaste(ev) {
      if (ev && typeof ev === "object") {
        if (processedPasteEvents.has(ev)) return;
        processedPasteEvents.add(ev);
      }
      if (state.isPasting && !tryRecoverPasteLock()) {
        setStatus("Paste is already running.");
        return;
      }
      const rawTypes = Array.from(ev.clipboardData?.types || []);
      const items = Array.from(ev.clipboardData?.items || []).filter((it) => !!it);
      const types = listClipboardTypes(ev.clipboardData);
      const hasPayload = items.length > 0 ||
        Array.from(ev.clipboardData?.files || []).length > 0 ||
        types.some((t) => /^(files|image\/png|image\/jpeg|image\/svg\+xml|text\/html|text\/plain)$/i.test(String(t || "")));
      if (!hasPayload) return;
      state.lastExternalPasteAt = Date.now();
      state.isPasting = true;
      state.pasteLockAt = Date.now();
      try {
        const getDataSafe = (kind) => {
          try {
            return ev.clipboardData?.getData(kind) || "";
          } catch (_) {
            return "";
          }
        };
        if (shouldPreferRasterPath(rawTypes, types)) {
          const rasterFileFirst = findRasterFileFromClipboard(ev, items);
          if (rasterFileFirst) {
            ev.preventDefault();
            const mime = String(rasterFileFirst.type || "image/unknown");
            pasteRasterImageQuick(rasterFileFirst, { mime, types, route: "image-raster", historyReason: "paste-image", statusPrefix: "Pasted raster image", noteTail: "fastpath" });
            return;
          }
          const apiFast = await pasteImageFromClipboardApi(types);
          if (apiFast) {
            ev.preventDefault();
            return;
          }
        }
        const svgXmlText = getDataSafe("image/svg+xml");
        const plain = getDataSafe("text/plain");
        if (svgXmlText.trim().startsWith("<svg")) {
          ev.preventDefault();
          const ok = importSvgText(svgXmlText).length > 0;
          setLastPasteReport("image-svg+xml", types, ok ? "vector imported" : "parse failed");
          if (!ok) setStatus("Paste SVG(XML) parse failed.");
          return;
        }

        const svgItem = items.find((it) => it.type === "image/svg+xml");
        if (svgItem) {
          ev.preventDefault();
          const raw = await readClipboardItemAsText(svgItem);
          const snippet = extractSvgSnippet(raw);
          const ok = snippet ? importSvgText(snippet).length > 0 : false;
          setLastPasteReport("item-image-svg+xml", types, ok ? "vector imported" : "item parse failed");
          if (ok) return;
        }

        const plainSvg = plain.trim().startsWith("<svg") ? plain : extractSvgSnippet(plain);
        if (plainSvg) {
          ev.preventDefault();
          const ok = importSvgText(plainSvg).length > 0;
          setLastPasteReport("plain-svg", types, ok ? "vector imported" : "parse failed");
          if (!ok) setStatus("Paste SVG parse failed.");
          return;
        }

        const itemStringImported = await importSvgFromClipboardStringItems(items, types, { timeoutMs: 260, maxItems: 3 });
        if (itemStringImported) {
          ev.preventDefault();
          return;
        }

        const htmlText = getDataSafe("text/html");
        const htmlSvgs = extractSvgFromHtml(htmlText);
        if (htmlSvgs.length) {
          ev.preventDefault();
          let count = 0;
          const allIds = [];
          htmlSvgs.forEach((svgText, idx) => {
            const ids = importSvgText(svgText, { push: false, setMessage: false, select: false, offsetX: idx * 24, offsetY: idx * 24 });
            if (ids.length > 0) count += 1;
            allIds.push(...ids);
          });
          if (count > 0) {
            setSelection(allIds);
            pushHistory("paste-html-svg");
            setLastPasteReport("html-svg", types, `blocks=${count}`);
            setStatus(`Pasted ${count} SVG block(s) from HTML.`);
            return;
          }
        }

        const rasterFile = findRasterFileFromClipboard(ev, items);
        if (rasterFile) {
          ev.preventDefault();
          const mime = String(rasterFile.type || "image/unknown");
          pasteRasterImageQuick(rasterFile, { mime, types, route: "image-raster", historyReason: "paste-image", statusPrefix: "Pasted raster image" });
          return;
        }

        if (types.some((t) => /^(files|image\/png|image\/jpeg)$/i.test(String(t || "")))) {
          const apiOk = await pasteImageFromClipboardApi(types);
          if (apiOk) {
            ev.preventDefault();
            return;
          }
        }

        const htmlImgSrcs = extractImageSrcFromHtml(htmlText);
        if (htmlImgSrcs.length) {
          ev.preventDefault();
          let inserted = 0;
          const allIds = [];
          for (const [idx, src] of htmlImgSrcs.slice(0, 20).entries()) {
            const size = await getImageSize(src);
            const id = insertImageElement(src, size.width, size.height, idx, { select: false });
            if (id) allIds.push(id);
            inserted += 1;
          }
          if (allIds.length) setSelection(allIds);
          pushHistory("paste-html-image");
          setLastPasteReport("html-image", types, `images=${inserted}`);
          setStatus(`Pasted ${inserted} HTML image(s).`);
          return;
        }

        setLastPasteReport("unsupported", types, "no supported payload found");
        const suffix = types.length ? ` Types: ${types.join(", ")}` : "";
        setStatus(`Paste unsupported: use SVG/HTML or PNG/JPEG.${suffix}`);
      } catch (err) {
        setLastPasteReport("error", types, String(err.message || err));
        setStatus("Paste failed. Please try another source format.");
        captureError("paste-failed", err, { userMessage: "Paste processing failed." });
      } finally {
        clearPasteLock();
      }
    }

    async function pasteFromClipboardApiFallback() {
      if (state.isPasting && !tryRecoverPasteLock()) return false;
      const cb = navigator.clipboard;
      if (!cb) return false;
      state.isPasting = true;
      state.pasteLockAt = Date.now();
      try {
        try {
          if (typeof cb.read === "function") {
            const cItems = await cb.read();
            if (Array.isArray(cItems) && cItems.length) {
              for (const cItem of cItems) {
                const cTypes = Array.from(cItem.types || []);
                if (cTypes.includes("image/svg+xml")) {
                  const blob = await cItem.getType("image/svg+xml");
                  const raw = await blob.text();
                  const snippet = extractSvgSnippet(raw);
                  if (snippet && importSvgText(snippet).length > 0) {
                    setLastPasteReport("clipboard-api-svg", cTypes, "vector imported via clipboard.read");
                    return true;
                  }
                }
                if (cTypes.includes("text/html")) {
                  const blob = await cItem.getType("text/html");
                  const html = await blob.text();
                  const htmlSvgs = extractSvgFromHtml(html);
                  if (htmlSvgs.length) {
                    let count = 0;
                    const allIds = [];
                    htmlSvgs.forEach((svgText, idx) => {
                      const ids = importSvgText(svgText, { push: false, setMessage: false, select: false, offsetX: idx * 24, offsetY: idx * 24 });
                      if (ids.length) count += 1;
                      allIds.push(...ids);
                    });
                    if (count > 0) {
                      setSelection(allIds);
                      pushHistory("paste-clipboard-api-html-svg");
                      setLastPasteReport("clipboard-api-html-svg", cTypes, `blocks=${count}`);
                      setStatus(`Pasted ${count} SVG block(s) via clipboard API.`);
                      return true;
                    }
                  }
                }
                if (cTypes.includes("text/plain")) {
                  const blob = await cItem.getType("text/plain");
                  const plain = await blob.text();
                  const snippet = plain.trim().startsWith("<svg") ? plain : extractSvgSnippet(plain);
                  if (snippet && importSvgText(snippet).length > 0) {
                    setLastPasteReport("clipboard-api-plain-svg", cTypes, "vector imported via clipboard.read");
                    return true;
                  }
                }
                const imageType = cTypes.find((t) => t === "image/png" || t === "image/jpeg");
                if (imageType) {
                  const blob = await cItem.getType(imageType);
                  const dataUrl = await fileToDataUrl(blob);
                  const size = await getImageSize(dataUrl);
                  const id = insertImageElement(dataUrl, size.width, size.height, 0, { select: false });
                  if (id) {
                    setSelection([id]);
                    pushHistory("paste-clipboard-api-image");
                    const hint = getPasteQualityHint(size.width, size.height);
                    setLastPasteReport("clipboard-api-image", cTypes, `${imageType}:${size.width}x${size.height}${hint ? ` | ${hint}` : ""}`);
                    setStatus(`Pasted image via clipboard API ${size.width}x${size.height}. ${hint || ""}`);
                    return true;
                  }
                }
              }
            }
          }
        } catch (_) {}

        try {
          if (typeof cb.readText === "function") {
            const t = await cb.readText();
            const snippet = t && (t.trim().startsWith("<svg") ? t : extractSvgSnippet(t));
            if (snippet && importSvgText(snippet).length > 0) {
              setLastPasteReport("clipboard-api-readText-svg", ["text/plain"], "vector imported via readText");
              return true;
            }
          }
        } catch (_) {}
        return false;
      } finally {
        clearPasteLock();
      }
    }

    async function pasteBestEffort() {
      const fromSystem = await pasteFromClipboardApiFallback();
      if (fromSystem) return true;
      return pasteInternalClipboard();
    }

    function beginMarquee(start, keepCurrent) {
      const rect = document.createElementNS(SVG_NS, "rect");
      rect.setAttribute("class", "marquee");
      rect.setAttribute("x", String(start.x));
      rect.setAttribute("y", String(start.y));
      rect.setAttribute("width", "0");
      rect.setAttribute("height", "0");
      canvas.appendChild(rect);
      state.interaction = { type: "marquee", start, rect, keepCurrent, pointerId: null };
    }

    function updateMarquee(pt) {
      const it = state.interaction;
      if (!it || it.type !== "marquee") return;
      const x = Math.min(it.start.x, pt.x);
      const y = Math.min(it.start.y, pt.y);
      const w = Math.abs(it.start.x - pt.x);
      const h = Math.abs(it.start.y - pt.y);
      it.rect.setAttribute("x", String(x));
      it.rect.setAttribute("y", String(y));
      it.rect.setAttribute("width", String(w));
      it.rect.setAttribute("height", String(h));
    }

    function finishMarquee() {
      const it = state.interaction;
      if (!it || it.type !== "marquee") return;
      const x = Number(it.rect.getAttribute("x"));
      const y = Number(it.rect.getAttribute("y"));
      const width = Number(it.rect.getAttribute("width"));
      const height = Number(it.rect.getAttribute("height"));
      it.rect.remove();
      const hit = [];
      if (width > 2 && height > 2) {
        const area = { x, y, width, height };
        canvas.querySelectorAll("[data-id]").forEach((el) => {
          if (!(el instanceof SVGElement) || !isEditableElement(el)) return;
          if (isGroupLabel(el)) return;
          const b = safeBBox(el);
          if (b && intersects(area, b)) hit.push(el.dataset.id);
        });
      }
      if (it.keepCurrent) {
        setSelection([...state.selectedIds, ...hit]);
      } else {
        setSelection(hit);
      }
      state.interaction = null;
    }

    function beginDrag(start) {
      const elements = getTopSelectedElements();
      if (!elements.length) return;
      const original = new Map();
      elements.forEach((el) => original.set(el.dataset.id, getTranslate(el)));
      state.interaction = { type: "drag", start, original, moved: false, pointerId: null };
    }

    function beginResize(start, targetEl, handle) {
      if (!targetEl || !isResizableElement(targetEl)) return;
      const b = safeBBox(targetEl);
      if (!b) return;
      const aspect = b.height > 0 ? b.width / b.height : 1;
      // Regression note: pasted SVG often carries parent/child transforms.
      // Resizing by editing geometry attrs caused position drift, so resize stays transform-based.
      state.interaction = {
        type: "resize",
        start,
        targetId: targetEl.dataset.id,
        handle,
        originalBox: b,
        baseBox: b,
        baseTransformRaw: String(targetEl.getAttribute("transform") || "").trim(),
        transformResize: true,
        liveBox: b,
        aspect,
        moved: false,
        pointerId: null
      };
    }

    function mapX(x, oldBox, newBox) {
      const denom = Math.max(oldBox.width, 1e-6);
      return newBox.x + ((x - oldBox.x) / denom) * newBox.width;
    }

    function mapY(y, oldBox, newBox) {
      const denom = Math.max(oldBox.height, 1e-6);
      return newBox.y + ((y - oldBox.y) / denom) * newBox.height;
    }

    function scalePathD(d, oldBox, newBox, offset) {
      const tokens = [];
      const re = /([a-zA-Z])|([-+]?\d*\.?\d+(?:e[-+]?\d+)?)/g;
      let m;
      while ((m = re.exec(d)) !== null) {
        if (m[1]) tokens.push({ type: "cmd", value: m[1] });
        else tokens.push({ type: "num", value: Number(m[2]) });
      }
      const out = [];
      let i = 0;
      let cmd = "";
      const sx = newBox.width / Math.max(oldBox.width, 1e-6);
      const sy = newBox.height / Math.max(oldBox.height, 1e-6);
      const mapAbsX = (x) => mapX(x + offset.x, oldBox, newBox) - offset.x;
      const mapAbsY = (y) => mapY(y + offset.y, oldBox, newBox) - offset.y;
      const mapRelX = (x) => x * sx;
      const mapRelY = (y) => y * sy;
      const readNum = () => {
        if (i >= tokens.length || tokens[i].type !== "num") return null;
        return tokens[i++].value;
      };
      const emit = (vals) => vals.forEach((v) => out.push(Number.isInteger(v) ? String(v) : String(Number(v.toFixed(4)))));
      while (i < tokens.length) {
        if (tokens[i].type === "cmd") {
          cmd = tokens[i].value;
          out.push(cmd);
          i += 1;
        }
        if (!cmd) break;
        const c = cmd.toLowerCase();
        const rel = cmd === c;
        const need = c === "m" || c === "l" || c === "t" ? 2
          : c === "h" || c === "v" ? 1
          : c === "c" ? 6
          : c === "s" || c === "q" ? 4
          : c === "a" ? 7
          : c === "z" ? 0 : -1;
        if (need === 0) {
          while (i < tokens.length && tokens[i].type !== "cmd") i += 1;
          continue;
        }
        if (need < 0) break;
        if (i < tokens.length && tokens[i].type === "cmd") continue;
        const vals = [];
        for (let k = 0; k < need; k += 1) {
          const v = readNum();
          if (v === null) break;
          vals.push(v);
        }
        if (vals.length < need) break;

        if (c === "h") emit([rel ? mapRelX(vals[0]) : mapAbsX(vals[0])]);
        else if (c === "v") emit([rel ? mapRelY(vals[0]) : mapAbsY(vals[0])]);
        else if (c === "m" || c === "l" || c === "t") {
          emit([rel ? mapRelX(vals[0]) : mapAbsX(vals[0]), rel ? mapRelY(vals[1]) : mapAbsY(vals[1])]);
        } else if (c === "s" || c === "q") {
          emit([
            rel ? mapRelX(vals[0]) : mapAbsX(vals[0]),
            rel ? mapRelY(vals[1]) : mapAbsY(vals[1]),
            rel ? mapRelX(vals[2]) : mapAbsX(vals[2]),
            rel ? mapRelY(vals[3]) : mapAbsY(vals[3])
          ]);
        } else if (c === "c") {
          emit([
            rel ? mapRelX(vals[0]) : mapAbsX(vals[0]),
            rel ? mapRelY(vals[1]) : mapAbsY(vals[1]),
            rel ? mapRelX(vals[2]) : mapAbsX(vals[2]),
            rel ? mapRelY(vals[3]) : mapAbsY(vals[3]),
            rel ? mapRelX(vals[4]) : mapAbsX(vals[4]),
            rel ? mapRelY(vals[5]) : mapAbsY(vals[5])
          ]);
        } else if (c === "a") {
          const rx = Math.max(0.5, Math.abs(vals[0] * sx));
          const ry = Math.max(0.5, Math.abs(vals[1] * sy));
          emit([
            rx,
            ry,
            vals[2],
            vals[3],
            vals[4],
            rel ? mapRelX(vals[5]) : mapAbsX(vals[5]),
            rel ? mapRelY(vals[6]) : mapAbsY(vals[6])
          ]);
        }
      }
      return out.join(" ");
    }

    function scaleSingleElement(el, oldBox, newBox, parentOffset = { x: 0, y: 0 }) {
      if (shouldUseTransformResize(el)) {
        if (applyResizeByTransform(el, oldBox, newBox)) return;
      }
      const t = getTranslate(el);
      if (el.tagName === "rect" || el.tagName === "image") {
        const x = Number(el.getAttribute("x") || 0) + t.x + parentOffset.x;
        const y = Number(el.getAttribute("y") || 0) + t.y + parentOffset.y;
        const x2 = x + Number(el.getAttribute("width") || 0);
        const y2 = y + Number(el.getAttribute("height") || 0);
        const nx = mapX(x, oldBox, newBox);
        const ny = mapY(y, oldBox, newBox);
        const nx2 = mapX(x2, oldBox, newBox);
        const ny2 = mapY(y2, oldBox, newBox);
        el.setAttribute("x", String(nx - t.x - parentOffset.x));
        el.setAttribute("y", String(ny - t.y - parentOffset.y));
        el.setAttribute("width", String(Math.max(1, nx2 - nx)));
        el.setAttribute("height", String(Math.max(1, ny2 - ny)));
        return;
      }
      if (el.tagName === "ellipse") {
        const cx = Number(el.getAttribute("cx") || 0) + t.x + parentOffset.x;
        const cy = Number(el.getAttribute("cy") || 0) + t.y + parentOffset.y;
        const rx = Number(el.getAttribute("rx") || 0);
        const ry = Number(el.getAttribute("ry") || 0);
        const x1 = cx - rx;
        const x2 = cx + rx;
        const y1 = cy - ry;
        const y2 = cy + ry;
        const nx1 = mapX(x1, oldBox, newBox);
        const nx2 = mapX(x2, oldBox, newBox);
        const ny1 = mapY(y1, oldBox, newBox);
        const ny2 = mapY(y2, oldBox, newBox);
        const ncx = (nx1 + nx2) / 2;
        const ncy = (ny1 + ny2) / 2;
        el.setAttribute("cx", String(ncx - t.x - parentOffset.x));
        el.setAttribute("cy", String(ncy - t.y - parentOffset.y));
        el.setAttribute("rx", String(Math.max(0.5, (nx2 - nx1) / 2)));
        el.setAttribute("ry", String(Math.max(0.5, (ny2 - ny1) / 2)));
        return;
      }
      if (el.tagName === "circle") {
        const cx = Number(el.getAttribute("cx") || 0) + t.x + parentOffset.x;
        const cy = Number(el.getAttribute("cy") || 0) + t.y + parentOffset.y;
        const r = Number(el.getAttribute("r") || 0);
        const x1 = cx - r;
        const x2 = cx + r;
        const y1 = cy - r;
        const y2 = cy + r;
        const nx1 = mapX(x1, oldBox, newBox);
        const nx2 = mapX(x2, oldBox, newBox);
        const ny1 = mapY(y1, oldBox, newBox);
        const ny2 = mapY(y2, oldBox, newBox);
        const ncx = (nx1 + nx2) / 2;
        const ncy = (ny1 + ny2) / 2;
        const nr = Math.max(0.5, ((nx2 - nx1) + (ny2 - ny1)) / 4);
        el.setAttribute("cx", String(ncx - t.x - parentOffset.x));
        el.setAttribute("cy", String(ncy - t.y - parentOffset.y));
        el.setAttribute("r", String(nr));
        return;
      }
      if (el.tagName === "line") {
        const x1 = Number(el.getAttribute("x1") || 0) + t.x + parentOffset.x;
        const y1 = Number(el.getAttribute("y1") || 0) + t.y + parentOffset.y;
        const x2 = Number(el.getAttribute("x2") || 0) + t.x + parentOffset.x;
        const y2 = Number(el.getAttribute("y2") || 0) + t.y + parentOffset.y;
        el.setAttribute("x1", String(mapX(x1, oldBox, newBox) - t.x - parentOffset.x));
        el.setAttribute("y1", String(mapY(y1, oldBox, newBox) - t.y - parentOffset.y));
        el.setAttribute("x2", String(mapX(x2, oldBox, newBox) - t.x - parentOffset.x));
        el.setAttribute("y2", String(mapY(y2, oldBox, newBox) - t.y - parentOffset.y));
        return;
      }
      if (el.tagName === "polygon" || el.tagName === "polyline") {
        const pts = String(el.getAttribute("points") || "").trim();
        if (!pts) return;
        const mapped = pts.split(/\s+/).map((pair) => {
          const [pxRaw, pyRaw] = pair.split(",");
          const px = Number(pxRaw);
          const py = Number(pyRaw);
          if (Number.isNaN(px) || Number.isNaN(py)) return pair;
          const wx = px + t.x + parentOffset.x;
          const wy = py + t.y + parentOffset.y;
          const nx = mapX(wx, oldBox, newBox) - t.x - parentOffset.x;
          const ny = mapY(wy, oldBox, newBox) - t.y - parentOffset.y;
          return `${nx},${ny}`;
        });
        el.setAttribute("points", mapped.join(" "));
        return;
      }
      if (el.tagName === "path") {
        const d = String(el.getAttribute("d") || "");
        if (!d) return;
        const mappedD = scalePathD(d, oldBox, newBox, { x: t.x + parentOffset.x, y: t.y + parentOffset.y });
        if (mappedD) el.setAttribute("d", mappedD);
        return;
      }
      if (el.tagName === "text") {
        const x = Number(el.getAttribute("x") || 0) + t.x + parentOffset.x;
        const y = Number(el.getAttribute("y") || 0) + t.y + parentOffset.y;
        const sx = Math.max(newBox.width / Math.max(oldBox.width, 1e-6), 0.05);
        const sy = Math.max(newBox.height / Math.max(oldBox.height, 1e-6), 0.05);
        const fs = Number(el.getAttribute("font-size") || 16);
        const scale = (sx + sy) / 2;
        el.setAttribute("x", String(mapX(x, oldBox, newBox) - t.x - parentOffset.x));
        el.setAttribute("y", String(mapY(y, oldBox, newBox) - t.y - parentOffset.y));
        el.setAttribute("font-size", String(Math.max(6, fs * scale)));
        return;
      }
      if (el.tagName === "g") {
        const nextOffset = { x: parentOffset.x + t.x, y: parentOffset.y + t.y };
        Array.from(el.children).forEach((child) => {
          if (!(child instanceof SVGElement)) return;
          scaleSingleElement(child, oldBox, newBox, nextOffset);
        });
      }
    }

    function updateResize(pt, keepAspect = false) {
      const it = state.interaction;
      if (!it || it.type !== "resize") return;
      const el = getById(it.targetId);
      if (!el) return;
      const ob = it.baseBox;
      let left = ob.x;
      let right = ob.x + ob.width;
      let top = ob.y;
      let bottom = ob.y + ob.height;
      if (it.handle.includes("w")) left = Math.min(pt.x, right - MIN_RESIZE_SIZE);
      if (it.handle.includes("e")) right = Math.max(pt.x, left + MIN_RESIZE_SIZE);
      if (it.handle.includes("n")) top = Math.min(pt.y, bottom - MIN_RESIZE_SIZE);
      if (it.handle.includes("s")) bottom = Math.max(pt.y, top + MIN_RESIZE_SIZE);
      let width = Math.max(MIN_RESIZE_SIZE, right - left);
      let height = Math.max(MIN_RESIZE_SIZE, bottom - top);
      if (keepAspect) {
        const aspect = Math.max(0.01, Number(it.aspect || 1));
        if (width / Math.max(height, 1e-6) > aspect) {
          width = height * aspect;
        } else {
          height = width / aspect;
        }
        if (it.handle.includes("w")) left = right - width;
        else right = left + width;
        if (it.handle.includes("n")) top = bottom - height;
        else bottom = top + height;
      }
      it.liveBox = { x: left, y: top, width, height };
      applyResizeByTransform(el, ob, it.liveBox, it.baseTransformRaw || "");
      it.moved = true;
      requestSelectionVisualRefresh();
    }

    function finishResize() {
      const it = state.interaction;
      if (!it || it.type !== "resize") return;
      if (it.moved) pushHistory("resize");
      state.interaction = null;
    }

    function updateDrag(pt) {
      const it = state.interaction;
      if (!it || it.type !== "drag") return;
      const dx = pt.x - it.start.x;
      const dy = pt.y - it.start.y;
      if (Math.abs(dx) > 0.3 || Math.abs(dy) > 0.3) it.moved = true;
      getTopSelectedElements().forEach((el) => {
        const o = it.original.get(el.dataset.id);
        if (!o) return;
        setTranslate(el, o.x + dx, o.y + dy);
      });
      requestSelectionVisualRefresh();
    }

    function finishDrag() {
      const it = state.interaction;
      if (!it || it.type !== "drag") return;
      if (it.moved) pushHistory("drag-move", { coalesce: true, withinMs: 400 });
      state.interaction = null;
    }

    function setupEvents() {
      const menuBar = document.getElementById("menuBar");
      if (menuBar) {
        menuBar.addEventListener("click", (e) => {
          const trigger = e.target.closest("[data-menu-trigger]");
          if (trigger) {
            e.preventDefault();
            toggleAppMenu(trigger.dataset.menuTrigger || "");
            return;
          }
          const actionBtn = e.target.closest("[data-menu-action]");
          if (actionBtn) {
            e.preventDefault();
            runMenuAction(actionBtn.dataset.menuAction || "");
            closeAppMenus();
          }
        });
      }
      window.addEventListener("pointerdown", (e) => {
        if (!menuBar) return;
        if (!menuBar.contains(e.target)) closeAppMenus();
      });
      const bindClick = (id, handler) => {
        const el = document.getElementById(id);
        if (el) el.addEventListener("click", handler);
      };

      document.getElementById("toolSelect").addEventListener("click", () => {
        state.tool = "select";
        document.getElementById("toolSelect").classList.add("active");
        document.getElementById("toolDirect").classList.remove("active");
        updateToolCursor();
      });
      document.getElementById("toolDirect").addEventListener("click", () => {
        state.tool = "direct";
        document.getElementById("toolDirect").classList.add("active");
        document.getElementById("toolSelect").classList.remove("active");
        updateToolCursor();
      });
      document.getElementById("shortcutsBtn").addEventListener("click", showShortcutHelp);
      document.getElementById("shortcutCloseBtn").addEventListener("click", closeShortcutHelp);
      if (shortcutModalEl) {
        shortcutModalEl.addEventListener("pointerdown", (e) => {
          if (e.target === shortcutModalEl) closeShortcutHelp();
        });
      }
      document.getElementById("downloadErrorLogBtn").addEventListener("click", downloadErrorLog);
      document.getElementById("dismissErrorNoticeBtn").addEventListener("click", dismissErrorNotice);

      bindClick("newCanvas", newCanvas);
      document.getElementById("addRect").addEventListener("click", addRect);
      document.getElementById("addLine").addEventListener("click", addLine);
      document.getElementById("addArrow").addEventListener("click", addArrow);
      document.getElementById("addEllipse").addEventListener("click", addEllipse);
      document.getElementById("addText").addEventListener("click", addText);
      bindClick("undoBtn", undo);
      bindClick("redoBtn", redo);
      bindClick("copyBtn", copySelected);
      bindClick("cutBtn", cutSelected);
      bindClick("pasteBtn", () => {
        // Avoid browser permission prompts on every click.
        pasteInternalClipboard();
      });
      bindClick("pasteReportBtn", showPasteReport);
      bindClick("copyPasteReportBtn", copyPasteReport);
      bindClick("downloadPasteReportBtn", downloadPasteReport);
      bindClick("pasteHistoryBtn", showPasteReportHistory);
      bindClick("copyPasteHistoryBtn", copyPasteReportHistory);
      bindClick("clearPasteHistoryBtn", clearPasteReportHistory);
      document.getElementById("groupBtn").addEventListener("click", groupSelected);
      document.getElementById("ungroupBtn").addEventListener("click", ungroupSelected);
      document.getElementById("duplicateBtn").addEventListener("click", duplicateSelected);
      bindClick("saveSvg", saveSvg);
      bindClick("exportPdf", exportPdf);

      document.querySelectorAll("[data-align]").forEach((btn) => {
        btn.addEventListener("click", () => alignSelected(btn.dataset.align));
      });
      document.querySelectorAll("[data-distribute]").forEach((btn) => {
        btn.addEventListener("click", () => distributeSelected(btn.dataset.distribute));
      });
      document.getElementById("alignBasisSelect").addEventListener("change", (e) => {
        const value = e.target.value === "first" ? "first" : "bbox";
        state.alignBasis = value;
        localStorage.setItem(ALIGN_BASIS_KEY, value);
        setStatus(`Align base: ${value === "first" ? "first selected" : "selection box"}`);
      });
      document.getElementById("arrowSizeInput").addEventListener("change", () => {
        if (state.selectedIds.length !== 1) return;
        const selected = getById(state.selectedIds[0]);
        if (!(selected instanceof SVGElement) || selected.tagName !== "line" || selected.dataset.arrow !== "1") return;
        const { size, stroke } = getArrowControlValues();
        applyArrowStyle(selected, size, stroke);
        pushHistory("arrow-style");
        setStatus("Arrow style updated.");
      });
      document.getElementById("arrowSizeInput").addEventListener("input", () => {
        if (state.selectedIds.length !== 1) return;
        const selected = getById(state.selectedIds[0]);
        if (!(selected instanceof SVGElement) || selected.tagName !== "line" || selected.dataset.arrow !== "1") return;
        const { size, stroke } = getArrowControlValues();
        applyArrowStyle(selected, size, stroke);
      });
      document.getElementById("arrowStrokeInput").addEventListener("change", () => {
        applyStrokeControlToSelectedLines({ push: true, withStatus: true });
      });
      document.getElementById("arrowStrokeInput").addEventListener("input", () => {
        applyStrokeControlToSelectedLines({ push: false, withStatus: false });
      });

      const fileInput = document.getElementById("openFileInput");
      bindClick("openSvg", () => {
        if (fileInput) fileInput.click();
      });
      if (fileInput) fileInput.addEventListener("change", async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        try {
          const text = await file.text();
          loadSvgText(text);
        } catch (err) {
          setStatus("File read failed. Please select a valid SVG file.");
          captureError("open-file-read", err, { userMessage: "File read failed." });
        }
        fileInput.value = "";
      });

      document.getElementById("autosaveSelect").addEventListener("change", updateAutosaveTimer);
      document.getElementById("restoreLatest").addEventListener("click", restoreLatest);
      document.getElementById("toggleAdvanced").addEventListener("click", () => {
        if (!document.body.classList.contains("compact")) return;
        document.body.classList.toggle("show-advanced");
        setStatus(document.body.classList.contains("show-advanced") ? "Advanced restore options shown." : "Advanced restore options hidden.");
      });
      document.getElementById("restoreFromList").addEventListener("click", restoreFromList);
      canvasWrapEl.addEventListener("wheel", (e) => {
        if (!(e.ctrlKey || e.metaKey)) return;
        e.preventDefault();
        const factor = Math.exp((-e.deltaY || 0) * 0.002);
        zoomByFactor(factor, e.clientX, e.clientY, { silent: true });
      }, { passive: false });
      canvasWrapEl.addEventListener("touchstart", (e) => {
        if (e.touches.length < 2) return;
        const metrics = getTouchMetrics(e.touches);
        if (!metrics || metrics.distance < 4) return;
        state.pinch.active = true;
        state.pinch.startScale = state.viewScale || 1;
        state.pinch.startDistance = metrics.distance;
        if (state.interaction) state.interaction = null;
        requestSelectionVisualRefresh();
        e.preventDefault();
      }, { passive: false });
      canvasWrapEl.addEventListener("touchmove", (e) => {
        if (!state.pinch.active || e.touches.length < 2) return;
        const metrics = getTouchMetrics(e.touches);
        if (!metrics || metrics.distance < 4) return;
        const factor = metrics.distance / Math.max(state.pinch.startDistance, 1);
        setCanvasZoom((state.pinch.startScale || 1) * factor, metrics.centerX, metrics.centerY, { silent: true });
        e.preventDefault();
      }, { passive: false });
      const finishPinch = () => {
        if (!state.pinch.active) return;
        state.pinch.active = false;
        state.pinch.startScale = state.viewScale || 1;
        state.pinch.startDistance = 0;
        setStatus(`Zoom ${Math.round((state.viewScale || 1) * 100)}%.`);
      };
      canvasWrapEl.addEventListener("touchend", (e) => {
        if (e.touches.length >= 2) return;
        finishPinch();
      }, { passive: true });
      canvasWrapEl.addEventListener("touchcancel", () => {
        finishPinch();
      }, { passive: true });

      canvas.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        const raw = closestEditableTarget(e.target);
        let target = null;
        if (raw) {
          target = resolveTargetByTool(raw);
          if (target?.dataset?.id && !state.selectedIds.includes(target.dataset.id)) {
            setSelection([target.dataset.id]);
          }
        }
        let group = null;
        if (target) {
          group = target.tagName === "g" ? target : resolveOuterGroup(target);
        } else if (state.selectedIds.length === 1) {
          const selected = getById(state.selectedIds[0]);
          if (selected) group = selected.tagName === "g" ? selected : resolveOuterGroup(selected);
        }
        const groupId = group && group.tagName === "g" ? group.dataset.id || "" : "";
        openContextMenu(e.clientX, e.clientY, { groupId, targetId: target?.dataset?.id || "" });
      });

      ctxMenu.addEventListener("click", (e) => {
        const btn = e.target.closest("button[data-ctx-action]");
        if (!btn || btn.disabled) return;
        const action = btn.dataset.ctxAction || "";
        if (action === "copy") copySelected();
        if (action === "cut") cutSelected();
        if (action === "paste") pasteInternalClipboard();
        if (action === "mark") promptGroupMark();
        if (action === "mark-clear") clearGroupMark();
        if (action === "group") groupSelected();
        if (action === "ungroup") ungroupSelected();
        if (action === "duplicate") duplicateSelected();
        closeContextMenu();
      });

      window.addEventListener("pointerdown", (e) => {
        if (e.button !== 0) return;
        focusPasteSink();
        if (!ctxMenu.contains(e.target)) closeContextMenu();
      });

      canvas.addEventListener("pointerdown", (e) => {
        if (e.button !== 0) return;
        if (state.pinch.active) return;
        focusPasteSink();
        closeContextMenu();
        const handleEl = e.target instanceof SVGElement ? e.target.closest(".selection-handle") : null;
        if (handleEl instanceof SVGElement) {
          const pt = getSvgPoint(e.clientX, e.clientY);
          const targetId = handleEl.dataset.targetId;
          const handle = handleEl.dataset.handle || "se";
          const target = targetId ? getById(targetId) : null;
          beginResize(pt, target, handle);
          if (state.interaction) state.interaction.pointerId = e.pointerId;
          if (canvas.setPointerCapture) canvas.setPointerCapture(e.pointerId);
          return;
        }
        const pt = getSvgPoint(e.clientX, e.clientY);
        const raw = closestEditableTarget(e.target);
        const stack = getEditableTargetsAtPoint(e.clientX, e.clientY);
        const hasCanvasHit = !!raw || stack.length > 0;
        if (hasCanvasHit) {
          let target = null;
          if (state.tool === "direct") {
            const directRaw = pickDirectTargetFromStack(stack) || raw || null;
            const directA = resolveDirectTextLikeTarget(directRaw);
            const labelNear = findNearestLabelLikeTargetByPoint(pt, 44);
            if (labelNear && (!directA || directA.tagName === "g")) {
              target = resolveDirectTextLikeTarget(labelNear.el);
            } else if (labelNear && directA) {
              const db = safeBBox(directA);
              const dDist = db ? rectDistanceToPoint(pt, db) : 1e9;
              if (labelNear.dist + 2 < dDist || (!isTextLikeElement(directA) && labelNear.dist <= 10)) {
                target = resolveDirectTextLikeTarget(labelNear.el);
              }
            }
            if (!target && directA) {
              target = directA;
            }
            if (!target) {
              const byBox = findEditableTargetByBBoxPoint(pt, false) || findNearestEditableTargetByPoint(pt, false, 28);
              target = resolveDirectTextLikeTarget(byBox);
            }
            if (!target) {
              const textNear = findNearestEditableTargetByPoint(pt, true, 20, true);
              target = resolveDirectTextLikeTarget(textNear);
            }
            if (!target && labelNear) {
              target = resolveDirectTextLikeTarget(labelNear.el);
            }
          } else {
            target = resolveTargetByTool(raw);
          }
          if (!target || !target.dataset.id) return;
          const id = target.dataset.id;
          if (e.shiftKey) {
            toggleSelection(id);
            return;
          }
          if (state.selectedIds.length !== 1 || state.selectedIds[0] !== id) setSelection([id]);
          beginDrag(pt);
          if (state.interaction) state.interaction.pointerId = e.pointerId;
          if (canvas.setPointerCapture) canvas.setPointerCapture(e.pointerId);
          return;
        }
        beginMarquee(pt, e.shiftKey);
        if (state.interaction) state.interaction.pointerId = e.pointerId;
        if (canvas.setPointerCapture) canvas.setPointerCapture(e.pointerId);
        if (!e.shiftKey) clearSelection();
      });

      canvas.addEventListener("dblclick", (e) => {
        let textEl = null;
        if (e.target instanceof SVGElement) {
          const t = e.target.closest("text");
          if (t instanceof SVGElement) textEl = t;
        }
        if (!textEl) {
          const stack = getEditableTargetsAtPoint(e.clientX, e.clientY);
          const t = stack.find((node) => node instanceof SVGElement && node.tagName === "text" && !isGroupLabel(node));
          if (t instanceof SVGElement) textEl = t;
        }
        if (!textEl && state.selectedIds.length === 1) {
          const selected = getById(state.selectedIds[0]);
          if (selected instanceof SVGElement && selected.tagName === "text" && !isGroupLabel(selected)) {
            textEl = selected;
          }
        }
        if (!(textEl instanceof SVGElement) || !textEl.dataset.id || isGroupLabel(textEl)) return;
        e.preventDefault();
        openInlineTextEditor(textEl);
      });

      textEditorInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          closeInlineTextEditor(true);
        }
        if (e.key === "Escape") {
          e.preventDefault();
          closeInlineTextEditor(false);
          setStatus("Text edit canceled.");
        }
      });
      textEditorInput.addEventListener("blur", () => {
        closeInlineTextEditor(true);
      });

      window.addEventListener("pointermove", (e) => {
        const it = state.interaction;
        if (!it) return;
        if (it.pointerId !== null && e.pointerId !== it.pointerId) return;
        const pt = getSvgPoint(e.clientX, e.clientY);
        if (it.type === "drag") updateDrag(pt);
        if (it.type === "resize") updateResize(pt, e.shiftKey);
        if (it.type === "marquee") updateMarquee(pt);
      });

      window.addEventListener("pointerup", (e) => {
        const it = state.interaction;
        if (!it) return;
        if (it.pointerId !== null && e.pointerId !== it.pointerId) return;
        const capturedId = it.pointerId;
        const type = it.type;
        if (type === "drag") finishDrag();
        if (type === "resize") finishResize();
        if (type === "marquee") finishMarquee();
        if (capturedId !== null && canvas.releasePointerCapture) {
          try { canvas.releasePointerCapture(capturedId); } catch (_) {}
        }
      });

      window.addEventListener("pointercancel", (e) => {
        if (!state.interaction) return;
        if (state.interaction.pointerId !== null && e.pointerId !== state.interaction.pointerId) return;
        const capturedId = state.interaction.pointerId;
        state.interaction = null;
        if (capturedId !== null && canvas.releasePointerCapture) {
          try { canvas.releasePointerCapture(capturedId); } catch (_) {}
        }
      });

      window.addEventListener("keydown", (e) => {
        if (state.textEdit) {
          return;
        }
        if (e.key === "Escape" && closeShortcutHelp()) {
          e.preventDefault();
          return;
        }
        if (e.key === "Escape" && state.activeMenu) {
          e.preventDefault();
          closeAppMenus();
          return;
        }
        if (e.key === "Escape") {
          closeInlineTextEditor(false);
          closeContextMenu();
          clearSelection();
          return;
        }
        if (e.key === "Delete" || e.key === "Backspace") {
          if (!state.selectedIds.length) return;
          e.preventDefault();
          getTopSelectedElements().forEach((el) => el.remove());
          clearSelection();
          pushHistory("delete");
          return;
        }
        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
          if (!state.selectedIds.length) return;
          e.preventDefault();
          const step = e.shiftKey ? 10 : 1;
          if (e.key === "ArrowUp") moveSelection(0, -step, { reason: "move-key", coalesce: true, withinMs: 300 });
          if (e.key === "ArrowDown") moveSelection(0, step, { reason: "move-key", coalesce: true, withinMs: 300 });
          if (e.key === "ArrowLeft") moveSelection(-step, 0, { reason: "move-key", coalesce: true, withinMs: 300 });
          if (e.key === "ArrowRight") moveSelection(step, 0, { reason: "move-key", coalesce: true, withinMs: 300 });
        }
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "z") {
          e.preventDefault();
          if (e.shiftKey) redo(); else undo();
        }
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "y") {
          e.preventDefault();
          redo();
        }
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "d") {
          e.preventDefault();
          duplicateSelected();
        }
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "c") {
          e.preventDefault();
          copySelected();
        }
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "x") {
          e.preventDefault();
          cutSelected();
        }
        if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey && e.key.toLowerCase() === "r") {
          e.preventDefault();
          addRect();
          setStatus("Added Rect.");
          return;
        }
        if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey && e.key.toLowerCase() === "l") {
          e.preventDefault();
          addLine();
          setStatus("Added Line.");
          return;
        }
        if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey && e.key.toLowerCase() === "q") {
          e.preventDefault();
          addArrow();
          setStatus("Added Arrow.");
          return;
        }
        if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey && e.key.toLowerCase() === "e") {
          e.preventDefault();
          addEllipse();
          setStatus("Added Ellipse.");
          return;
        }
        if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey && e.key.toLowerCase() === "t") {
          e.preventDefault();
          addText();
          setStatus("Added Text.");
          return;
        }
        if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey && e.key.toLowerCase() === "v") {
          e.preventDefault();
          state.tool = "select";
          document.getElementById("toolSelect").classList.add("active");
          document.getElementById("toolDirect").classList.remove("active");
          updateToolCursor();
          setStatus("Tool: Black Arrow");
          return;
        }
        if (!e.ctrlKey && !e.metaKey && !e.altKey && !e.shiftKey && e.key.toLowerCase() === "a") {
          e.preventDefault();
          state.tool = "direct";
          document.getElementById("toolDirect").classList.add("active");
          document.getElementById("toolSelect").classList.remove("active");
          updateToolCursor();
          setStatus("Tool: White Arrow");
          return;
        }
        if ((e.key === "Enter" || e.key === "F2") && !e.ctrlKey && !e.metaKey && !e.altKey) {
          if (state.selectedIds.length !== 1) return;
          const selected = getById(state.selectedIds[0]);
          if (!(selected instanceof SVGElement) || selected.tagName !== "text" || isGroupLabel(selected)) return;
          e.preventDefault();
          openInlineTextEditor(selected);
          return;
        }
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === "v") {
          e.preventDefault();
          pasteInternalClipboard();
          return;
        }
        if ((e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey && e.key.toLowerCase() === "v") {
          // Prefer OS paste path; if no external payload arrives, fallback to internal clipboard.
          focusPasteSink();
          if (state.pendingInternalPasteTimer) clearTimeout(state.pendingInternalPasteTimer);
          const before = Date.now();
          state.pendingInternalPasteTimer = window.setTimeout(() => {
            state.pendingInternalPasteTimer = 0;
            if (state.lastExternalPasteAt > before) return;
            if (!state.clipboardItems.length) return;
            pasteInternalClipboard();
          }, 90);
        }
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === "r") {
          e.preventDefault();
          restoreLatest();
        }
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === "i") {
          e.preventDefault();
          showPasteReport();
        }
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === "j") {
          e.preventDefault();
          copyPasteReport();
        }
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === "k") {
          e.preventDefault();
          downloadPasteReport();
        }
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === "h") {
          e.preventDefault();
          showPasteReportHistory();
        }
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === "u") {
          e.preventDefault();
          copyPasteReportHistory();
        }
        if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === "l") {
          e.preventDefault();
          clearPasteReportHistory();
        }
        if ((e.ctrlKey || e.metaKey) && e.key === "/") {
          e.preventDefault();
          showShortcutHelp();
        }
      });

      window.addEventListener("paste", handlePaste);
      document.addEventListener("paste", handlePaste);
      canvasWrapEl.addEventListener("paste", handlePaste);
      if (pasteSinkEl) pasteSinkEl.addEventListener("paste", handlePaste);
      window.addEventListener("focus", focusPasteSink);
      window.addEventListener("resize", renderStatus);
      window.addEventListener("beforeunload", () => {
        if (document.getElementById("autosaveSelect").value !== "off") saveAutosave();
      });
    }

    function initialize() {
      setupGlobalErrorHandlers();
      setupEventRingHooks();
      assignIds();
      syncCanvasDisplaySizeFromViewBox();
      setupEvents();
      focusPasteSink();
      updateToolCursor();
      try {
        const lastErr = JSON.parse(localStorage.getItem(LAST_ERROR_KEY) || "null");
        if (lastErr && typeof lastErr === "object" && lastErr.id) {
          state.lastErrorRecord = lastErr;
          // Keep record for download, but don't auto-show stale notice on every startup.
          setStatus(`Previous error record loaded: ${lastErr.id}`);
          localStorage.removeItem(LAST_ERROR_KEY);
        }
      } catch (_) {}
      try {
        const parsed = JSON.parse(localStorage.getItem(PASTE_REPORT_KEY) || "null");
        if (parsed && typeof parsed === "object" && parsed.route) {
          state.lastPasteReport = parsed;
        }
      } catch (_) {}
      try {
        const history = JSON.parse(localStorage.getItem(PASTE_REPORT_HISTORY_KEY) || "[]");
        if (Array.isArray(history)) {
          state.pasteReportHistory = history.filter((r) => r && typeof r === "object" && r.route).slice(-30);
        }
      } catch (_) {}
      const interval = localStorage.getItem(AUTOSAVE_INTERVAL_KEY) || "off";
      document.getElementById("autosaveSelect").value = ["off", "10", "30"].includes(interval) ? interval : "off";
      const alignBasis = localStorage.getItem(ALIGN_BASIS_KEY);
      state.alignBasis = alignBasis === "first" ? "first" : "bbox";
      document.getElementById("alignBasisSelect").value = state.alignBasis;
      refreshRestoreList();
      updateAutosaveTimer();
      pushHistory("init");
      setStatus("Figure Maker ready.");
    }

    initialize();
  </script>
</body>
</html>
